<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[阅读笔记]区块链原理、设计与应用-01</title>
      <link href="/2020/01/02/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8-01/"/>
      <url>/2020/01/02/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-%E5%8C%BA%E5%9D%97%E9%93%BE%E5%8E%9F%E7%90%86%E3%80%81%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%BA%94%E7%94%A8-01/</url>
      
        <content type="html"><![CDATA[<h2 id="区块链核心技术概述"><a href="#区块链核心技术概述" class="headerlink" title="区块链核心技术概述"></a>区块链核心技术概述</h2><h3 id="定义与原理"><a href="#定义与原理" class="headerlink" title="定义与原理"></a>定义与原理</h3><p>区块链（blockchain）思想最早出现在中本聪的比特币（Bitcoin）开源项目中，首次真正从实践意义上实现安全可靠的<strong>去中心化</strong>数字货币机制。</p><p>而后比特币背后的区块链技术逐渐走上台面，进而引出了<strong>分布式记账本</strong>（distributed ledger）的可行实现。</p><p>区块链特点：</p><ul><li>分布式鲁棒性，能够容忍部分节点异常</li><li>不可篡改</li><li>密码学保证隐私受保护</li><li>提供天然可信的分布式记账本平台，不需要第三方中介</li><li><p>维护成本降低（深入应用的关键性要求）</p><p>区块链的基本原理：</p><ul><li>交易（transaction）：一次对账本的操作，导致其状态的一次转变</li><li>区块（block）：记录一段时间内发生所有交易和状态结果，是对当前账本状态的一次共识</li><li>链（chain）：由区块链按照发生顺序串联而成，使整个账本状态变化的日志记录</li></ul><p>一个只允许添加不允许删除的分布式记账本，账本底层结构为一个线性链表，链表由一个个区块串联组成，结构示例如下：<br><img alt="区块链结构示例" data-src="https://i.loli.net/2020/01/01/N5yHPMo1wvElRUb.png" class="lozad"></p><p>区块链的安全性主要来自于hash值及工作量证明来得以保障。同时分布式（p2p网络）也保证了自身的安全性。</p><p>比特币中基于算力去寻找一个nonce串（随机串），使待放入的候选区块的哈希结果满足一定条件后放到区块网络中，最终达成共识，这种方式称为<strong>工作量证明</strong>（Proof of Work，PoW）-&gt;（基于概率理论上允许不超过一半的不合作节点）。该过程无快速启发式算法，只能不断去演算尝试去找到符合条件的nonce串。 计算新区块的过程称为<strong>挖矿</strong>，即通过调节对哈希结果的限制（即算法难度n），比特币网络控制平均约10分钟产生一个合理区块。</p><p>算出区块的节点将得到该区块中所有交易的管理费和协议固定发放的奖励费（每四年减半），亦即<strong>打包奖励</strong>。</p><p>区块链上执行的处理过程进一步泛化，即所谓的提供<strong>智能合约</strong>（smart constract），完成更加复杂的功能。</p><h3 id="技术演化与分类"><a href="#技术演化与分类" class="headerlink" title="技术演化与分类"></a>技术演化与分类</h3><p>区块链技术的三种典型演化场景：</p></li></ul><div class="table-container"><table><thead><tr><th>场景</th><th>功能</th><th>智能合约</th><th>一致性</th><th>权限</th><th>类型</th><th>性能</th><th>编程语言</th><th>代表</th></tr></thead><tbody><tr><td>公信的数字货币</td><td>记账功能</td><td>不带有或较弱</td><td>PoW</td><td>无</td><td>公有链</td><td>较低</td><td>简单脚本</td><td>比特币网络</td></tr><tr><td>公信的交易处理</td><td>智能合约</td><td>图灵完备</td><td>PoW、PoS</td><td>无</td><td>公有链</td><td>受限</td><td>特定语言</td><td>以太坊网络</td></tr><tr><td>带权限的分布式账本处理</td><td>商业处理</td><td>多种语言，图灵完备</td><td>包括CFT、BFT在内的多种机制，可插拔</td><td>支持</td><td>联盟链</td><td>可扩展</td><td>高级编程语言</td><td>超级账本</td></tr></tbody></table></div><p>区块链因为只允许达成共识的区块加入到区块网络中，所以其本身自带对账功能。属于一种去中心化的记录技术，本身网络中的节点无需彼此信任，链内数据由所有节点共同维护，每个维护节点都能复制获得一份完整或部分记录的拷贝。</p><p>基于区块链的分布式账本应该包括：</p><ul><li>一条不断增长链，只增不篡改</li><li>去中心化，无需集中控制而达成共识，分布式</li><li>密码学保证无法被抵赖和破坏，同时尽量保护隐私</li></ul><p>根据参与者的不同进行分类：</p><ul><li>公有链：任何人参与使用和维护，信息全公开<br>下述为进一步引入许可机制：</li><li>私有链：集中管理者进行管理限制，内部少部分人可使用，信息不公开</li><li>联盟链：介于两者之间，必须带权限的限制访问。</li></ul><h3 id="关键问题和挑战"><a href="#关键问题和挑战" class="headerlink" title="关键问题和挑战"></a>关键问题和挑战</h3><h4 id="抗抵赖和隐私保护的层面："><a href="#抗抵赖和隐私保护的层面：" class="headerlink" title="抗抵赖和隐私保护的层面："></a>抗抵赖和隐私保护的层面：</h4><p>传统方案：Hash算法、加解密算法、数字证书和签名（盲签名、环签名）等。</p><h4 id="达成分布式共识："><a href="#达成分布式共识：" class="headerlink" title="达成分布式共识："></a>达成分布式共识：</h4><p>共识问题核心的指标包括：容错的节点比例、决策收敛速度、出错后的恢复、动态特性等。</p><p>比特币区块链考虑的是公开匿名场景下的最坏保证：通过引入PoW来规避少数人的恶意行为，并通过概率模型保证最后参与方共识到最长链，核心思想是基于经济利益的博弈，恶意破坏者损失利益保证大部人的合作，同时确认必须经过多个区块生成之后达成，从概率上保证。类似的由以权益为抵押的PoS、DPoS和Casper等。</p><p>带权限管理的场景下开始考虑支持更多的确定性共识机制，如拜占庭算法等，可解决快速确认的问题。</p><p>同时在交易性能、拓展性能、安全防护、数据库和存储系统和集成与运营等方面仍存在很多需要考量的地方。</p><p>这里需要认清一点，区块链不等于比特币，它也不等于数据库，因为它解决的是多方合作以及互信的问题，单纯从存储数据的角度，它的效率可能并不高，也不推荐把大量的原始数据放到区块链系统上。</p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>《区块链原理、设计与应用》</li><li><a href="https://www.youtube.com/watch?v=SSo_EIwHSd4" target="_blank" rel="noopener">区块链如何运作 - 简单解释</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我是否可以摆脱午睡</title>
      <link href="/2019/12/18/%E6%88%91%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%91%86%E8%84%B1%E5%8D%88%E7%9D%A1/"/>
      <url>/2019/12/18/%E6%88%91%E6%98%AF%E5%90%A6%E5%8F%AF%E4%BB%A5%E6%91%86%E8%84%B1%E5%8D%88%E7%9D%A1/</url>
      
        <content type="html"><![CDATA[<p>一直以来其实自己都有这么一个困惑：<strong>我是否可以摆脱午睡？</strong> 每每准确地到达那个时间段时，疲惫也好、心理暗示也罢，总会催促着自己赶紧上床歇息，于是乎两个小时就这么过去了（不得不在这里提一下，我是一位极易睡到恍惚的人，甚至自己会在不自觉地情况下按掉闹钟，所以每当下午有重要事宜的时候，我甚至会害怕自己去午睡，我真的太难了）</p><p>为什么很多西方人不午睡下午也能满血状态的工作呢？难道不应该是传统的午休（我好难做到的qwq）下午才会来的更加精神饱满吗？这样的问题不止一次出现在我的每日一问当中。</p><p>看了知友们的回答，立脚点各不相同，众说纷纭的解释都有待自己亲身去检验，所以我估计后续会有一个自己的计划表，检验下是否能够让自己摆脱午睡的厄运，哈哈</p><p>Schedules（2019/12/18）：</p><ol><li><strong>饭前一大杯水</strong>，产生饱腹感，同时午餐尽量保持在7-8分饱；</li><li><strong>coffee</strong> or <strong>tea</strong>，每天间歇性饮用</li><li><strong>饭后散步</strong>一小会，减少疲惫感</li><li><strong>紧迫的工作观念</strong>，说实话这是我后续工作迫切需要加强的一点</li><li><strong>坚持</strong>就是胜利，奥里给！</li></ol><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>知乎话题讨论：<a href="https://www.zhihu.com/question/25569759" target="_blank" rel="noopener">“为什么很多欧洲人和美国人不午睡下午还能满血状态工作？”</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue.js文档学习</title>
      <link href="/2019/12/16/Vue-js%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/16/Vue-js%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="Vue框架学习"><a href="#Vue框架学习" class="headerlink" title="Vue框架学习"></a>Vue框架学习</h1><h2 id="Part-1-初步认识Vue"><a href="#Part-1-初步认识Vue" class="headerlink" title="Part 1.初步认识Vue"></a>Part 1.初步认识Vue</h2><p>Vue是一套用于构建用户界面的<strong>渐进式框架</strong>。可以自底向上逐层应用，核心库只关注视图层，</p><p>引入Vue你需要在你html的head中键入<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 开发环境版本，包含了有帮助的命令行警告 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue/dist/vue.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 生产环境版本，优化了尺寸和速度 --&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdn.jsdelivr.net/npm/vue"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>对于你自己所编写的js文件，你需要在<strong>body底部</strong>，即<strong>最末行</strong>来进行引用</p><h2 id="Part-2-Vue实例"><a href="#Part-2-Vue实例" class="headerlink" title="Part 2.Vue实例"></a>Part 2.Vue实例</h2><h3 id="创建一个-Vue-实例"><a href="#创建一个-Vue-实例" class="headerlink" title="创建一个 Vue 实例"></a>创建一个 Vue 实例</h3><p>通过new方法去创建Vue实例：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;  </span><br><span class="line">    <span class="comment">// 选项</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></p><p>当创建一个 Vue 实例时，你可以传入一个选项对象，接下来就将主要描述如何使用这些选项来创建你想要的行为。API文档浏览<a href="https://vuejs.bootcss.com/v2/api/#%E9%80%89%E9%A1%B9-%E6%95%B0%E6%8D%AE" target="_blank" rel="noopener">完整的选项列表</a></p><p>一个Vue应用由<br>一个通过new Vue创建的根Vue实例<br>，以及可选的嵌套的、可复用的组件树组成。</p><h3 id="数据与方法"><a href="#数据与方法" class="headerlink" title="数据与方法"></a>数据与方法</h3><p>在Vue的响应式系统中，其data对象中包含了所有的属性。当实例被创建时data中存在的属性才是响应式的（即随之更新，视图重渲染）。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 我们的数据对象 </span></span><br><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125; </span><br><span class="line"><span class="comment">// 该对象被加入到一个 Vue 实例中 var vm = new Vue(&#123; </span></span><br><span class="line">    data: data </span><br><span class="line">&#125;) </span><br><span class="line"><span class="comment">// 获得这个实例上的属性</span></span><br><span class="line"><span class="comment">// 返回源数据中对应的字段 </span></span><br><span class="line">vm.a == data.a <span class="comment">// =&gt; true </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置属性也会影响到原始数据 </span></span><br><span class="line">vm.a = <span class="number">2</span> </span><br><span class="line">data.a <span class="comment">// =&gt; 2 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ……反之亦然 </span></span><br><span class="line">data.a = <span class="number">3</span> </span><br><span class="line">vm.a <span class="comment">// =&gt; 3</span></span><br></pre></td></tr></table></figure></p><p>除遇到Object.freeze()函数，这会阻止修改现有的属性</p><p>Vue实例存在有以<code>$</code>为前缀的属性及方法，与用户定义的属性区分开。<a href="https://vuejs.bootcss.com/v2/api/#%E5%AE%9E%E4%BE%8B%E5%B1%9E%E6%80%A7" target="_blank" rel="noopener">API文档</a></p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> data = &#123; <span class="attr">a</span>: <span class="number">1</span> &#125;</span><br><span class="line"><span class="keyword">var</span> vm = <span class="keyword">new</span> Vue(&#123;  </span><br><span class="line">    el: <span class="string">'#example'</span>,  </span><br><span class="line">    data: data</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">vm.$data === data <span class="comment">// =&gt; true</span></span><br><span class="line">vm.$el === <span class="built_in">document</span>.getElementById(<span class="string">'example'</span>) <span class="comment">// =&gt; true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// $watch 是一个实例方法</span></span><br><span class="line">vm.$watch(<span class="string">'a'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">newValue, oldValue</span>) </span>&#123; </span><br><span class="line">    <span class="comment">// 这个回调将在 `vm.a` 改变后调用</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>生命周期钩子，可在实例生命周期的不同阶段被调用去执行特定的代码，<br>生命周期钩子的this上下文都指向调用它的Vue实例。</p><p><strong>不要</strong>在选项属性或回调上使用箭头函数，比如 <code>created: () =&gt; console.log(this.a)</code>或<code>vm.$watch(&#39;a&#39;, newValue =&gt; this.myMethod())。</code>因为箭头函数并没有 this，this 会作为变量一直向上级词法作用域查找，直至找到为止，经常导致 <code>Uncaught TypeError: Cannot read property of undefined</code> 或 <code>Uncaught TypeError: this.myMethod is not a function</code> 之类的错误。</p><p><img alt="实例生命周期" data-src="https://cn.vuejs.org/images/lifecycle.png" class="lozad"></p><h2 id="Part-0-Reference"><a href="#Part-0-Reference" class="headerlink" title="Part 0.Reference"></a>Part 0.Reference</h2><ol><li>Vue官方文档：<a href="https://vuejs.bootcss.com/v2/guide/installation.html" target="_blank" rel="noopener">Vue.js中文文档</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>形成自己的配图体系</title>
      <link href="/2019/12/15/%E5%BD%A2%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E5%9B%BE%E4%BD%93%E7%B3%BB/"/>
      <url>/2019/12/15/%E5%BD%A2%E6%88%90%E8%87%AA%E5%B7%B1%E7%9A%84%E9%85%8D%E5%9B%BE%E4%BD%93%E7%B3%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>文章配图的意义，在于能够简要清晰的传达给读者作者ta所需要表述的观点或细节层面的阐述，在阅读体验上可以给读者带来更加直观的体验，同时在制图的过程中也是自己对于知识点的一次系统的概述性总结，我个人在过去的时间里其实对于配图并不是相当的在意，但当我接触过Xmind去制作知识图谱以后，我愈发觉得其实给技术文章制图配图的过程，有时候也是可以如此的有趣且收获颇多。</p><p>那接下来就进入学习环节吧（选择性摘录博主观点并谈谈自己的看法）:D</p><h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><blockquote><p>『你的图是用什么工具画的？』，我不认为工具在帮助我们配图时起到了决定性的作用，更加重要的其实是我们对于<strong>制图规则</strong>的思考并形成<strong>一套自恰的体系</strong>。</p></blockquote><p>关于制图，确实工具的选择没有自己确定的制图规范来的重要，一套成体系的规范不仅在制图过程中会加快速度，同时后续回看也会更加的易读。</p><blockquote><p>对制图规则的设计，其中有几个准则是非常重要的：</p><ol><li>图片必须足够美观并且清晰地传达想要表现的内容；<ol><li>是技术博客中出现图片的意义；</li></ol></li><li>图片必须能够在短时间内实现量产，不影响写作的效率；<ol><li>博客中的全部图片都是在写作的过程中一一绘制的，而不是最后统一完成的，所以会希望画图的时间可以尽量短，一旦画图的时间超过过长，那么整个思路就会被打断；</li><li>博客的内容和逻辑相比于图片更加重要，作者不希望在上面花费过长的时间；</li></ol></li><li>图片需要保证风格上的一致性，不会显得非常突兀；<ol><li>图片的风格和配色对于作者来说就是签名，形成统一的风格之后会给读者留下比较深的印象；</li></ol></li></ol></blockquote><h2 id="画图"><a href="#画图" class="headerlink" title="画图"></a>画图</h2><blockquote><p>为技术文章绘制图片和使用 PS 修改图片、为 App 绘制 UI 设计图是完全不同的，技术文章的配图主要作用还是为了辅助说明内容，图画的再好看如果不能很好地解释问题都没有太多的作用，相比于图片的样式，我们应该更加关注图片的内容是否清晰和简单。</p></blockquote><h2 id="内容"><a href="#内容" class="headerlink" title="内容"></a>内容</h2><blockquote><p>图片的内容是配图时至关重要的，作者在一个问题太过复杂或者连续的文字过多时，就会选择为文章插入适合的图片，内容作为博客中插图的核心，我们需要清楚地知道需要表达什么</p></blockquote><p>在需要展示某个问题的多个方面、多个原因或者阶段等处于相同层次的概念时就会使用如下所示的图片：<br><img alt data-src="https://i.loli.net/2019/12/15/KRnqr6IvMNU4jXa.png" class="lozad"><br>展示不同概念或者模块之间的关系，流程图、架构图等类型的图片：<br><img alt data-src="https://i.loli.net/2019/12/15/9qBe8IVxsHPF1wS.png" class="lozad"><br><img alt data-src="https://i.loli.net/2019/12/15/SshiYgeFfEb2Q7M.png" class="lozad"><br>展示层次模型等的图片：<br><img alt data-src="https://i.loli.net/2019/12/15/odOqTKFDzAE1Nc7.png" class="lozad"></p><h2 id="样式"><a href="#样式" class="headerlink" title="样式"></a>样式</h2><h3 id="配色"><a href="#配色" class="headerlink" title="配色"></a>配色</h3><p>选择<a href="https://colorhunt.co/palette/7642" target="_blank" rel="noopener">配色体系</a><br><img alt data-src="https://i.loli.net/2019/12/15/X7AMLvYrHPy4RQm.png" class="lozad"></p><h3 id="图片长宽"><a href="#图片长宽" class="headerlink" title="图片长宽"></a>图片长宽</h3><p>比较关键的问题：</p><ol><li>保证图片的宽度一定，长度不要太长；</li><li>保证图片的大小被合理利用；</li></ol><p>目前作者博客的图片宽度都是 <code>1200px</code>（ 我个人小破站默认为<code>900px</code></p><h2 id="字号"><a href="#字号" class="headerlink" title="字号"></a>字号</h2><ol><li>图片标题的字号<code>31px</code>；</li><li>图片非标题的字号 <code>18~20px</code>；</li></ol><h2 id="圆角"><a href="#圆角" class="headerlink" title="圆角"></a>圆角</h2><p>作者一般会选择 <code>15px</code>以下的圆角</p><blockquote><p>画图的工具并不重要，重要的其实是你应该如何形成自己的规则体系，想要为博客配图并不是一件困难的事情，比较困难的是长期坚持并且经常思考，对自己形成的规则不断改善，最终就一定能够做好。</p></blockquote><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li><a href="https://draveness.me/sketch-and-sketch" target="_blank" rel="noopener">技术文章配图指南</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[每天一个知识点]结构布局学习</title>
      <link href="/2019/12/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%BB%93%E6%9E%84%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/12/11/%E6%AF%8F%E5%A4%A9%E4%B8%80%E4%B8%AA%E7%9F%A5%E8%AF%86%E7%82%B9-%E7%BB%93%E6%9E%84%E5%B8%83%E5%B1%80%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h2 id="0-背景知识-calc"><a href="#0-背景知识-calc" class="headerlink" title="0. 背景知识 calc()"></a>0. 背景知识 calc()</h2><p><code>calc()</code>让你在声明CSS属性值时执行部分运算，注意运算符的两边需要留上空格。</p><p>它能够使用指定的外边距去定位一个对象<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.banner</span>&#123;</span><br><span class="line">    <span class="attribute">left</span>:<span class="number">40px</span>;</span><br><span class="line">    <span class="attribute">width</span>:<span class="built_in">calc</span>(100% - 80px);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>或是自动调整表单域的大小来适应它外部容器的大小<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.form</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>:<span class="built_in">calc</span>(100% / 6);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-全背景等宽内容居中"><a href="#1-全背景等宽内容居中" class="headerlink" title="1. 全背景等宽内容居中"></a>1. 全背景等宽内容居中</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="comment">/* 等宽内容居中 */</span></span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">header</span>,</span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">section</span>,</span><br><span class="line"><span class="selector-class">.main</span>&gt;<span class="selector-tag">footer</span>&#123;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">1em</span> <span class="built_in">calc</span>(50% - 329px);</span><br><span class="line">    <span class="attribute">text-align</span>: justify;  </span><br><span class="line">    <span class="attribute">hyphens</span>: auto;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="2-绝对底部（Sticky-Footer）"><a href="#2-绝对底部（Sticky-Footer）" class="headerlink" title="2. 绝对底部（Sticky Footer）"></a>2. 绝对底部（Sticky Footer）</h2><p>Sticky Footer，一种网页效果，内容不够长footer紧贴窗体最底部，内容够长footer紧贴内容下方<br><img alt data-src="https://i.loli.net/2019/12/10/j8YGuWcQwSR7P4A.png" class="lozad"></p><h3 id="方案一：内容负值的底部margin"><a href="#方案一：内容负值的底部margin" class="headerlink" title="方案一：内容负值的底部margin"></a>方案一：内容负值的底部margin</h3><p>让主体内容的高度等于底部脚本footer值的负值<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"wrapper"</span>&gt;</span> </span><br><span class="line">        content </span><br><span class="line">        <span class="comment">&lt;!-- 这里添加了一个push用于避免脚本覆盖了内容，同时方便文本内容的插入 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"push"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span>    </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123;</span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>;</span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.wrapper</span> &#123; </span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>; </span><br><span class="line">    <span class="comment">/* 等于底部 footer 高度*/</span></span><br><span class="line">    <span class="comment">/* 同样也应该考虑可能有的子元素的底边距*/</span> </span><br><span class="line">    <span class="attribute">margin-bottom</span>: -<span class="number">50px</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.footer</span>, <span class="selector-class">.push</span> &#123; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：脚本负值的头部margin"><a href="#方案二：脚本负值的头部margin" class="headerlink" title="方案二：脚本负值的头部margin"></a>方案二：脚本负值的头部margin</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span> </span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content-inside"</span>&gt;</span> </span><br><span class="line">            content </span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span>         </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span>, <span class="selector-tag">body</span> &#123; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>; </span><br><span class="line">    <span class="attribute">margin</span>: <span class="number">0</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.content</span> &#123; </span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.content-inside</span> &#123; </span><br><span class="line">    <span class="attribute">padding</span>: <span class="number">20px</span>; </span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">50px</span>; </span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>; </span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">50px</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案三：calc"><a href="#方案三：calc" class="headerlink" title="方案三：calc()"></a>方案三：calc()</h3><p>通过计算函数<code>calc()</code>计算（视窗高度 - 页脚高度）赋予内容区最小高度<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span> </span><br><span class="line">        content </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;    </span><br><span class="line">    <span class="comment">/* vh -&gt; viewport height（窗口高度） */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="built_in">calc</span>(100vh - 50px); </span><br><span class="line">    <span class="comment">/* 有时候需要将预估的margin-bottom也预估进去一起从窗口高度减去 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;    </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案四：flexbox"><a href="#方案四：flexbox" class="headerlink" title="方案四：flexbox"></a>方案四：flexbox</h3><p>使用flex来设置的好处就是不用固定footer高度<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span> </span><br><span class="line">        content </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.content</span> &#123;    </span><br><span class="line">    <span class="comment">/* vh -&gt; viewport height（窗口高度） */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="built_in">calc</span>(100vh - 50px); </span><br><span class="line">    <span class="comment">/* 有时候需要将预估的margin-bottom也预估进去一起从窗口高度减去 */</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.footer</span> &#123;    </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">50px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案五-grid"><a href="#方案五-grid" class="headerlink" title="方案五 grid"></a>方案五 grid</h3><p>网格布局Grid Layout的实现方式<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"content"</span>&gt;</span> </span><br><span class="line">        content </span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">footer</span> <span class="attr">class</span>=<span class="string">"footer"</span>&gt;</span><span class="tag">&lt;/<span class="name">footer</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></p><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">html</span> &#123; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">100%</span>; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-tag">body</span> &#123; </span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid; </span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">1</span>fr auto; </span><br><span class="line">&#125; </span><br><span class="line"><span class="selector-class">.footer</span> &#123; </span><br><span class="line">    <span class="attribute">grid-row-start</span>: <span class="number">2</span>; </span><br><span class="line">    <span class="attribute">grid-row-end</span>: <span class="number">3</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-水平垂直居中（首选方案1、2、5）"><a href="#3-水平垂直居中（首选方案1、2、5）" class="headerlink" title="3. 水平垂直居中（首选方案1、2、5）"></a>3. 水平垂直居中（首选方案1、2、5）</h2><h3 id="方案一：display-flex-margin-auto-不限定宽高"><a href="#方案一：display-flex-margin-auto-不限定宽高" class="headerlink" title="方案一：display: flex + margin: auto 不限定宽高"></a>方案一：<code>display: flex + margin: auto</code> 不限定宽高</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">152px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">margin</span>: auto;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#b4a078</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案二：display-grid-不限定宽高"><a href="#方案二：display-grid-不限定宽高" class="headerlink" title="方案二：display: grid 不限定宽高"></a>方案二：<code>display: grid</code> 不限定宽高</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">152px</span>;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">justify-content</span>: center;</span><br><span class="line">    <span class="attribute">align-items</span>: center;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#b4a078</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案三：绝对定位-position-absolute-限定宽高"><a href="#方案三：绝对定位-position-absolute-限定宽高" class="headerlink" title="方案三：绝对定位 position: absolute 限定宽高"></a>方案三：绝对定位 <code>position: absolute</code> 限定宽高</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">152px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>; <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">margin-top</span>: -<span class="number">16px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">72px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案四：绝对定位-position-absolute-calc-限定宽高"><a href="#方案四：绝对定位-position-absolute-calc-限定宽高" class="headerlink" title="方案四：绝对定位 position: absolute + calc() 限定宽高"></a>方案四：绝对定位 <code>position: absolute + calc()</code> 限定宽高</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">152px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="built_in">calc</span>(50% - 16px); </span><br><span class="line">    <span class="attribute">left</span>: <span class="built_in">calc</span>(50% - 72px);</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#b4a078</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案五：绝对定位-position-absolute-translate-不限定宽高"><a href="#方案五：绝对定位-position-absolute-translate-不限定宽高" class="headerlink" title="方案五：绝对定位 position: absolute + translate 不限定宽高"></a>方案五：绝对定位 <code>position: absolute + translate</code> 不限定宽高</h3><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"> <span class="selector-tag">main</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">152px</span>;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">main</span> &gt; <span class="selector-tag">span</span> &#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">50%</span>; <span class="attribute">left</span>: <span class="number">50%</span>;</span><br><span class="line">    <span class="attribute">background</span>: <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">color</span>: white;</span><br><span class="line">    <span class="attribute">padding</span>: .<span class="number">3em</span> <span class="number">1em</span> .<span class="number">5em</span>;</span><br><span class="line">    <span class="attribute">border-radius</span>: <span class="number">3px</span>;</span><br><span class="line">    <span class="attribute">box-shadow</span>: <span class="number">0</span> <span class="number">0</span> .<span class="number">5em</span> <span class="number">#b4a078</span>;</span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">translate</span>(-50%, -50%);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="方案六：仿table布局-display-table-table-cell-vertical-align-middle-不限定宽高"><a href="#方案六：仿table布局-display-table-table-cell-vertical-align-middle-不限定宽高" class="headerlink" title="方案六：仿table布局 display: table/table-cell + vertical-align: middle 不限定宽高"></a>方案六：仿table布局 <code>display: table/table-cell + vertical-align: middle</code> 不限定宽高</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined">5</span></span><br><span class="line"><span class="undefined">  main &#123;</span></span><br><span class="line"><span class="undefined">    width: 100%;</span></span><br><span class="line"><span class="undefined">    height: 152px;</span></span><br><span class="line"><span class="undefined">    display: table;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">main &gt; div &#123;</span></span><br><span class="line"><span class="undefined">    display: table-cell;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">    vertical-align: middle;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">main &gt; div &gt; span &#123;</span></span><br><span class="line"><span class="undefined">    width: 50%;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#b4a078</span>;</span></span><br><span class="line"><span class="undefined">    color: white;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span>: <span class="selector-class">.3em</span> 1<span class="selector-tag">em</span> <span class="selector-class">.5em</span>;</span></span><br><span class="line"><span class="undefined">    border-radius: 3px;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">box-shadow</span>: 0 0 <span class="selector-class">.5em</span> <span class="selector-id">#b4a078</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span>&gt;</span><span class="tag">&lt;<span class="name">span</span>&gt;</span>Center me, please!<span class="tag">&lt;/<span class="name">span</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="方案七：伪元素-after-vertical-align-middle-不限定宽高"><a href="#方案七：伪元素-after-vertical-align-middle-不限定宽高" class="headerlink" title="方案七：伪元素 :after + vertical-align:middle 不限定宽高"></a>方案七：伪元素 :<code>after + vertical-align:middle</code> 不限定宽高</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">  main &#123;</span></span><br><span class="line"><span class="undefined">    width: 100%;</span></span><br><span class="line"><span class="undefined">    height: 152px;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="css">  <span class="selector-tag">main</span><span class="selector-pseudo">::after</span> &#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">content</span><span class="selector-pseudo">:''</span>;</span></span><br><span class="line"><span class="undefined">    display: inline-block;</span></span><br><span class="line"><span class="undefined">    height: 100%;</span></span><br><span class="line"><span class="undefined">    vertical-align: middle;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">  main &gt; span &#123;</span></span><br><span class="line"><span class="undefined">    /* display: inline-block;</span></span><br><span class="line"><span class="undefined">    vertical-align: middle; */</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#b4a078</span>;</span></span><br><span class="line"><span class="undefined">    color: white;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span>: <span class="selector-class">.3em</span> 1<span class="selector-tag">em</span> <span class="selector-class">.5em</span>;</span></span><br><span class="line"><span class="undefined">    border-radius: 3px;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">box-shadow</span>: 0 0 <span class="selector-class">.5em</span> <span class="selector-id">#b4a078</span>;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">main</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span>&gt;</span>Center me, please!<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">main</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="4-圣杯布局"><a href="#4-圣杯布局" class="headerlink" title="4. 圣杯布局"></a>4. 圣杯布局</h2><p>两边等宽，中间自适应的三栏布局<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-tag">section</span> <span class="selector-class">.left</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: -<span class="number">129px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-class">.center</span> &#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">text-align</span>: justify;</span><br><span class="line">    <span class="attribute">hyphens</span>: auto;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-tag">section</span> <span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">129px</span>;</span><br><span class="line">    <span class="attribute">margin-left</span>: -<span class="number">119px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>用grid实现圣杯布局<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.mainbody</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: grid;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">"header header header"</span></span><br><span class="line">                        <span class="string">"navigation main ads"</span></span><br><span class="line">                        <span class="string">"footer footer footer"</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">150px</span> <span class="number">1</span>fr <span class="number">150px</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> </span><br><span class="line">                        <span class="number">1</span>fr</span><br><span class="line">                        <span class="number">30px</span>;</span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/* 移动端 */</span></span><br><span class="line">@<span class="keyword">media</span> screen and (max-width: <span class="number">600px</span>) &#123;</span><br><span class="line"><span class="selector-class">.mainbody</span> &#123;</span><br><span class="line">    <span class="attribute">grid-template-areas</span>: <span class="string">"header"</span></span><br><span class="line">                         <span class="string">"navigation"</span></span><br><span class="line">                         <span class="string">"main"</span></span><br><span class="line">                         <span class="string">"ads"</span></span><br><span class="line">                         <span class="string">"footer"</span>;</span><br><span class="line">    <span class="attribute">grid-template-columns</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">grid-template-rows</span>: <span class="number">100px</span> Header</span><br><span class="line">                        <span class="number">50px</span> <span class="comment">/* Navigation */</span></span><br><span class="line">                        <span class="number">1</span>fr <span class="comment">/* Main Content */</span></span><br><span class="line">                        <span class="number">50px</span> <span class="comment">/* Ads */</span></span><br><span class="line">                        <span class="number">30px</span>; <span class="comment">/* Footer */</span></span><br><span class="line">    <span class="attribute">min-height</span>: <span class="number">100vh</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><img alt data-src="https://i.loli.net/2019/12/10/NZwXiqUyMJQ1R8j.png" class="lozad"></p><h3 id="5-双飞翼布局"><a href="#5-双飞翼布局" class="headerlink" title="5. 双飞翼布局"></a>5. 双飞翼布局</h3><p>此布局的需求同圣杯布局一样，都为两边等宽，中间自适应的三栏布局</p><h3 id="6-类订单布局"><a href="#6-类订单布局" class="headerlink" title="6. 类订单布局"></a>6. 类订单布局</h3><p>左侧高度不固定，右侧高度自适应并居中</p><h3 id="7-flex布局"><a href="#7-flex布局" class="headerlink" title="7. flex布局"></a>7. flex布局</h3><p>使用弹性盒子的意义，就是在跨平台、不同屏幕大小下它都能够通过拉伸或缩小达到一个可用不溢出的尺寸。<br><code>flex</code>能够引起一个元素生成一个盒级的弹性盒子，而<code>inline-flex</code>会生成一个行内弹性盒子。</p><p>Flexible Box模型（flexbox），是一种一维的布局模型。flex布局具有两根轴线——<code>flex-direction</code>决定的主轴和垂直于它的交叉轴。</p><h4 id="更改flex方向-flex-direction属性"><a href="#更改flex方向-flex-direction属性" class="headerlink" title="更改flex方向 flex-direction属性"></a>更改flex方向 flex-direction属性</h4><blockquote><p>row(初始值)：水平方向，从左到右<br>row-reverse：水平方向，从右向左<br>column：垂直方向，从上向下<br>column-reverse：垂直方向，从下向上排列</p></blockquote><p>我们管flexbox的区域为flex容器，即<code>display:flex/inline-flex;</code>的区域。初始条件下，内部flex元素均满足：</p><ul><li>元素排列为一行 (flex-direction 属性的初始值是 row)。</li><li>元素从主轴的起始线开始。</li><li>元素不会在主维度方向拉伸，但是可以缩小。</li><li>元素被拉伸来填充交叉轴大小。</li><li>flex-basis 属性为 auto。</li><li>flex-wrap 属性为 nowrap。<h4 id="实现换行-flex-wrap属性"><a href="#实现换行-flex-wrap属性" class="headerlink" title="实现换行 flex-wrap属性"></a>实现换行 flex-wrap属性</h4>当行内元素过多，容器单行无法满足时，<code>flex-wrap</code>可以实现换行显示<blockquote><p>nowrap(默认值)：不换行，进行缩小适应<br>wrap：换行，第一行在上方<br>row-reverse：换行，第一行在下方</p></blockquote></li></ul><p><code>flex-direction</code>和<code>flex-wrap</code>可以简写为<code>flex-glow</code>属性</p><h4 id="flex元素属性：flex-grow"><a href="#flex元素属性：flex-grow" class="headerlink" title="flex元素属性：flex-grow"></a>flex元素属性：flex-grow</h4><p>定义了元素的伸张比例，按比例分配空间</p><blockquote><p><number>: 值越大元素占据空间越大，默认值为0</number></p></blockquote><h4 id="flex元素属性：flex-shrink"><a href="#flex元素属性：flex-shrink" class="headerlink" title="flex元素属性：flex-shrink"></a>flex元素属性：flex-shrink</h4><p>定义了元素的收缩比例，按比例分配空间</p><blockquote><p><number>: 值越大元素占据空间越小，默认值为0</number></p></blockquote><h4 id="flex元素属性：flex-basis"><a href="#flex元素属性：flex-basis" class="headerlink" title="flex元素属性：flex-basis"></a>flex元素属性：flex-basis</h4><p>定义在分配多余空间之前（即伸缩之前），元素占据的主轴空间</p><blockquote><p><length>：默认值为auto，当不设置具体宽高时采用原始尺寸</length></p></blockquote><h4 id="三种元素属性的简写-flex"><a href="#三种元素属性的简写-flex" class="headerlink" title="三种元素属性的简写 flex"></a>三种元素属性的简写 flex</h4><p>flex能够将以上三种元素属性数值进行简写为：<code>flex: flex-grow flex-shrink flex-basis;</code><br>flex有其预定义的简写形式</p><blockquote><p>initial：相当于<code>flex: 0 1 auto</code><br>auto：相当于<code>flex: 1 1 auto</code><br>none：相当于<code>flex：0 0 auto</code></p><p><number>(某一正数)：相当于<code>flex: n n 0</code></number></p></blockquote><h4 id="交叉轴方向对齐-align-items属性"><a href="#交叉轴方向对齐-align-items属性" class="headerlink" title="交叉轴方向对齐 align-items属性"></a>交叉轴方向对齐 align-items属性</h4><blockquote><p>flex-start：交叉轴的起点对齐<br>flex-end：交叉轴的终点对齐<br>cente：交叉轴的中心对齐<br>baseline：项目第一行文字的基线对齐<br>stretch(默认值)：项目未设置固定高度时，将占满整个容器</p></blockquote><h4 id="主轴方向对齐-justify-content"><a href="#主轴方向对齐-justify-content" class="headerlink" title="主轴方向对齐 justify-content"></a>主轴方向对齐 justify-content</h4><blockquote><p>flex-start(默认值)：左对齐<br>flex-end：右对齐<br>center：居中<br>space-evenly：每个项目之间及与两端的间隔都相等<br>space-around：每个项目与两侧间隔相等<br>space-between：两端对齐贴合，项目之间间隔相等</p></blockquote><h4 id="多根轴线之间对齐方式-align-content"><a href="#多根轴线之间对齐方式-align-content" class="headerlink" title="多根轴线之间对齐方式 align-content"></a>多根轴线之间对齐方式 align-content</h4><blockquote><p>flex-start：交叉轴的起点对齐<br>flex-end：交叉轴的终点对<br>center：交叉轴的中心对齐<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布等<br>space-around：每根轴线两侧的间隔都相<br>stretch(默认值)：轴线占满整个交叉轴</p></blockquote><h3 id="网格布局（Grid-Layout）"><a href="#网格布局（Grid-Layout）" class="headerlink" title="网格布局（Grid Layout）"></a>网格布局（Grid Layout）</h3><p>通过在元素上声明 <code>display：grid</code>或 <code>display：inline-grid</code>来创建一个网格容器。</p><p>通过<code>grid-template-columns</code>和 <code>grid-template-rows</code> 属性来定义网格中的行和列。</p><p>存在一个新的计量单位：fr，代表网格容器中可用空间的一等份</p><p>可使用<code>repeat()</code>标记来重复部分或整个轨道列表</p><p>在隐式网格中用<code>grid-auto-rows</code>和<code>grid-auto-columns</code> 属性来定义一个设置大小尺寸的轨道，配合使用<code>minmax(,)</code>可以设置轨道的大小<br><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: grid;</span><br><span class="line">  <span class="attribute">grid-template-columns</span>: <span class="built_in">repeat</span>(3, 1fr);</span><br><span class="line">  <span class="attribute">grid-auto-rows</span>: <span class="built_in">minmax</span>(100px, auto);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>使用了<code>grid-column-start</code>, <code>grid-column-end</code>, <code>grid-row-start</code> 和 <code>grid-row-end</code> 属性去规定行、列起止点，以此来选择网格占位。</p><p><code>grid-gap</code>规定了网格间距，接收列间和行间。</p><p>一个网格元素可以也成为一个网格容器，实现多层的网格嵌套结构。定义嵌套网格可以使用 <code>display: subgrid</code> 而不是 <code>display: grid</code>，然后移除轨道定义。嵌套网格将会使用父级网格元素中的轨道定义来排列它其中的网格元素。</p><p>当你想要让你的网格实现重叠的功能，可以通过行列网线跨域实现，也可以分别赋值<code>z-index</code>实现（值大者居上），始终满足<strong>后来居上</strong>的顺序</p><h3 id="Grid与flexbox比较"><a href="#Grid与flexbox比较" class="headerlink" title="Grid与flexbox比较"></a>Grid与flexbox比较</h3><p>CSS网格布局和弹性盒布局的主要区别在于弹性盒布局是为一维布局服务的（沿横向或纵向的），而网格布局是为二维布局服务的（同时沿着横向和纵向）。</p><p>如果将项目设置为<code>display: contents</code>，通常自身的盒子会消失，子元素的盒子仍显示，就像子元素在文档树中上升了一层。</p><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li>MDN文档<ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/calc" target="_blank" rel="noopener">calc()函数</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/flex" target="_blank" rel="noopener">flex布局</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Node/insertBefore" target="_blank" rel="noopener">Node.insertBefore()</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/grid" target="_blank" rel="noopener">grid网格结构</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align" target="_blank" rel="noopener">vertical-align</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/cursor" target="_blank" rel="noopener">悬浮上方鼠标样式cursor</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout" target="_blank" rel="noopener">CSS弹性盒子布局：flexbox</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout" target="_blank" rel="noopener">网格布局</a></li><li>(grid layout 和其它布局方法的联系)[<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Grid_Layout/Relationship_of_Grid_Layout</a>]</li></ol></li><li>博客文章<ol><li><a href="https://lhammer.cn/You-need-to-know-css/#/zh-cn/" target="_blank" rel="noopener">You-need-to-know-css</a> </li><li><a href="https://css-tricks.com/couple-takes-sticky-footer/" target="_blank" rel="noopener">Sticky Footer, Five Ways</a></li><li><a href="https://aotu.io/notes/2017/04/13/Sticky-footer/index.html" target="_blank" rel="noopener">Sticky Footer，完美的绝对底部</a></li><li><a href="http://ireade.github.io/holy-grail-css-grid/" target="_blank" rel="noopener">The Holy Grail Layout with CSS Grid</a></li><li><a href="https://alligator.io/css/css-grid-holy-grail-layout/" target="_blank" rel="noopener">CSS Grid: Holy Grail Layout</a></li><li><a href="https://www.zhihu.com/question/21504052/answer/50053054" target="_blank" rel="noopener">知乎：CSS布局中圣杯布局与双飞翼布局的实现思路差异在哪里？</a></li><li><a href="https://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a></li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> CSS </tag>
            
            <tag> 每天一个知识点 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[刨根问底]-越来越优秀-JavaScript</title>
      <link href="/2019/12/09/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BC%98%E7%A7%80-JavaScript/"/>
      <url>/2019/12/09/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BC%98%E7%A7%80-JavaScript/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-1-2019-12-12"><a href="#Day-1-2019-12-12" class="headerlink" title="Day.1 2019/12/12"></a>Day.1 2019/12/12</h2><h3 id="Q1-用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"><a href="#Q1-用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值" class="headerlink" title="Q1. 用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值"></a>Q1. 用递归算法实现，数组长度为5且元素的随机数在2-32间不重复的值</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> min = <span class="number">2</span>,max = <span class="number">32</span>;</span><br><span class="line"><span class="keyword">var</span> arrayLength = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">newDiffArray</span>(<span class="params">arr,left,right,length</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*(max - min + <span class="number">1</span>) + min);</span><br><span class="line">    <span class="keyword">if</span>(!arr.includes(num))&#123;</span><br><span class="line">        arr.push(num);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> arr.length === length?arr:newDiffArray(arr,left,right,length);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = newDiffArray([],min,max,arrayLength);</span><br><span class="line"><span class="built_in">console</span>.table(result);</span><br></pre></td></tr></table></figure><h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://github.com/haizlin/fe-interview/issues/3#issuecomment-498971913" target="_blank" rel="noopener">答题解析</a></li></ol><h2 id="Day-1-2019-12-13"><a href="#Day-1-2019-12-13" class="headerlink" title="Day.1 2019/12/13"></a>Day.1 2019/12/13</h2><h3 id="Q2-写一个方法去掉字符串中的空格"><a href="#Q2-写一个方法去掉字符串中的空格" class="headerlink" title="Q2. 写一个方法去掉字符串中的空格"></a>Q2. 写一个方法去掉字符串中的空格</h3><h4 id="Part1-单纯去掉空格来说"><a href="#Part1-单纯去掉空格来说" class="headerlink" title="Part1. 单纯去掉空格来说"></a>Part1. 单纯去掉空格来说</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputText = <span class="string">"   There are   many bolcks!   "</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">cutBlock</span>(<span class="params">text</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> txt = text.split(<span class="string">" "</span>);</span><br><span class="line">    txt = txt.join(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> txt;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> shortText = cutBlock(inputText);</span><br><span class="line"><span class="built_in">console</span>.log(shortText);</span><br></pre></td></tr></table></figure><h4 id="Part2-大佬的多种情况复用"><a href="#Part2-大佬的多种情况复用" class="headerlink" title="Part2. 大佬的多种情况复用"></a>Part2. 大佬的多种情况复用</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> inputText = <span class="string">"   There are   many bolcks!   "</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> POSITION = <span class="built_in">Object</span>.freeze(&#123;    <span class="comment">// freeze 使得数据无法进行修改，ReadOnly</span></span><br><span class="line">    left: <span class="built_in">Symbol</span>(),                 <span class="comment">//去除左边所有</span></span><br><span class="line">    right: <span class="built_in">Symbol</span>(),                <span class="comment">//去除右边所有</span></span><br><span class="line">    both: <span class="built_in">Symbol</span>(),                 <span class="comment">//去除左右两边所有</span></span><br><span class="line">    center: <span class="built_in">Symbol</span>(),               <span class="comment">//去除中间所有</span></span><br><span class="line">    all: <span class="built_in">Symbol</span>(),                  <span class="comment">//去除所有</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trim</span>(<span class="params">str, position = POSITION.left</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!!POSITION[position]) <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unexpected position value'</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">switch</span>(position) &#123;</span><br><span class="line">        <span class="keyword">case</span>(POSITION.left):</span><br><span class="line">          str = str.replace(<span class="regexp">/^\s+/</span>, <span class="string">''</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(POSITION.right):</span><br><span class="line">          str = str.replace(<span class="regexp">/\s+$/</span>, <span class="string">''</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(POSITION.both):</span><br><span class="line">          str = str.replace(<span class="regexp">/^\s+/</span>, <span class="string">''</span>).replace(<span class="regexp">/\s+$/</span>, <span class="string">''</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(POSITION.center):</span><br><span class="line">          <span class="keyword">while</span> (str.match(<span class="regexp">/\w\s+\w/</span>)) &#123;</span><br><span class="line">            str = str.replace(<span class="regexp">/(\w)(\s+)(\w)/</span>, <span class="string">`$1$3`</span>)</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span>(POSITION.all):</span><br><span class="line">          str = str.replace(<span class="regexp">/\s/g</span>, <span class="string">''</span>)</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: </span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> result = trim(inputText,position = POSITION.center);</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">`|<span class="subst">$&#123;result&#125;</span>|`</span>);</span><br></pre></td></tr></table></figure><h3 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze" target="_blank" rel="noopener">Object.freeze()</a></li><li><a href="https://github.com/haizlin/fe-interview/issues/6#issuecomment-507090616" target="_blank" rel="noopener">答题解析</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 刨根问底 </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[刨根问底]-越来越优秀-CSS</title>
      <link href="/2019/12/09/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BC%98%E7%A7%80-CSS/"/>
      <url>/2019/12/09/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BC%98%E7%A7%80-CSS/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-1-2019-12-10"><a href="#Day-1-2019-12-10" class="headerlink" title="Day.1 2019/12/10"></a>Day.1 2019/12/10</h2><h3 id="Q1-圣杯布局和双飞翼布局的理解和区别，并用代码实现"><a href="#Q1-圣杯布局和双飞翼布局的理解和区别，并用代码实现" class="headerlink" title="Q1. 圣杯布局和双飞翼布局的理解和区别，并用代码实现"></a>Q1. 圣杯布局和双飞翼布局的理解和区别，并用代码实现</h3><ul><li><a href="https://github.com/haizlin/fe-interview/issues/2" target="_blank" rel="noopener">Issues索引</a></li></ul><p>圣杯布局和双飞翼布局最终的效果都是呈现两边等宽，中间自适应的三栏布局，中间栏要放在文档流前面以优先渲染。</p><p>两者解决中间栏div内容不被遮挡时的方案不同：</p><ul><li>圣杯布局采取中间div设置 padding-left 和 padding-right 后，将左右两个div用相对布局 position:relative 并分别配合right和left属性，以便左右两栏移动过程中也不会遮挡中间div。</li><li>双飞翼布局采取将中间div内部创建子div用于放置内容，在该子div里 margin-left 和 margin-right 为左右两栏div留出位置。</li></ul><h4 id="代码实现1：圣杯布局"><a href="#代码实现1：圣杯布局" class="headerlink" title="代码实现1：圣杯布局"></a>代码实现1：圣杯布局</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--</span> 圣杯布局 <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hd"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"bd"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"middle"</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#hd</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#bd</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="comment">/*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">padding</span><span class="selector-pseudo">:0</span> 200<span class="selector-tag">px</span> 0 180<span class="selector-tag">px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#middle</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;<span class="comment">/*左栏上去到第一行*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#left</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:180px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100</span>%;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#0c9</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">left</span><span class="selector-pseudo">:-180px</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-200px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#0c9</span>;</span></span><br><span class="line"><span class="css">    <span class="comment">/*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/</span></span></span><br><span class="line"><span class="css">    <span class="selector-tag">position</span><span class="selector-pseudo">:relative</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">right</span><span class="selector-pseudo">:-200px</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#footer</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="代码实现2：双飞翼布局"><a href="#代码实现2：双飞翼布局" class="headerlink" title="代码实现2：双飞翼布局"></a>代码实现2：双飞翼布局</h4><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">--</span> 双飞翼布局 <span class="attr">--</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"hd"</span>&gt;</span>header<span class="tag">&lt;/<span class="name">div</span>&gt;</span> </span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"middle"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inside"</span>&gt;</span>middle<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"left"</span>&gt;</span>left<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"right"</span>&gt;</span>right<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"footer"</span>&gt;</span>footer<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="selector-id">#hd</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line"><span class="undefined">    text-align: center;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#middle</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:100</span>%;<span class="comment">/*左栏上去到第一行*/</span>     </span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span><span class="selector-pseudo">:blue</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#left</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:180px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-100</span>%;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#0c9</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#right</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">float</span><span class="selector-pseudo">:left</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">width</span><span class="selector-pseudo">:200px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin-left</span><span class="selector-pseudo">:-200px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">background</span>:<span class="selector-id">#0c9</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="css"><span class="comment">/*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/</span> </span></span><br><span class="line"><span class="css"><span class="selector-id">#inside</span>&#123;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">margin</span><span class="selector-pseudo">:0</span> 200<span class="selector-tag">px</span> 0 180<span class="selector-tag">px</span>;</span></span><br><span class="line"><span class="css">    <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="css"><span class="selector-id">#footer</span>&#123;  </span></span><br><span class="line"><span class="css">   <span class="selector-tag">clear</span><span class="selector-pseudo">:both</span>; <span class="comment">/*记得清楚浮动*/</span>  </span></span><br><span class="line"><span class="css">   <span class="selector-tag">height</span><span class="selector-pseudo">:50px</span>;     </span></span><br><span class="line"><span class="css">   <span class="selector-tag">background</span>: <span class="selector-id">#666</span>;    </span></span><br><span class="line"><span class="undefined">   text-align: center; </span></span><br><span class="line"><span class="undefined">&#125; </span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Day-2-2019-12-13"><a href="#Day-2-2019-12-13" class="headerlink" title="Day.2 2019/12/13"></a>Day.2 2019/12/13</h2><h3 id="Q2-CSS3有哪些新增的特性？"><a href="#Q2-CSS3有哪些新增的特性？" class="headerlink" title="Q2. CSS3有哪些新增的特性？"></a>Q2. CSS3有哪些新增的特性？</h3><h4 id="边框-borders"><a href="#边框-borders" class="headerlink" title="边框(borders):"></a>边框(borders):</h4><ul><li>border-radius 圆角</li><li>box-shadow 盒阴影</li><li>border-image 边框图像<h4 id="背景"><a href="#背景" class="headerlink" title="背景:"></a>背景:</h4></li><li>background-size 背景图片的尺寸</li><li>background_origin 背景图片的定位区域</li><li>background-clip 背景图片的绘制区域<h4 id="渐变："><a href="#渐变：" class="headerlink" title="渐变："></a>渐变：</h4></li><li>linear-gradient 线性渐变</li><li>radial-gradient 径向渐变<h4 id="文本效果"><a href="#文本效果" class="headerlink" title="文本效果;"></a>文本效果;</h4></li><li>word-break</li><li>word-wrap</li><li>text-overflow</li><li>text-shadow</li><li>text-wrap</li><li>text-outline</li><li>text-justify<h4 id="转换："><a href="#转换：" class="headerlink" title="转换："></a>转换：</h4>*2D转换属性：</li><li>transform</li><li>transform-origin</li><li>2D转换方法</li><li>translate(x,y)</li><li>translateX(n)</li><li>translateY(n)</li><li>rotate(angle)</li><li>scale(n)</li><li>scaleX(n)</li><li>scaleY(n)</li><li>rotate(angle)</li><li>matrix(n,n,n,n,n,n)<h4 id="3D转换："><a href="#3D转换：" class="headerlink" title="3D转换："></a>3D转换：</h4>*3D转换属性：</li><li>transform</li><li>transform-origin</li><li>transform-style</li><li>3D转换方法</li><li>translate3d(x,y,z)</li><li>translateX(x)</li><li>translateY(y)</li><li>translateZ(z)</li><li>scale3d(x,y,z)</li><li>scaleX(x)</li><li>scaleY(y)</li><li>scaleZ(z)</li><li>rotate3d(x,y,z,angle)</li><li>rotateX(x)</li><li>rotateY(y)</li><li>rotateZ(z)</li><li>perspective(n)<h4 id="过渡"><a href="#过渡" class="headerlink" title="过渡"></a>过渡</h4></li><li>transition<h4 id="动画"><a href="#动画" class="headerlink" title="动画"></a>动画</h4></li><li>@Keyframes规则</li><li>animation<h4 id="弹性盒子-flexbox"><a href="#弹性盒子-flexbox" class="headerlink" title="弹性盒子(flexbox)"></a>弹性盒子(flexbox)</h4><h4 id="多媒体查询-media"><a href="#多媒体查询-media" class="headerlink" title="多媒体查询@media"></a>多媒体查询@media</h4><h4 id="补充新增css3伪类"><a href="#补充新增css3伪类" class="headerlink" title="补充新增css3伪类"></a>补充新增css3伪类</h4></li><li>:after 在元素之前添加内容，也可以用来做清除浮动。</li><li>:before 在元素之后添加内容。</li><li>:enabled 选择可用的表单元素。</li><li>:disabled 控制表单控件的禁用状态。</li><li>:checked 单选框或复选框被选中。<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3></li></ul><ol><li><a href="https://github.com/haizlin/fe-interview/issues/5#issuecomment-485129573" target="_blank" rel="noopener">答案解析</a></li><li><a href="https://github.com/haizlin/fe-interview/issues/5#issuecomment-538126851" target="_blank" rel="noopener">答案解析</a></li></ol><h2 id="Day-3-2019-12-14"><a href="#Day-3-2019-12-14" class="headerlink" title="Day.3 2019/12/14"></a>Day.3 2019/12/14</h2><h3 id="Q3-在页面上隐藏元素的方法有哪些？"><a href="#Q3-在页面上隐藏元素的方法有哪些？" class="headerlink" title="Q3 在页面上隐藏元素的方法有哪些？"></a>Q3 在页面上隐藏元素的方法有哪些？</h3><ol><li><p><strong>opacity: 0；</strong> </p><p>将元素内容进行透明隐藏，但读屏软件不隐藏，仍占据位置，并且响应用户交互。<code>opacity:1;</code> 可以实现元素的重新浮现 <a href="http://codepen.io/SitePoint/pen/bedZrR/" target="_blank" rel="noopener">示例</a> 可以通过<code>&lt;1</code>去实现层叠上下文</p></li><li><p><strong>visibility:hidden；</strong></p><p>与opacity一样被隐藏但仍对网页布局起作用，对读屏软件也隐藏，不同之处在于它不响应用户交互。 <a href="https://codepen.io/SitePoint/pen/pbJYpV/" target="_blank" rel="noopener">示例</a> 可以将此特性用于<a href="https://www.zhangxinxu.com/wordpress/2013/05/transition-visibility-show-hide/" target="_blank" rel="noopener">延时显示</a>  要显示某个子孙元素，只要将该元素的 visibility 显式设置为 <code>visibility:visible;</code> 即可。</p></li><li><p><strong>display: none；</strong></p><p>元素不可见且连盒模型也不生成，不占任何空间，效果近似完全不存在，且子孙元素一并无法恢复显示。<a href="https://codepen.io/SitePoint/pen/zBGbjb/" target="_blank" rel="noopener">示例</a><br>可以通过 DOM 来操作对其进行修改，例如让其<code>display : block</code>转为可见</p></li><li><p><strong>position: absolute；</strong><br> top: -9999px;<br> left: -9999px;<br> （或 z-index:-9999px;让其他元素去遮住它）</p><p>移除可视区域是在保证不影响布局的前提下，又使得元素保持可操作（opacity 和 visibility 影响布局， display 不影响布局但又无法直接交互）<a href="https://codepen.io/SitePoint/pen/QEboZm/" target="_blank" rel="noopener">示例</a> 通过<code>position : static;</code> 让元素恢复出现 （用 DOM 模拟复选框和单选按钮，但用这个方法隐藏真正的 checkbox 和 radio 元素来“接收”焦点切换）</p><ol><li><strong>clip-path: polygon(0px 0px,0px 0px,0px 0px,0px 0px)；</strong> </li></ol></li></ol><p>通过剪裁它们来实现，恢复可以通过令其隐藏class来实现。  <a href="https://codepen.io/SitePoint/pen/YWXgdW/" target="_blank" rel="noopener">示例</a></p><h3 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h3><p>1.<a href="https://75.team/post/five-ways-to-hide-elements-in-css.html" target="_blank" rel="noopener">【译】用 CSS 隐藏页面元素的 5 种方法</a></p><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">层叠上下文</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 刨根问底 </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[刨根问底]越来越优秀-HTML</title>
      <link href="/2019/12/08/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BC%98%E7%A7%80-HTML/"/>
      <url>/2019/12/08/%E5%88%A8%E6%A0%B9%E9%97%AE%E5%BA%95-%E8%B6%8A%E6%9D%A5%E8%B6%8A%E4%BC%98%E7%A7%80-HTML/</url>
      
        <content type="html"><![CDATA[<h2 id="Day-1-2019-12-08"><a href="#Day-1-2019-12-08" class="headerlink" title="Day.1 2019/12/08"></a>Day.1 2019/12/08</h2><h3 id="Q1-页面导入样式时，使用link和-import有什么区别？"><a href="#Q1-页面导入样式时，使用link和-import有什么区别？" class="headerlink" title="Q1. 页面导入样式时，使用link和@import有什么区别？"></a>Q1. 页面导入样式时，使用link和@import有什么区别？</h3><h3 id="1-链接样式"><a href="#1-链接样式" class="headerlink" title="1. 链接样式"></a>1. 链接样式<link></h3><p>HTML外部链接元素(<code>&lt;link&gt;</code>)用于链接当前文档与外部资源，最常用于的就是链接外部样式表（stylesheet），同时也用来创建站点图标（pc端的favicon和移动端的主屏幕图标）<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">"../styles/main.css"</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"icon"</span> <span class="attr">href</span>=<span class="string">"favicon.ico"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"apple-touch-icon-precomposed"</span> <span class="attr">sizes</span>=<span class="string">"114x114"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">href</span>=<span class="string">"apple-icon-114.png"</span> <span class="attr">type</span>=<span class="string">"image/png"</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>可以通过<code>rel = &quot;preload&quot;</code> 还有许多其他好处。使用 <code>as =</code> 来指定将要预加载的内容的类型，具体参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Preloading_content" target="_blank" rel="noopener">通过rel=”preload”进行内容预加载</a></p><h3 id="2-导入样式-import"><a href="#2-导入样式-import" class="headerlink" title="2. 导入样式@import"></a>2. 导入样式@import</h3><p><code>@import</code>是CSS<a href="https://developer.mozilla.org/en-US/docs/Web/CSS/At-rule" target="_blank" rel="noopener">@规则</a>，只用于样式表的导入，url为要引入的资源，list-of-media-queries为决定引入CSS规则的媒体查询条件<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">    @<span class="meta"><span class="meta-keyword">import</span> url list-of-media-queries;</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="3-具体区别"><a href="#3-具体区别" class="headerlink" title="3. 具体区别"></a>3. 具体区别</h3><div class="table-container"><table><thead><tr><th>区别</th><th><code>&lt;link&gt;</code></th><th><code>@import</code></th></tr></thead><tbody><tr><td>从属关系</td><td>HTML提供的标签，不仅加载CSS，还能定义RSS、rel连接属性</td><td>CSS提供的语法规则，只负责导入样式表</td></tr><tr><td>加载顺序</td><td>在页面加载时，会同时被加载</td><td>仅在页面加载完后被加载</td></tr><tr><td>兼容性</td><td>作为 HTML 元素，不存在兼容性问题</td><td>CSS2.1 才有的语法，不兼容 IE5 以下</td></tr><tr><td>DOM可控性</td><td>通过js操作DOM插入<code>&lt;link&gt;</code>标签来改变样式</td><td>DOM方法是基于文档的，无法使用<code>@import</code>方式插入样式</td></tr></tbody></table></div><h3 id="0-Reference"><a href="#0-Reference" class="headerlink" title="0. Reference"></a>0. Reference</h3><ol><li>MDN文档：<ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/link" target="_blank" rel="noopener"><code>&lt;link&gt;</code>元素</a></li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/@import" target="_blank" rel="noopener">@import</a></li></ol></li><li>博客文章：<ol><li><a href="https://www.cnblogs.com/my--sunshine/p/6872224.html" target="_blank" rel="noopener">link和@import的区别</a></li></ol></li></ol><h2 id="Day-2-2019-12-12"><a href="#Day-2-2019-12-12" class="headerlink" title="Day.2 2019/12/12"></a>Day.2 2019/12/12</h2><h3 id="Q2-html的元素有哪些（包含H5）？区分出行内元素、块级元素、空元素并在后面简要标注下作用。"><a href="#Q2-html的元素有哪些（包含H5）？区分出行内元素、块级元素、空元素并在后面简要标注下作用。" class="headerlink" title="Q2. html的元素有哪些（包含H5）？区分出行内元素、块级元素、空元素并在后面简要标注下作用。"></a>Q2. html的元素有哪些（包含H5）？区分出行内元素、块级元素、空元素并在后面简要标注下作用。</h3><h4 id="行内元素"><a href="#行内元素" class="headerlink" title="行内元素"></a>行内元素</h4><ul><li>a 链接</li><li><del>hr</del></li><li>span 短语，突显</li></ul><p>以下为补充：</p><ul><li>abbr 展示缩写，窗口提示</li><li>code 贴代码</li><li>em 着重内容斜体</li><li>i 斜体</li><li>strong 加粗</li><li>br 换行</li><li>img 图像嵌入</li><li>script 嵌入或引入可执行脚本</li><li>button 按键</li><li>input 表单交互</li><li>textarea 多行纯文本控件</li><li>label 标签<br>……<h4 id="块级元素"><a href="#块级元素" class="headerlink" title="块级元素"></a>块级元素</h4></li><li>p 行</li><li>h1-h6 标题 </li><li>div 文档分区</li><li><del>body</del> </li><li><del>main</del></li><li>section 一个页面区段（h5）</li><li>ul 无序列表</li><li>ol 有序列表</li><li>li 列表项</li></ul><p>以下为补充：</p><ul><li>article 文章内容（h5）</li><li>aside 伴随内容（h5）</li><li>audio 音频（h5）</li><li>canvas 绘制图形（h5）</li><li>figure 图文组（h5）</li><li>form 表单</li><li>header 页头（h5）</li><li>footer 页脚（h5）</li><li>hr 水平线，段落级转换</li><li>table 表格</li><li>video 视频（h5）<br>…..<h4 id="空元素"><a href="#空元素" class="headerlink" title="空元素"></a>空元素</h4></li><li>img </li><li>br </li></ul><p>以下为补充：</p><ul><li>hr </li><li>input </li><li>link 外部资源链接</li><li>meta<br>……<h3 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h3></li></ul><ol><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element" target="_blank" rel="noopener">HTML 元素参考</a></li></ol><h2 id="Day-3-2019-12-14"><a href="#Day-3-2019-12-14" class="headerlink" title="Day.3 2019/12/14"></a>Day.3 2019/12/14</h2><h3 id="Q3-HTML全局属性-global-attribute-有哪些（包含H5）？"><a href="#Q3-HTML全局属性-global-attribute-有哪些（包含H5）？" class="headerlink" title="Q3. HTML全局属性(global attribute)有哪些（包含H5）？"></a>Q3. HTML全局属性(global attribute)有哪些（包含H5）？</h3><p>全局属性是所有HTML元素共有的属性; 它们可以用于所有元素，即使属性可能对某些元素不起作用。</p><div class="table-container"><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>accesskey</td><td>设置访问元素的键盘快捷键。</td></tr><tr><td>class</td><td>允许 CSS 和 Javascript 通过类选择器 (class selectors) 或DOM方法( document.getElementsByClassName)来选择和访问特定的元素</td></tr><tr><td>contenteditable</td><td>元素是否可被用户编辑</td></tr><tr><td>data-*</td><td>一类自定义数据属性</td></tr><tr><td>dir</td><td>设置元素中内容的文本方向。</td></tr><tr><td>draggable</td><td>指定某个元素是否可以拖动</td></tr><tr><td>dropzone</td><td>指定是否将数据复制，移动，或链接，或删除</td></tr><tr><td>hidden</td><td>规定对元素进行隐藏。</td></tr><tr><td>id</td><td>定义唯一标识符</td></tr><tr><td>lang</td><td>设置元素中内容的语言代码。</td></tr><tr><td>spellcheck</td><td>检测元素是否拼写错误</td></tr><tr><td>style</td><td>规定元素的行内样式（inline style）</td></tr><tr><td>tabindex</td><td>设置元素的 Tab 键控制次序。</td></tr><tr><td>title</td><td>规定元素的额外信息（可在工具提示中显示）</td></tr><tr><td>translate</td><td>指定是否一个元素的值在页面载入时是否需要翻译</td></tr></tbody></table></div><p>……</p><h3 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h3><ol><li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes" target="_blank" rel="noopener">全局属性 Global_attributes</a></li><li><a href="https://github.com/haizlin/fe-interview/issues/7#issuecomment-489413814" target="_blank" rel="noopener">答案出处</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端面试题 </tag>
            
            <tag> 刨根问底 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[阅读笔记]JavaScript高级程序设计</title>
      <link href="/2019/12/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/"/>
      <url>/2019/12/08/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-JavaScript%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读笔记-JavaScript高级程序设计"><a href="#阅读笔记-JavaScript高级程序设计" class="headerlink" title="[阅读笔记]JavaScript高级程序设计"></a>[阅读笔记]JavaScript高级程序设计</h1><h2 id="第一章-JavaScript简介"><a href="#第一章-JavaScript简介" class="headerlink" title="第一章 JavaScript简介"></a>第一章 JavaScript简介</h2><p>JavaScript是一种脚本语言，用于与网页进行交互。由三大部分组成：负责核心语言功能的ECMAScript、负责网页内容交互方法和接口的DOM，负责浏览器交互方法和接口的BOM</p><h3 id="1-1-原书小结"><a href="#1-1-原书小结" class="headerlink" title="1.1 原书小结"></a>1.1 原书小结</h3><p>JavaScript是一种专为与网页交互而设计的脚本语言，由下列三个不同的部分组成：</p><ul><li>ECMAScript,由ECMA-262定义，提供核心语言功能；</li><li>文档对象模型（DOM),提供访问和操作网页内容的方法和接口；</li><li>浏览器对象模型（BOM),提供与浏览器交互的方法和接口。</li></ul><p>JavaScript的这三个组成部分，在当前五个主要浏览器（IE、Firefox、Chrome、Safari和Opera)中都得到了不同程度的支持。其中，所有浏览器对ECMAScript第3版的支持大体上都还不错，而对ECMAScript 5的支持程度越来越高，但对DOM的支持则彼此相差比较多。对HTML5已经正式纳入标准的BOM来说，尽管各浏览器都实现了某些众所周知的共同特性，但其他特性还是会因浏览器而异。</p><h2 id="第二章-在HTML中使用JavaScript"><a href="#第二章-在HTML中使用JavaScript" class="headerlink" title="第二章 在HTML中使用JavaScript"></a>第二章 在HTML中使用JavaScript</h2><h3 id="2-1原书小结"><a href="#2-1原书小结" class="headerlink" title="2.1原书小结"></a>2.1原书小结</h3><p>把JavaScript插入到HTML页面中要使用<code>&lt;script&gt;</code>元素。使用这个元素可以把JavaScript嵌入到HTML页面中，让脚本与标记混合在一起；也可以包含外部的JavaScript文件。而我们需要注意的地方有：</p><ul><li>在包含外部JavaScript文件时，必须将src属性设置为指向相应文件的URL。而这个文件既可以是与包含它的页面位于同一个服务器上的文件，也可以是其他任何域中的文件。</li><li>所有<code>&lt;script&gt;</code>元素都会按照它们在页面中出现的先后顺序依次被解析。在不使用defer和async属性的情况下，只有在解析完前面<code>&lt;script&gt;</code>元素中的代码之后，才会开始解析后面<code>&lt;script&gt;</code>元素中的代码。</li><li>由于浏览器会先解析完不使用defer属性的<code>&lt;script&gt;</code>元素中的代码，然后再解析后面的内容，所以一般应该把<code>&lt;script&gt;</code>元素放在页面最后，即主要内容后面，<code>&lt;/body&gt;</code>标签前面。</li><li>使用defer属性可以让脚本在文档完全呈现之后再执行。延迟脚本总是按照指定它们的顺序执行。</li><li>使用async属性可以表示当前脚本不必等待其他脚本，也不必阻塞文档呈现。不能保证异步脚本按照它们在页面中出现的顺序执行。<br>另外，使用<code>&lt;noscript&gt;</code>元素可以指定在不支持脚本的浏览器中显示的替代内容。但在启用了脚本的情况下，浏览器不会显示<code>&lt;noscript&gt;</code>元素中的任何内容。</li></ul><h3 id="第三章-基本概念"><a href="#第三章-基本概念" class="headerlink" title="第三章 基本概念"></a>第三章 基本概念</h3><h4 id="3-1-语法"><a href="#3-1-语法" class="headerlink" title="3.1 语法"></a>3.1 语法</h4><p>ECMAScript中的一切都区分大小写，对于标识符采用驼峰大小写格式。</p><p>关于注释<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  单行注释</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  块级注释</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure></p><p>严格模式下会对某些不安全的操作进行错误的抛出，须在脚本顶部引用<code>“use strict”</code>，它是一个编译指示告诉其切换至严格模式</p><p>代码结尾无分号可能存在压缩错误的风险</p><h4 id="3-2-关键字和保留字"><a href="#3-2-关键字和保留字" class="headerlink" title="3.2  关键字和保留字"></a>3.2  关键字和保留字</h4><h4 id="3-3-变量"><a href="#3-3-变量" class="headerlink" title="3.3 变量"></a>3.3 变量</h4><p>ECMAScript的变量是松散类型的，可以用来保存任何类型的数据。</p><p>var操作符定义的变量将成为定义该变量的作用域中的局部变量，它可能出现重复声明的冲突。改用let（变量）/const（常量）避免重复声明的毛病。</p><h4 id="3-4-数据类型"><a href="#3-4-数据类型" class="headerlink" title="3.4 数据类型"></a>3.4 数据类型</h4><p>五种基本数据类型：Undefined、Null、Boolean、Number和String。一种复杂数据类型（引用类型）：Object（本质是一组无序的名值对组成的）。<br>typeof用来检测给定变量的数据类型，解决方案如下：</p><ul><li>“undefined”——如果这个值未定义；</li><li>“boolean”——如果这个值是布尔值；</li><li>“string”——如果这个值是字符串；</li><li>“number”——如果这个值是数值；</li><li>“object”——如果这个值是对象或null;</li><li>“function”——如果这个值是函数。</li></ul><h5 id="Undefined类型"><a href="#Undefined类型" class="headerlink" title="Undefined类型"></a>Undefined类型</h5><p>未进行初始化的变量默认取undefined值</p><h5 id="Null类型"><a href="#Null类型" class="headerlink" title="Null类型"></a>Null类型</h5><p>null值表示一个空对象指针，在没有明确对象时最好将其赋值保存为null值，作为与上一种类型的区分。</p><h5 id="Boolean类型"><a href="#Boolean类型" class="headerlink" title="Boolean类型"></a>Boolean类型</h5><p>true和false与数值1和0不再归为一起，同时只认小写值。<br>以下列举一下各类型及其对应的转换规则<br>数据类型|转换为true的值|转换为false的值<br>—-|—-|—-<br>Boolean|true|false<br>String|任何非空字符|””（空字符串）<br>Number|任何非零数字值（包括无穷大）|0或NaN<br>Object|任何对象|null<br>Undefined|N/A（不适用）|undefined</p><h5 id="Number类型"><a href="#Number类型" class="headerlink" title="Number类型"></a>Number类型</h5><p>永远不要测试某个特定的浮点数值，因为其数值计算会产生舍入误差。</p><p>对于超出JavaScript数值范围的值，该数值将被自动转换成特殊的Infinity（无穷）值。</p><p>NaN（Not a Number）是非数值，一种特殊的数值。表示一个本要返回数值的操作数未返回数值的情况（不抛出错误）。</p><p>关于数值的转换，可以通过适用于任何类型的Number()、专门字符串转数值的parseInt()和parseFloat()</p><h5 id="String类型"><a href="#String类型" class="headerlink" title="String类型"></a>String类型</h5><p>几乎所有值都有toString()方法返回该类型的字符串的一个副本。</p><h5 id="Object类型"><a href="#Object类型" class="headerlink" title="Object类型"></a>Object类型</h5><p>通过new出一个新的变量对象</p><p>常用的属性和方法：</p><ul><li>hasOwnProperty(propertyName)    检查该对象实例是否存在对应属性</li><li>toString()    返回对象的字符串表示</li><li>valueOf()    返回对象的字符串、数值或布尔值表示，通常与toString()方法相同</li><li>……</li></ul><h4 id="3-5-操作符"><a href="#3-5-操作符" class="headerlink" title="3.5 操作符"></a>3.5 操作符</h4><p>通常可以加上label标签用法去配合break和contine使用，实现对循环语句使用的控制<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">outBreak:</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>;i&lt;n;++i)&#123;</span><br><span class="line">    <span class="keyword">if</span>(condition)&#123;</span><br><span class="line">        <span class="comment">//.....</span></span><br><span class="line">        <span class="keyword">break</span> outBreak; <span class="comment">//  contine outBreak;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>with语句将代码定位到一个特定的对象上，对其进行子方法或是子属性的统一调用（严格模式下不建议使用）</p><h4 id="3-6-函数"><a href="#3-6-函数" class="headerlink" title="3.6 函数"></a>3.6 函数</h4><p>函数体本身传入的参数可以通过<code>arguments[]</code>数组对象进行访问。</p><p>ECMAScript函数没有重载一说</p><h3 id="3-7-原书小结"><a href="#3-7-原书小结" class="headerlink" title="3.7 原书小结"></a>3.7 原书小结</h3><p>JavaScript的核心语言特性在ECMA-262中是以名为ECMAScript的伪语言的形式来定义的。ECMAScript中包含了所有基本的语法、操作符、数据类型以及完成基本的计算任务所必需的对象，但没有对取得输入和产生输出的机制作出规定。理解ECMAScript及其纷繁复杂的各种细节，是理解其在Web测览器中的实现——JavaScript的关键。目前大多数实现所遵循的都是ECMA-262第3版，但很多也已经着手开始实现第5版了。以下简要总结了ECMAScript中基本的要素。</p><ul><li>ECMAScript中的基本数据类型包括Undefined、Null、Boolean、Number和String。</li><li>与其他语言不同，ECMScript没有为整数和浮点数值分别定义不同的数据类型，Number类型可用于表示所有数值。</li><li>CMAScript中也有一种复杂的数据类型，即object类型，该类型是这门语言中所有对象的基础类型。</li><li>严格模式为这门语言中容易出错的地方施加了限制。</li><li>ECMAScript提供了很多与C及其他类C语言中相同的基本操作符，包括算术操作符、布尔操作符、关系操作符、相等操作符及赋值操作符等。</li><li>ECMAScript从其他语言中借鉴了很多流控制语句，例如if语句、for语句和switch语句等。</li></ul><p>ECMAScript中的函数与其他语言中的函数有诸多不同之处。</p><ul><li>无须指定函数的返回值，因为任何ECMAScript函数都可以在任何时候返回任何值。</li><li>实际上，未指定返回值的函数返回的是一个特殊的undefined值。</li><li>ECMAScript中也没有函数签名的概念，因为其函数参数是以一个包含零或多个值的数组的形式传递的。</li><li>可以向ECMAScript函数传递任意数量的参数，并且可以通过arguments对象来访问这些参数。</li><li>由于不存在函数签名的特性，ECMAScript函数不能重载。</li></ul><h2 id="第四章-变量、作用域和内存问题"><a href="#第四章-变量、作用域和内存问题" class="headerlink" title="第四章 变量、作用域和内存问题"></a>第四章 变量、作用域和内存问题</h2><p>变量属于松散类型，即其值及类型可以在生命周期内发生变化。</p><h3 id="4-1-基本类型和引用类型的值"><a href="#4-1-基本类型和引用类型的值" class="headerlink" title="4.1 基本类型和引用类型的值"></a>4.1 基本类型和引用类型的值</h3><p>ECMAScript变量可能含两种不同数据类型的值：简单的数据段的基本类型值（Undefined、Null、Boolean、Number和String，是按值访问的），可能由多值构成的的对象的引用类型值（JavaScript不允许直接访问内存中的位置，所以引用类型是按引用访问的）。</p><p>引用类型赋值后可以动态的添加或者删除属性及方法，基本类型不支持。</p><p>复制基本类型就是在创建的副本上复制原值，而对于复制引用类型，则是将副本作为一个指针指向原值。</p><div class="table-container"><table><thead><tr><th>检测数据类型</th><th>操作符</th></tr></thead><tbody><tr><td>基本数据类型</td><td>typeof</td></tr><tr><td>引用类型</td><td>instanceof</td></tr></tbody></table></div><p>基本类型不是对象，用instanceof检测始终返回false。</p><h3 id="4-2-执行环境和作用域"><a href="#4-2-执行环境和作用域" class="headerlink" title="4.2 执行环境和作用域"></a>4.2 执行环境和作用域</h3><p>执行环境与某个变量对象相关联，它允许操作作用范围内的变量及函数。当环境内的代码执行完毕后销毁。各个执行环境的包含形成了变量对象的作用域链的概念，每个环境只可以向上搜索作用域链，使用上级环境的任何变量和函数。（window为全局执行环境）</p><p>延长作用域链，with规定下的环境变量和函数可在内部环境内使用。</p><p>JavaScript没有块级作用域，var局部变量不会得到立即销毁，即外部仍可以获取值。通过声明变量（<strong>let变量/const常量</strong>），我们能够将其添加到函数的局部环境中使得外部无法获取它们的值。不加声明的变量升格为全局变量。</p><p>通常查询标识符则依照由内向外层层查询的方式。</p><h3 id="4-3-垃圾收集"><a href="#4-3-垃圾收集" class="headerlink" title="4.3 垃圾收集"></a>4.3 垃圾收集</h3><p>垃圾收集策略常用的是<strong>标记清除</strong>，引用计数的垃圾收集策略存在相互重复、循环引用使得引用次数可能无法归零所以不常使用。</p><p>当数据不再使用时时，最好通过将值设置为null的方式来解除引用，而局部变量在离开执行环境后即自动解除引用。</p><h3 id="4-4-原书小结"><a href="#4-4-原书小结" class="headerlink" title="4.4 原书小结"></a>4.4 原书小结</h3><p>JavaScript变量可以用来保存两种类型的值：基本类型值和引用类型值。基本类型的值源自以下5种基本数据类型：Undefined、Null、Boolean、Number和String。基本类型值和引用类型值具有以下特点</p><ul><li>基本类型值在内存中占据固定大小的空间，因此被保存在栈内存中；</li><li>从一个变量向另一个变量复制基本类型的值，会创建这个值的一个副本；</li><li>引用类型的值是对象，保存在堆内存中；</li><li>包含引用类型值的变量实际上包含的并不是对象本身，而是一个指向该对象的指针；</li><li>从一个变量向另一个变量复制引用类型的值，复制的其实是指针，因此两个变量最终都指向同一个对象；</li><li>确定一个值是哪种基本类型可以使用typeof操作符，而确定一个值是哪种引用类型可以使用instanceof 操作符。</li></ul><p>所有变量（包括基本类型和引用类型）都存在于一个执行环境（也称为作用域）当中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量。以下是关于执行环境的几点总结：</p><ul><li>执行环境有全局执行环境（也称为全局环境）和函数执行环境之分；</li><li>每次进入一个新执行环境，都会创建一个用于搜索变量和函数的作用域链；</li><li>函数的局部环境不仅有权访问函数作用域中的变量，而且有权访问其（父）环境，乃至全局环境；</li><li>全局环境只能访问在全局环境中定义的变量和函数，而不能直接访问局部环境中的任何数据；</li><li>变量的执行环境有助于确定应该何时释放内存。</li></ul><p>JavaScript是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对JavaScript的垃圾收集例程作如下总结。</p><ul><li>离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</li><li>“标记清除”是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</li><li>另一种垃圾收集算法是“引用计数”，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法；但在IE中访问非原JavaScript对象（如DOM元素）时，这种算法仍然可能会导致问题。</li><li>当代码中存在循环引用现象时，“引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用（设置值为null）。</li></ul><h2 id="第五章-引用类型"><a href="#第五章-引用类型" class="headerlink" title="第五章 引用类型"></a>第五章 引用类型</h2><h3 id="5-1-Object类型"><a href="#5-1-Object类型" class="headerlink" title="5.1 Object类型"></a>5.1 Object类型</h3><h3 id="5-2-Array类型"><a href="#5-2-Array类型" class="headerlink" title="5.2 Array类型"></a>5.2 Array类型</h3><p>toString()方法会返回数字的拼接字符串，每项之间用’，’隔开。<br>valueOf()返回数组本身</p><p>数组操作<br>方法名|操作动作<br>—-|—-<br>push()|插入数组末尾<br>pop()|弹出数组最后一项<br>shift()|移除数组首项<br>unshift()|添加到数组的首端</p><p>对数组进行自定规则的排序<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1,value2</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1&lt;value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;  <span class="comment">//</span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(value1&gt;value2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;   <span class="comment">//true，进行置换操作</span></span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>concat()：创建一个新的数组副本并加入添加项，原数组不做修改。<br>slice()：取起、止位置间的数组部分<br>splice()：指定起始位置、要删除的项数和要插入的任意项。</p><p>indexOf()：正向数返回该位置上的值<br>lastIndexOf()：逆向数返回该位置上的值</p><p>关于迭代的方法共五种，每种方法均接受两个参数：要在每一项运行的函数和可选的函数作用域对象（影响this的值）。<br>every()：对每一项运行函数，都返回true则返回true；<br>somr()：对任一项运行函数，都返回true则返回true；<br>forEach()：对每一项运行函数，没有返回值；<br>filter()：对每一项运行函数，返回true的项组成的数组；<br>map()：对每一项运行函数，返回调用结果组成的数组；</p><h3 id="5-3-Data类型"><a href="#5-3-Data类型" class="headerlink" title="5.3 Data类型"></a>5.3 Data类型</h3><p>new Data(Data.parse())返回表示日期的字符串参数</p><h3 id="5-4-RegExp类型"><a href="#5-4-RegExp类型" class="headerlink" title="5.4 RegExp类型"></a>5.4 RegExp类型</h3><p>正则表达式的匹配</p><h3 id="5-5-Function类型"><a href="#5-5-Function类型" class="headerlink" title="5.5 Function类型"></a>5.5 Function类型</h3><p>没有重载</p><p>this引用的是函数执行环境的对象</p><p>ECMAScript中prototype保存了所有实例方法，由它可以实现自定义引用类型和实现继承。</p><p>apply()和call()可以在特定的作用域中调用函数，实际等于设置函数体内this对象的值。两者的区别是call()传参需逐个列出。</p><h3 id="5-6-基本包装类型"><a href="#5-6-基本包装类型" class="headerlink" title="5.6 基本包装类型"></a>5.6 基本包装类型</h3><h3 id="5-7-单体内置对象"><a href="#5-7-单体内置对象" class="headerlink" title="5.7 单体内置对象"></a>5.7 单体内置对象</h3><h3 id="5-8-原书小结"><a href="#5-8-原书小结" class="headerlink" title="5.8 原书小结"></a>5.8 原书小结</h3><p>对象在JavaScript中被称为引用类型的值，而且有一些内置的引用类型可以用来创建特定的对象，现简要总结如下：</p><ul><li>引用类型与传统面向对象程序设计中的类相似，但实现不同；</li><li>Object是一个基础类型，其他所有类型都从Object继承了基本的行为；</li><li>Array类型是一组值的有序列表，同时还提供了操作和转换这些值的功能；</li><li>Date类型提供了有关日期和时间的信息，包括当前日期和时间以及相关的计算功能;</li><li>RegExp类型是ECMAScript支持正则表达式的一个接口，提供了最基本的和一些高级的正则表达式功能。</li></ul><p>函数实际上是Function类型的实例，因此函数也是对象；而这一点正是JavaScript最有特色的地方。由于函数是对象，所以函数也拥有方法，可以用来增强其行为。<br>因为有了基本包装类型，所以JavaScript中的基本类型值可以被当作对象来访问。三种基本包装类型分别是：Boolean、Number和string。以下是它们共同的特征</p><ul><li>每个包装类型都映射到同名的基本类型；</li><li>在读取模式下访问基本类型值时，就会创建对应的基本包装类型的一个对象，从而方便了数据操作；</li><li>操作基本类型值的语句一经执行完毕，就会立即销毁新创建的包装对象。<br>在所有代码执行之前，作用域中就已经存在两个内置对象：Global和Math。在大多数ECMAScript实现中都不能直接访问Global对象；不过，Web浏览器实现了承担该角色的window对象。全局变量和函数都是Global对象的属性。Math对象提供了很多属性和方法，用于辅助完成复杂的数学计算任务。</li></ul><h2 id="第六章-面向对象（OO-Object-Oriented）的程序设计"><a href="#第六章-面向对象（OO-Object-Oriented）的程序设计" class="headerlink" title="第六章 面向对象（OO,Object-Oriented）的程序设计"></a>第六章 面向对象（OO,Object-Oriented）的程序设计</h2><p>ES因为没有类的概念，所以它表现对象的方式有所不同，构成一组名值对的散列表。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name:<span class="string">"Kevin"</span>,</span><br><span class="line">    age:<span class="number">22</span>,</span><br><span class="line">    job:<span class="string">"Software Engineer"</span>,</span><br><span class="line">    </span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        alert(<span class="keyword">this</span>.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p><h3 id="6-1-属性类型"><a href="#6-1-属性类型" class="headerlink" title="6.1 属性类型"></a>6.1 属性类型</h3><p>ECMAScript中属性分：数据属性和访问器属性</p><p>数据属性的特性包括：configurable（能否通过delete删除属性）、enumerable（能否通过for-in循环返回属性）、writable（能否修改属性的值）、value（包含改属性的数据值）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> person=&#123;&#125;;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person,<span class="string">"name"</span>,&#123;</span><br><span class="line">    writable:<span class="literal">false</span>,</span><br><span class="line">    configurable:<span class="literal">false</span>,</span><br><span class="line">    value:<span class="string">"Kevin"</span></span><br><span class="line"></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(person.name); <span class="comment">//"Kevin"</span></span><br><span class="line"></span><br><span class="line">person,name = <span class="string">"Ken"</span></span><br><span class="line">alert(person.name); <span class="comment">//"Kevin"   无法修改</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">delete</span> person.name;</span><br><span class="line">alert(person.name); <span class="comment">//"Kevin"   无法删除</span></span><br></pre></td></tr></table></figure></p><p>访问器属性为读取和写入访问器时的特性：configurable（能否通过delete删除属性）、enumerable（能否通过for-in循环返回属性）、get（读取属性时调用的函数）、set（写入属性时调用的函数）<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> book = &#123;</span><br><span class="line">    _year:<span class="number">2004</span>,</span><br><span class="line">    edition:<span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(book,<span class="string">"year"</span>,&#123;</span><br><span class="line">    <span class="keyword">get</span>: function()&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._year;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">set</span>:function(newValue)&#123;</span><br><span class="line">       <span class="keyword">if</span>(newValue&gt;<span class="number">2004</span>)&#123;</span><br><span class="line">            <span class="keyword">this</span>._year = newValue;</span><br><span class="line">            <span class="keyword">this</span>.edition+=newValue - <span class="number">2004</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">book.year = <span class="number">2005</span>;</span><br><span class="line">alert(book.edition);</span><br></pre></td></tr></table></figure></p><h3 id="6-2-创建对象"><a href="#6-2-创建对象" class="headerlink" title="6.2 创建对象"></a>6.2 创建对象</h3><h3 id="6-3-继承"><a href="#6-3-继承" class="headerlink" title="6.3 继承"></a>6.3 继承</h3><h3 id="6-4-原书小结"><a href="#6-4-原书小结" class="headerlink" title="6.4 原书小结"></a>6.4 原书小结</h3><p>ECMAScript支持面向对象（oo）编程，但不使用类或者接口。对象可以在代码执行过程中创建和增强，因此具有动态性而非严格定义的实体。在没有类的情况下，可以采用下列模式创建对象。</p><ul><li>工厂模式，使用简单的函数创建对象，为对象添加属性和方法，然后返回对象。这个模式后来被构造函数模式所取代。</li><li>构造函数模式，可以创建自定义引用类型，可以像创建内置对象实例一样使用new操作符。不过，构造函数模式也有缺点，即它的每个成员都无法得到复用，包括函数。由于函数可以不局限于任何对象（即与对象具有松散糊合的特点）,因此没有理由不在多个对象间共享函数。</li><li>原型模式，使用构造函数的prototype属性来指定那些应该共享的属性和方法。组合使用构造函数模式和原型模式时，使用构造函数定义实例属性，而使用原型定义共享的属性和方法。</li></ul><p>JavaScript主要通过原型链实现继承。原型链的构建是通过将一个类型的实例赋值给另一个构造函数的原型实现的。这样，子类型就能够访问超类型的所有属性和方法，这一点与基于类的继承很相似。原型链的问题是对象实例共享所有继承的属性和方法，因此不适宜单独使用。解决这个问题的技术是借用构造函数，即在子类型构造函数的内部调用超类型构造函数。这样就可以做到每个实例都具有自己的属性，同时还能保证只使用构造函数模式来定义类型。使用最多的继承模式是组合继承，这种模式使用原型链继承共享的属性和方法，而通过借用构造函数继承实例属性。<br>此外，还存在下列可供选择的继承模式。</p><ul><li>原型式继承，可以在不必预先定义构造函数的情况下实现继承，其本质是执行对给定对象的浅复制。而复制得到的副本还可以得到进一步改造。</li><li>寄生式继承，与原型式继承非常相似，也是基于某个对象或某些信息创建一个对象，然后增强对象，最后返回对象。为了解决组合继承模式由于多次调用超类型构造函数而导致的低效率问题，可以将这个模式与组合继承一起使用。</li><li>寄生组合式继承，集寄生式继承和组合继承的优点与一身，是实现基于类型继承的最有效方式。</li></ul><h2 id="第七章-函数表达式"><a href="#第七章-函数表达式" class="headerlink" title="第七章 函数表达式"></a>第七章 函数表达式</h2><p>函数有两种表达方式，分函数声明和函数表达式<br>函数声明的语法如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">functionName</span>(<span class="params">arg0,arg1,arg2</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//函数体</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p> 函数声明的一个重要特性是函数声明提升，即调用语句可以放在函数声明之前。</p><p> 函数表达式的语法如下：<br> <figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName = <span class="function"><span class="keyword">function</span>(<span class="params">arg0,arg1,arg2</span>)</span>&#123;</span><br><span class="line">   <span class="comment">//函数体</span></span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>上述function后没有标识符的函数命名方式称为匿名函数。不支持提前调用，<br>遇到函数分情况定义的情形时，代码如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> functionName；</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(condition)&#123;</span><br><span class="line">    functionName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">// 函数体1;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    functionName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//函数体2;</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="7-1-递归"><a href="#7-1-递归" class="headerlink" title="7.1 递归"></a>7.1 递归</h3><p>递归，简单理解就是依条件去调用自身，避免在代码编写过程中出现的赋值后函数名冲突问题，可以使用指针arguments.callee(args)代替函数名来指向正在执行的函数。</p><p>严格及非严格条件下通常采用命名函数表达式来实现递归<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> functionName = (<span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">args</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// return f(args)</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><h3 id="7-2-闭包-Closures"><a href="#7-2-闭包-Closures" class="headerlink" title="7.2 闭包(Closures)"></a>7.2 闭包(Closures)</h3><p>闭包指代可以访问另一个函数作用域中变量的函数，可以让你从内部函数访问外部函数作用域，常见方式即<strong>在一个函数中创建另一个函数</strong>。闭包是由函数以及创建该函数的词法环境组合而成，<strong>这个环境包含了这个闭包创建时所能访问的所有局部变量</strong>。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeAdder</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">  &#125;;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> add5 = makeAdder(<span class="number">5</span>);</span><br><span class="line"><span class="keyword">var</span> add10 = makeAdder(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add5(<span class="number">2</span>));  <span class="comment">// 7</span></span><br><span class="line"><span class="built_in">console</span>.log(add10(<span class="number">2</span>)); <span class="comment">// 12</span></span><br></pre></td></tr></table></figure></p><h3 id="7-3-模仿块级作用域"><a href="#7-3-模仿块级作用域" class="headerlink" title="7.3 模仿块级作用域"></a>7.3 模仿块级作用域</h3><h3 id="7-4-私有变量"><a href="#7-4-私有变量" class="headerlink" title="7.4 私有变量"></a>7.4 私有变量</h3><p>可以通过特权方法来访问私有变量和私有函数。然而每次在构造函数模式中去实现，其存在每一个实例都需要创建同样一组新方法的缺点，可以通过静态私有变量来解决。<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="comment">//私有变量和私有函数</span></span><br><span class="line">    <span class="keyword">let</span> name = <span class="string">""</span>;    </span><br><span class="line">    Person = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        name = value;</span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.getName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;    </span><br><span class="line">    &#125;;</span><br><span class="line">    Person.prototype.setName = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">        name = value; </span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure></p><h3 id="7-5-原书小结"><a href="#7-5-原书小结" class="headerlink" title="7.5 原书小结"></a>7.5 原书小结</h3><p>在JavaScript编程中，函数表达式是一种非常有用的技术。使用函数表达式可以无须对函数命名，从而实现动态编程。匿名函数，也称为拉姆达函数，是一种使用JavaScript函数的强大方式。以下总结了函数表达式的特点。</p><ul><li>函数表达式不同于函数声明。函数声明要求有名字，但函数表达式不需要。没有名字的函数表达式也叫做匿名函数。</li><li>在无法确定如何引用函数的情况下，递归函数就会变得比较复杂；</li><li>递归函数应该始终使arguments.callee来递归地调用自身，不要使用函数名——函数名可能会发生变化。</li></ul><p>当在函数内部定义了其他函数时，就创建了闭包。闭包有权访问包含两数内部的所有变量，原理如下。</p><ul><li>在后台执行环境中，闭包的作用域链包含着它自己的作用域、包含函数的作用域和全局作用域。</li><li>通常，函数的作用域及其所有变量都会在函数执行结束后被销毁。</li><li>但是，当函数返回了一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。</li></ul><p>使用闭包可以在JavaScript中模仿块级作用域（JavaScript本身没有块级作用域的概念）,要点如下。</p><ul><li>创建并立即调用一个函数，这样既可以执行其中的代码，又不会在内存中留下对该函数的引用</li><li>结果就是函数内部的所有变量都会被立即销毁——除非将某些变量赋值给了包含作用域（即外部作用域）中的变量。</li></ul><p>闭包还可以用于在对象中创建私有变量，相关概念和要点如下。</p><ul><li>即使JavaScript中没有正式的私有对象属性的概念，但可以使用闭包来实现公有方法，而通过公有方法可以访问在包含作用域中定义的变量。</li><li>有权访问私有变量的公有方法叫做特权方法。</li><li>可以使用构造函数模式、原型模式来实现自定义类型的特权方法，也可以使用模块模式、增强的模块模式来实现单例的特权方法。</li></ul><p>JavaScript中的函数表达式和闭包都是极其有用的特性，利用它们可以实现很多功能。不过，因为创建闭包必须维护额外的作用域，所以过度使用它们可能会占用大量内存。</p><h2 id="第八章-BOM"><a href="#第八章-BOM" class="headerlink" title="第八章 BOM"></a>第八章 BOM</h2><p>BOM（浏览器对象模型）,不同浏览器下所界定的共有对象所组成的标准化规范。</p><h3 id="8-1-window对象"><a href="#8-1-window对象" class="headerlink" title="8.1 window对象"></a>8.1 window对象</h3><p>window是BOM的核心，表示一个包含DOM文档（document）的窗口，作为接口和<strong>全局变量</strong>代表脚本正在运行的窗口，暴露给JavaScript。</p><p>在框架集（frames）中，会涉及到框架之间的引用，其中<br>frames[]=window[](self-&gt;window)=top[]&gt;=parent[]<br>(top始终指向最外围框架，window指向框架实例，parent则指向当前框架的上层)</p><p>获取跨浏览器获取窗口左边和上边的位置<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> leftPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenLeft == <span class="string">'number'</span>)?<span class="built_in">window</span>.screenLeft:<span class="built_in">window</span>.screenX;</span><br><span class="line"><span class="keyword">var</span> topPos = (<span class="keyword">typeof</span> <span class="built_in">window</span>.screenTop == <span class="string">'number'</span>)?<span class="built_in">window</span>.screenTop:<span class="built_in">window</span>.screenY;</span><br></pre></td></tr></table></figure></p><p>获取浏览器页面的视窗（viewport）大小<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> pageWidth = <span class="built_in">window</span>.innerWidth,pageHeight = <span class="built_in">window</span>.innerHeight;</span><br><span class="line"><span class="keyword">if</span>(<span class="keyword">typeof</span> pageWidth != <span class="string">"number"</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">document</span>.compatMode == <span class="string">"CSS1Compat"</span>)&#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.documentElement.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.documentElement.clientHeight;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        pageWidth = <span class="built_in">document</span>.body.clientWidth;</span><br><span class="line">        pageHeight = <span class="built_in">document</span>.body.clientHeight;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>尝试着去打开一个新的窗口，可通过window.open()来实现，它接受四个参数：链接地址、对应到指定属性名的窗口或者框架、打开新窗口所需要的设置参数（”height=,width=,top=,left=,resizeable=”,…rest）、标签页是否需要打开新窗口的布尔值。相应的关闭窗口即调用window.close()。</p><p>对于新弹出的窗口，可能存在因为安全限制而出现被屏蔽的现象，可以通过try-catch块去捕获异常。</p><p>Javascript是单线程的，但可以通过超时调用（指定时间过后执行）和间歇调用（每隔指定时间执行一次，直到被取消或页面被卸载）来满足部分需求。<br>超时调用：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> timeoutId = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//执行函数；</span></span><br><span class="line">&#125;,等待毫秒数);</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 取消超时调用</span></span><br><span class="line">clearTimeout(timeoutId);</span><br></pre></td></tr></table></figure></p><p>间歇调用（开发过程很少用到，因为不同的执行开始时间不定，可以利用超市调用来模仿）：<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> intervalId = setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//执行函数；</span></span><br><span class="line">&#125;,等待毫秒数);</span><br><span class="line">   </span><br><span class="line"><span class="comment">// 取消间歇调用</span></span><br><span class="line">clearInterval(intervalId);</span><br></pre></td></tr></table></figure></p><p>浏览器允许向用户发送系统对话框，主要有用于警告的alert()，用于确认用户选择的confirm()以及用于提示并获取用户输入的prompt()。</p><h3 id="8-2-location对象"><a href="#8-2-location对象" class="headerlink" title="8.2 location对象"></a>8.2 location对象</h3><p>location接口表示链接到对象的位置（URL），document与window都具有。</p><p>属性名和方法<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Location" target="_blank" rel="noopener">参考链接</a></p><h3 id="8-3-navigator对象"><a href="#8-3-navigator对象" class="headerlink" title="8.3 navigator对象"></a>8.3 navigator对象</h3><p>navigator可以获知客户端浏览器的相关信息。</p><h3 id="8-4-screen对象"><a href="#8-4-screen对象" class="headerlink" title="8.4 screen对象"></a>8.4 screen对象</h3><p>不常用。</p><h3 id="8-5-history对象"><a href="#8-5-history对象" class="headerlink" title="8.5 history对象"></a>8.5 history对象</h3><p>通达过去的历史会话记录或标签页，可以通过go()来实现跳转，往细分可由back()与forward()两方法组成。</p><h3 id="8-6-原书小结"><a href="#8-6-原书小结" class="headerlink" title="8.6 原书小结"></a>8.6 原书小结</h3><p>浏览器对象模型（BOM)以window对象为依托，表示浏览器窗口以及页面可见区域。同时，window对象还是ECMAScript中的Global对象，因而所有全局变量和函数都是它的属性，且所有原生的构造函数及其他函数也都存在于它的命名空间下。本章讨论了下列BOM的组成部分。</p><ul><li>在使用框架时，每个框架都有自己的window对象以及所有原生构造函数及其他函数的副本。<br>每个框架都保存在frames集合中，可以通过位置或通过名称来访问。</li><li>有一些窗口指针，可以用来引用其他框架，包括父框架。</li><li>top对象始终指向最外围的框架，也就是整个浏览器窗口。</li><li>parent对象表示包含当前框架的框架，而self对象则回指window。</li><li>使用location对象可以通过编程方式来访问浏览器的导航系统。设置相应的属性，可以逐段或整体性地修改浏览器的URL。</li><li>调用replace()方法可以导航到一个新URL,同时该URL会替换浏览器历史记录中当前显示的页面。</li><li>navigator对象提供了与浏览器有关的信息。到底提供哪些信息，很大程度上取决于用户的浏览器；不过，也有一些公共的属性（如userAgent)存在于所有浏览器中。</li></ul><p>BOM中还有两个对象：screen和history,但它们的功能有限。screen对象中保存着与客户端显示器有关的信息，这些信息一般只用于站点分析。history对象为访问浏览器的历史记录开了一个小缝隙，开发人员可以据此判断历史记录的数量，也可以在历史记录中向后或向前导航到任意页面。</p><h2 id="第十章-DOM"><a href="#第十章-DOM" class="headerlink" title="第十章 DOM"></a>第十章 DOM</h2><p>DOM（文档对象模型）是针对HTML和XML文档的一个API（应用程序编程接口）。描绘了一个层次化的节点树。</p><h3 id="10-1-节点层次"><a href="#10-1-节点层次" class="headerlink" title="10.1 节点层次"></a>10.1 节点层次</h3><p>DOM可以将任何HTML或XML文档描绘成一个由多层节点构成的结构，形成节点树（根节点为文档元素）。</p><p>插入节点的用法：<code>someNode.insertBefore(newNode,nodePosition)</code>或者<code>someNode.appendChild(nodePosition)</code>，<br>替换节点的用法：<code>someNode.replaceChild(newNode,nodePosition)</code><br>移除节点的用法：<code>someNode.removeChild(newNode,nodePosition)</code><br>(nodePosition = (…someNode.firstChild、someNode.lastChild、null…))<br>cloneNode()用于复制节点特性，normalize()用于处理文档树中的文本节点。</p><h4 id="10-1-2-Document类型"><a href="#10-1-2-Document类型" class="headerlink" title="10.1.2 Document类型"></a>10.1.2 Document类型</h4><p>document表示整个HTML页面，它是HTMLDocument（继承自Document类型）的一个实例。常用的表示文档子节点的方式是<code>documentElement</code>属性，该属性始终指向<code>&lt;html&gt;</code>标签，也可以通过childNodes列表访问文档元素。</p><p><code>document.title</code>可以获取<code>&lt;title&gt;</code>元素中的值，但是不能修改它。</p><p>document对网页请求相关的属性有：URL（完整的地址栏显示的地址）、domain（只包含页面的域名）、referrer（保存链接到当前页面的过去的URL），这些属性都存在于请求的HTTP头部。</p><p>document中用于查找元素的方法：<code>getElementById()</code>（匹配首个页面元素的id特性（IE7存在匹配表单元素（<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;button&gt;</code>、<code>&lt;select&gt;</code>）的name特性的情况））和<code>getElementByTagName()</code>（匹配页面元素的标签名，返回一个HTMLCollection，通过[]或item()方法访问其中的项），HTMLCollection中存在[]或nameItem()去按特性名选择项<br>HTMLDocument中特有的方法getElementByName()取得name特性的所有元素，返回一个HTMLCollection。</p><h4 id="10-1-3-Element类型"><a href="#10-1-3-Element类型" class="headerlink" title="10.1.3 Element类型"></a>10.1.3 Element类型</h4><p>HTML中的标签名均以大写表示，转换为小写形式toLowerCase()避免不必要的操作问题（同时满足了HTML和XML）。</p><p>每个HTML元素都存在的属性：id（唯一标识符）、className（属性名）、title、lang、dir（语言方向 ltr or rtl）。<br>getAttribute()、setAttribute()和removeAttribute()用来对元素的特性进行处理操作。</p><p>通过document.createElement()方法来创建新元素，然后由document.body.appendChild()将新元素加入DOM树中。</p><p>在获取并遍历子节点的过程中，需要先检验一下nodeType的属性，如下<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i=<span class="number">0</span>,len=element.childNodes.length; i&lt;len; i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(element.childNodes[i].nodeType ==<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="comment">//执行某些操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="10-1-4-Text类型"><a href="#10-1-4-Text类型" class="headerlink" title="10.1.4 Text类型"></a>10.1.4 Text类型</h4><h4 id="10-1-5-Comment类型"><a href="#10-1-5-Comment类型" class="headerlink" title="10.1.5 Comment类型"></a>10.1.5 Comment类型</h4><h4 id="10-1-6-CDATASection类型"><a href="#10-1-6-CDATASection类型" class="headerlink" title="10.1.6 CDATASection类型"></a>10.1.6 CDATASection类型</h4><h4 id="10-1-7-DocumentType类型"><a href="#10-1-7-DocumentType类型" class="headerlink" title="10.1.7 DocumentType类型"></a>10.1.7 DocumentType类型</h4><h4 id="10-1-8-DocumentFragment类型"><a href="#10-1-8-DocumentFragment类型" class="headerlink" title="10.1.8 DocumentFragment类型"></a>10.1.8 DocumentFragment类型</h4><h4 id="10-1-9-Attr类型"><a href="#10-1-9-Attr类型" class="headerlink" title="10.1.9 Attr类型"></a>10.1.9 Attr类型</h4><h3 id="10-2-DOM操作技术"><a href="#10-2-DOM操作技术" class="headerlink" title="10.2 DOM操作技术"></a>10.2 DOM操作技术</h3><p>插入外部动态脚本<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span> src=<span class="string">"client.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure></p><p>与同台脚本相似，动态样式是在页面加载完成后动态添加页面中的，将下列代码添加至<code>&lt;head&gt;</code>中<br><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"styles.css"</span>&gt;</span><br></pre></td></tr></table></figure></p><h3 id="10-3-原书小结"><a href="#10-3-原书小结" class="headerlink" title="10.3 原书小结"></a>10.3 原书小结</h3><p>DOM是语言中立的API,用于访问和操作HTML和XML文档。DOM1级将HTML和XML文档形象地看作一个层次化的节点树，可以使用JavaScript来操作这个节点树，进而改变底层文档的外观和结构。<br>DOM由各种节点构成，简要总结如下。</p><ul><li>最基本的节点类型是Node,用于抽象地表示文档中一个独立的部分；所有其他类型都继承自Node。</li><li>Document类型表示整个文档，是一组分层节点的根节点。在JavaScript中，document对象是Document的一个实例。使用document对象，有很多种方式可以查询和取得节点。</li><li>Element 节点表示文档中的所有HTML或XML元索，可以用来操作这些元素的内容和特性。</li><li>另外还有一些节点类型，分别表示文本内容、注释、文档类型、CDATA区域和文档片段。</li><li>访问DOM的操作在多数情况下都很直观，不过在处理<script>和<style>元素时还是存在一些复杂性。由于这两个元素分别包含脚本和样式信息，因此浏览器通常会将它们与其他元素区别对待。这些区别导致了在针对这些元素使用innerHTML时，以及在创建新元素时的一些问题。</li><li>理解DOM的关键，就是理解DOM对性能的影响。DOM操作往往是JavaScript程序中开销最大的部分，而因访问NodeList导致的问题为最多。NodeList对象都是“动态的”，这就意味着每次访问NodeList对象，都会运行一次查询。有鉴于此，最好的办法就是尽量减少DOM操作。</li></ul><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li>《JavaScript高级程序设计（第三版）》</li></ul></script></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MDN文档学习</title>
      <link href="/2019/11/27/MDN%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"/>
      <url>/2019/11/27/MDN%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="MDN文档学习"><a href="#MDN文档学习" class="headerlink" title="MDN文档学习"></a>MDN文档学习</h1><h2 id="Part-1-Web入门"><a href="#Part-1-Web入门" class="headerlink" title="Part 1.Web入门"></a>Part 1.Web入门</h2><h3 id="HTML基础"><a href="#HTML基础" class="headerlink" title="HTML基础"></a>HTML基础</h3><p>超文本标记语言（英语：Hypertext Markup Language，简称：HTML），一种结构化Web网页及其内容的<strong>标记语言</strong>。</p><p>整体单元结构如下<br><img alt="段落元素" data-src="https://mdn.mozillademos.org/files/16475/element.png" class="lozad"><br><img alt="元素属性" data-src="https://mdn.mozillademos.org/files/16476/attribute.png" class="lozad"></p><p>HTML文档介绍<br><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span>      <span class="comment">&lt;!--包含了整个页面的内容，有时也被称作根元素--&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">head</span>&gt;</span>      <span class="comment">&lt;!--包含例如面向搜索引擎的搜索关键字（keywords）、页面描述、CSS 样式表和字符编码声明等--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">title</span>&gt;</span>测试页面<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">body</span>&gt;</span>        <span class="comment">&lt;!--包含期望让用户在访问页面时看到的内容--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">"images/icon.png"</span> <span class="attr">alt</span>=<span class="string">"测试图片"</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p><p>常用标签一览：</p><ul><li><code>&lt;img&gt;</code>：图像，src包含文件路径，alt为描述文本</li><li><code>&lt;h&gt;</code>：标题</li><li><code>&lt;p&gt;</code>：段落</li><li><code>&lt;ul&gt;</code>：无序列表</li><li><code>&lt;ol&gt;</code>：有序列表</li><li><code>&lt;li&gt;</code>：列表项元素</li><li><code>&lt;a&gt;</code>：链接，href包含链接网站</li></ul><h3 id="CSS基础"><a href="#CSS基础" class="headerlink" title="CSS基础"></a>CSS基础</h3><p>层叠样式表（Cascading Style Sheet，简称：CSS），为网页添加样式。</p><p><img alt="CSS规则集" data-src="https://mdn.mozillademos.org/files/16483/css-declaration.png" class="lozad"></p><p>常用<a href="https://developer.mozilla.org/zh-CN/docs/Learn/CSS/Introduction_to_CSS/Selectors" target="_blank" rel="noopener">选择器</a></p><div class="table-container"><table><thead><tr><th>选择器名称</th><th>选择的内容</th><th>示例</th></tr></thead><tbody><tr><td>元素选择器（也称作标签或类型选择器）</td><td>所有指定类型的 HTML 元素</td><td>p 选择 <code>&lt;p&gt;</code></td></tr><tr><td>ID 选择器</td><td>具有特定 ID 的元素（单一 HTML 页面中，每个 ID 只对应一个元素，一个元素只对应一个 ID）</td><td>#my-id选择 <code>&lt;p id=&quot;my-id&quot;&gt;</code> 或 <code>&lt;a id=&quot;my-id&quot;&gt;</code></td></tr><tr><td>类选择器</td><td>具有特定类的元素（单一页面中，一个类可以有多个实例）</td><td>.my-class选择 <code>&lt;p class=&quot;my-class&quot;&gt;</code> 和 <code>&lt;a class=&quot;my-class&quot;&gt;</code></td></tr><tr><td>属性选择器</td><td>拥有特定属性的元素</td><td>img[src]选择 <code>&lt;img src=&quot;myimage.png&quot;&gt;</code> 而不是 <code>&lt;img&gt;</code></td></tr><tr><td>伪（Pseudo）类选择器</td><td>特定状态下的特定元素（比如鼠标指针悬停）</td><td>a:hover仅在鼠标指针悬停在链接上时选择 <code>&lt;a&gt;</code>。</td></tr></tbody></table></div><p><img alt="盒模型" data-src="https://mdn.mozillademos.org/files/9443/box-model.png" class="lozad"></p><ul><li>width ：元素的宽度</li><li>background-color ：元素内容和内边距底下的颜色</li><li>color ：元素内容（通常是文本）的颜色</li><li>text-shadow ：为元素内的文本设置阴影</li><li>display ：设置元素的显示模式</li><li>margin: top right bottom left</li><li>……</li></ul><h3 id="JavaScript基础"><a href="#JavaScript基础" class="headerlink" title="JavaScript基础"></a>JavaScript基础</h3><p>JavaScript（缩写：JS），动态编程语言。</p><p>我们将 <code>&lt;script&gt;</code> 放在HTML文件的底部附近的原因是浏览器会按照代码在文件中的顺序加载 HTML。如果先加载的 JavaScript 期望修改其下方的 HTML，那么它可能由于 HTML 尚未被加载而失效。因此，将 JavaScript 代码放在 HTML页面的底部附近通常是最好的策略。</p><ul><li>变量：var 或 let，let会更加的严谨，不允许重复定义类型</li><li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Data_structures" target="_blank" rel="noopener">数值类型参考</a></li><li><p>注释</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> *  段落注释</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 行注释</span></span><br></pre></td></tr></table></figure></li><li><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators" target="_blank" rel="noopener">表达式和运算符</a></p></li><li>函数（Function）：<code>document.querySelector</code>和 <code>alert</code> 是浏览器内置的函数，随时可用。</li><li>事件：<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="built_in">document</span>.querySelector(<span class="string">'html'</span>).onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br></pre></td></tr></table></figure></li></ul><h2 id="HTML-构建Web"><a href="#HTML-构建Web" class="headerlink" title="HTML-构建Web"></a>HTML-构建Web</h2><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ul><li><a href="https://developer.mozilla.org/zh-CN/docs/Learn/Getting_started_with_the_web" target="_blank" rel="noopener">MDN入门教程</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习记录 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[阅读笔记]HTTP权威指南</title>
      <link href="/2019/11/24/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/"/>
      <url>/2019/11/24/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-HTTP%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读笔记-HTTP权威指南"><a href="#阅读笔记-HTTP权威指南" class="headerlink" title="[阅读笔记]HTTP权威指南"></a>[阅读笔记]HTTP权威指南</h1><h2 id="第一章-HTTP概述"><a href="#第一章-HTTP概述" class="headerlink" title="第一章 HTTP概述"></a>第一章 HTTP概述</h2><h3 id="Q-amp-A"><a href="#Q-amp-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol><li><p>Web客户端与服务器是如何通信的</p><p> 客户端向服务器进行HTTP请求，服务器进行HTTP响应回传所请求的数据（包括对象、对象类型、对象长度等信息）</p></li><li><p>（表示Web内容的）资源来自何方</p><p> 可以是存储在Web服务器文件系统中的静态文件，也可以是软件程序根据需要生成的内容（媒体等）</p></li><li><p>Web事务是怎样工作的</p><p> 事务由请求和响应构成，通过HTTP报文的格式化数据块进行通信</p></li><li><p>HTTP通信所使用的报文格式</p><p> 分为请求报文和响应报文，主体分三部分：起始行（请求做什么，响应出现什么情况）、首部字段和可选的主体</p></li><li><p>底层TCP网络传输</p><p> 由URL获取HTTP服务器的IP地址和端口号（其中域名服务DNS可以将主机名转换为对应的IP地址），通过网际协议IP地址和端口号建立客户端和服务器之间的TCP/IP通道，TCP进行无差错、按序、为分段的数据传输（基于文本的）。</p></li><li><p>不同的HTTP协议变体</p><p> 广泛使用HTTP/1.0</p></li><li><p>因特网上安装的大量HTTP架构组件中的一部分</p><p> 代理（位于客户端和服务器之间的负责转发工作的HTTP代理服务器）、缓存（HTTP仓库，经代理传送的常用文档复制保存做副本，留下次请求同一文档时提供服务）、网关（将HTTP流量转换成其他协议，连接其他应用程序的特殊Web服务器）、隧道（对HTTP通道报文进行盲转发的特殊代理，常见用途是通过HTTP连接承载加密的安全套接字层SSL流量）、Agent代理（代表用户发起HTTP请求的Web客户端程序，如Web浏览器等）</p></li></ol><h2 id="第二章-URL与资源"><a href="#第二章-URL与资源" class="headerlink" title="第二章 URL与资源"></a>第二章 URL与资源</h2><p>待续。。。。。。  </p><h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><ol><li>《HTTP权威指南》</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[阅读笔记]HTML5秘籍</title>
      <link href="/2019/11/23/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-HTML5%E7%A7%98%E7%B1%8D/"/>
      <url>/2019/11/23/%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0-HTML5%E7%A7%98%E7%B1%8D/</url>
      
        <content type="html"><![CDATA[<h1 id="阅读笔记-HTML5秘籍-章节1-4"><a href="#阅读笔记-HTML5秘籍-章节1-4" class="headerlink" title="[阅读笔记]HTML5秘籍(章节1~4)"></a>[阅读笔记]HTML5秘籍(章节1~4)</h1><h2 id="Part-1-HTML5简介"><a href="#Part-1-HTML5简介" class="headerlink" title="Part 1. HTML5简介"></a>Part 1. HTML5简介</h2><p>HTML5集合了之前所有的特性，同时涵盖往后的新特性，给人的印象大概就是新旧集合的元素堆叠，不排除任一个阵营的喜好，可严谨抑又可拓展的存在，海纳百川 :D（我只是在真实的反映浏览器真实现状罢了。</p><p>顺便跟flash插件说声ヾ(•ω•`)o</p><h2 id="Part-2-构造网页新方式"><a href="#Part-2-构造网页新方式" class="headerlink" title="Part 2. 构造网页新方式"></a>Part 2. 构造网页新方式</h2><p>div和span的功能相近，用于将内容分块，不过div为分块元素（换行）而span为行内元素（不换行）</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/font-size" target="_blank" rel="noopener">font-size</a></p><p>新增的<code>&lt;header&gt;``&lt;footer&gt;``&lt;hgroup&gt;``&lt;figure&gt;</code>等其实就是使得原本分块的<code>&lt;div&gt;</code>换至意义更加的明确，更加针对你（逃，偷懒+习惯<code>&lt;div&gt;</code>使然</p><h2 id="Part-3-有意义的标记"><a href="#Part-3-有意义的标记" class="headerlink" title="Part 3. 有意义的标记"></a>Part 3. 有意义的标记</h2><p>如章节题给所言，主要记录的都是具有特定含义的标签，特殊用法都可通过在MDN上检索查询，这里也就不再赘述，仅供自己检索</p><h2 id="Part-4-Web表单"><a href="#Part-4-Web表单" class="headerlink" title="Part 4. Web表单"></a>Part 4. Web表单</h2><p>通过列表、文本框、按钮等收集用户数据即是表单</p><p>关于表单控件、样式的诸多介绍，因为并没有必要的需求，暂时草草掠过后续有需要再回看。</p><h2 id="Part-0-使用工具及参考文献"><a href="#Part-0-使用工具及参考文献" class="headerlink" title="Part 0.使用工具及参考文献"></a>Part 0.使用工具及参考文献</h2><ul><li>《HTML5秘籍/HTML5:The Missing Manual》（Matthew.MacDonald）</li><li>查询哪个浏览器支持的HTML5功能网站：<a href="http://caniuse.com" target="_blank" rel="noopener">http://caniuse.com</a></li><li>各国语言检索：<a href="https://www.w3school.com.cn/tags/html_ref_language_codes.asp" target="_blank" rel="noopener">lang属性</a></li><li>h5在线验错：<a href="https://validator.w3.org/nu/" target="_blank" rel="noopener">标签疏漏</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 读书笔记 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]64.Minimum Path Sum</title>
      <link href="/2019/10/07/Leetcode-64-Minimum-Path-Sum/"/>
      <url>/2019/10/07/Leetcode-64-Minimum-Path-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="64-Minimum-Path-Sum-最小路径和"><a href="#64-Minimum-Path-Sum-最小路径和" class="headerlink" title="#64.Minimum Path Sum(最小路径和)"></a>#64.Minimum Path Sum(最小路径和)</h1><ul><li>难度: 中等</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</span><br><span class="line"></span><br><span class="line">说明：每次只能向下或者向右移动一步。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  [1,3,1],</span><br><span class="line">  [1,5,1],</span><br><span class="line">  [4,2,1]</span><br><span class="line">]</span><br><span class="line">输出: 7</span><br><span class="line">解释: 因为路径 1→3→1→1→1 的总和最小。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 这道题给了我们一个只有非负数的二维数组，让找一条从左上到右下的路径，使得路径和最小，限定了每次只能向下或者向右移动。一个常见的错误解法就是每次走右边或下边数字中较小的那个，这样的贪婪算法获得的局部最优解不一定是全局最优解，因此是不行的。实际上这道题跟之前那道 Dungeon Game 没有什么太大的区别，都需要用动态规划 Dynamic Programming 来做，这应该算是 DP 问题中比较简单的一类，我们维护一个二维的 dp 数组，其中 dp[i][j] 表示到达当前位置的最小路径和。接下来找状态转移方程，因为到达当前位置 (i, j)  只有两种情况，要么从上方 (i-1, j) 过来，要么从左边 (i, j-1) 过来，我们选择 dp 值较小的那个路径，即比较 dp[i-1][j] 和 dp[i][j-1]，将其中的较小值加上当前的数字 grid[i][j]，就是当前位置的 dp 值了。但是有些特殊情况要提前赋值，比如起点位置，直接赋值为 grid[0][0]，还有就是第一行和第一列，其中第一行的位置只能从左边过来，第一列的位置从能从上面过来，所以这两行要提前初始化好，然后再从 (1, 1) 的位置开始更新到右下角即可，反正难度不算大，代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) dp[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>] + dp[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) dp[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j] + dp[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + min(dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[m - <span class="number">1</span>][n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">### 方法二:</span><br><span class="line">- 说明: 可以优化空间复杂度，可以使用一个一维的 dp 数组就可以了，初始化为整型最大值，但是 dp[<span class="number">0</span>][<span class="number">0</span>] 要初始化为<span class="number">0</span>。之所以可以用一维数组代替之前的二维数组，是因为当前的 dp 值只跟左边和上面的 dp 值有关。这里我们并不提前更新第一行或是第一列，而是在遍历的时候判断，若j等于<span class="number">0</span>时，说明是第一列，我们直接加上当前的数字，否则就要比较是左边的 dp[j<span class="number">-1</span>] 小还是上面的 dp[j]  小，当是第一行的时候，dp[j] 是整型最大值，所以肯定会取到 dp[j<span class="number">-1</span>] 的值，然后再加上当前位置的数字即可，参见代码如下：</span><br><span class="line">```Cpp</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size(), n = grid[<span class="number">0</span>].size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, INT_MAX);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (j == <span class="number">0</span>) dp[j] += grid[i][j];</span><br><span class="line">                <span class="keyword">else</span> dp[j] = grid[i][j] + min(dp[j], dp[j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h3><ul><li><p>说明: 还可以进一步的优化空间，连一维数组都不用新建，而是直接使用原数组 grid 进行累加，这里的累加方式跟解法一稍有不同，没有提前对第一行和第一列进行赋值，而是放在一起判断了，当i和j同时为0时，直接跳过。否则当i等于0时，只加上左边的值，当j等于0时，只加上面的值，否则就比较左边和上面的值，加上较小的那个即可，参见代码如下：</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) grid[<span class="number">0</span>][j] += grid[<span class="number">0</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) grid[i][<span class="number">0</span>] += grid[i - <span class="number">1</span>][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += min(grid[i - <span class="number">1</span>][j], grid[i][j - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p> 思路同上，或者利用 up 和 left 去代替:</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (grid.empty() || grid[<span class="number">0</span>].empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[i].size(); ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">int</span> up = (i == <span class="number">0</span>) ? INT_MAX : grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">int</span> left = (j == <span class="number">0</span>) ? INT_MAX : grid[i][j - <span class="number">1</span>];</span><br><span class="line">                grid[i][j] += min(up, left);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid.back().back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Medium </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]198.House Robber</title>
      <link href="/2019/10/07/Leetcode-198-House-Robber/"/>
      <url>/2019/10/07/Leetcode-198-House-Robber/</url>
      
        <content type="html"><![CDATA[<h1 id="198-House-Robber-打家劫舍"><a href="#198-House-Robber-打家劫舍" class="headerlink" title="#198.House Robber(打家劫舍)"></a>#198.House Robber(打家劫舍)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</span><br><span class="line"></span><br><span class="line">给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,2,3,1]</span><br><span class="line">输出: 4</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br><span class="line">     偷窃到的最高金额 = 1 + 3 = 4 。</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [2,7,9,3,1]</span><br><span class="line">输出: 12</span><br><span class="line">解释: 偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。</span><br><span class="line">     偷窃到的最高金额 = 2 + 9 + 1 = 12</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一(动态规划):"></a>方法一(动态规划):</h3></li><li>思路: 本质相当于在一列数组中取出一个或多个不相邻数，使其和最大。那么对于这类求极值的问题首先考虑动态规划 Dynamic Programming 来解，维护一个一位数组 dp，其中 dp[i] 表示 [0, i] 区间可以抢夺的最大值，对当前i来说，有抢和不抢两种互斥的选择，不抢即为 dp[i-1]（等价于去掉 nums[i] 只抢 [0, i-1] 区间最大值），抢即为 dp[i-2] + nums[i]（等价于去掉 nums[i-1]）。状态转移方程 dp[i] = max(num[i] + dp[i - 2], dp[i - 1]), 且需要初始化 dp[0] 和 dp[1]，其中 dp[0] 即为 num[0]，dp[1] 此时应该为 max(num[0], num[1])，代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;num)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (num.size() &lt;= <span class="number">1</span>) <span class="keyword">return</span> num.empty() ? <span class="number">0</span> : num[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp = &#123;num[<span class="number">0</span>], max(num[<span class="number">0</span>], num[<span class="number">1</span>])&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; num.size(); ++i) &#123;</span><br><span class="line">            dp.push_back(max(num[i] + dp[i - <span class="number">2</span>], dp[i - <span class="number">1</span>]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><ul><li>思路: 核心思想还是用 DP，分别维护两个变量 robEven 和 robOdd，顾名思义，robEven 就是要抢偶数位置的房子，robOdd 就是要抢奇数位置的房子。所以在遍历房子数组时，如果是偶数位置，那么 robEven 就要加上当前数字，然后和 robOdd 比较，取较大的来更新 robEven。这里就看出来了，robEven 组成的值并不是只由偶数位置的数字，只是当前要抢偶数位置而已。同理，当奇数位置时，robOdd 加上当前数字和 robEven 比较，取较大值来更新 robOdd，这种按奇偶分别来更新的方法，可以保证组成最大和的数字不相邻，最后在 robEven 和 robOdd 种取较大值返回，代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> robEven = <span class="number">0</span>, robOdd = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i % <span class="number">2</span> == <span class="number">0</span>) &#123;</span><br><span class="line">                robEven = max(robEven + nums[i], robOdd);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                robOdd = max(robEven, robOdd + nums[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(robEven, robOdd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h3><ul><li>思路: 上述方法的进一步简洁，我们使用两个变量 rob 和 notRob，其中 rob 表示抢当前的房子，notRob 表示不抢当前的房子，那么在遍历的过程中，先用两个变量 preRob 和 preNotRob 来分别记录更新之前的值，由于 rob 是要抢当前的房子，那么前一个房子一定不能抢，所以使用 preNotRob 加上当前的数字赋给 rob，然后 notRob 表示不能抢当前的房子，那么之前的房子就可以抢也可以不抢，所以将 preRob 和 preNotRob 中的较大值赋给 notRob，参见代码如下：<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> rob = <span class="number">0</span>, notRob = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> preRob = rob, preNotRob = notRob;</span><br><span class="line">            rob = preNotRob + nums[i];</span><br><span class="line">            notRob = max(preRob, preNotRob);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(rob, notRob);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Easy </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]746.Min Cost Climbing Stairs</title>
      <link href="/2019/10/07/Leetcode-746-Min-Cost-Climbing-Stairs/"/>
      <url>/2019/10/07/Leetcode-746-Min-Cost-Climbing-Stairs/</url>
      
        <content type="html"><![CDATA[<h1 id="746-Min-Cost-Climbing-Stairs-使用最小花费爬楼梯"><a href="#746-Min-Cost-Climbing-Stairs-使用最小花费爬楼梯" class="headerlink" title="#746.Min Cost Climbing Stairs(使用最小花费爬楼梯)"></a>#746.Min Cost Climbing Stairs(使用最小花费爬楼梯)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">数组的每个索引做为一个阶梯，第 i个阶梯对应着一个非负数的体力花费值 cost[i](索引从0开始)。</span><br><span class="line"></span><br><span class="line">每当你爬上一个阶梯你都要花费对应的体力花费值，然后你可以选择继续爬一个阶梯或者爬两个阶梯。</span><br><span class="line"></span><br><span class="line">您需要找到达到楼层顶部的最低花费。在开始时，你可以选择从索引为 0 或 1 的元素作为初始阶梯。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: cost = [10, 15, 20]</span><br><span class="line">输出: 15</span><br><span class="line">解释: 最低花费是从cost[1]开始，然后走两步即可到阶梯顶，一共花费15。</span><br><span class="line"></span><br><span class="line"> 示例 2:</span><br><span class="line">输入: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]</span><br><span class="line">输出: 6</span><br><span class="line">解释: 最低花费方式是从cost[0]开始，逐个经过那些1，跳过cost[3]，一共花费6。</span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line">cost 的长度将会在 [2, 1000]。</span><br><span class="line">每一个 cost[i] 将会是一个Integer类型，范围为 [0, 999]。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一(动态规划):"></a>方法一(动态规划):</h3></li><li><p>思路: 定义一个一维的dp数组，其中dp[i]表示爬到第i层的最小cost，dp[i]到第i层只有两种可能性，一个是从第i-2层上直接跳上来，一个是从第i-1层上跳上来。dp[i]只和前两层有关系，所以可以写做如下:</p><p>  <strong>dp[i] = min(dp[i- 2] + cost[i - 2], dp[i - 1] + cost[i - 1])</strong></p><p>  最后返回最后一个数字dp[n]即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n + <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            dp[i] = min(dp[i- <span class="number">2</span>] + cost[i - <span class="number">2</span>], dp[i - <span class="number">1</span>] + cost[i - <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><ul><li><p>思路: 跟上面的解法很相近，不同在于dp数组长度为n，其中dp[i]表示到第i+1层的最小cost，分别初始化dp[0]和dp[1]为cost[0]和cost[1]。然后从i=2处开始遍历，此时我们的更新思路是，要爬当前的台阶，肯定需要加上当前的cost[i]，那么我们还是要从前一层或者前两层的台阶上跳上来，那么我们选择dp值小的那个，所以递归式如下：</p><p>  <strong>dp[i] = cost[i] + min(dp[i- 1], dp[i - 2])</strong></p><p>  最后在最后两个dp值中选择一个较小的返回即可</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = cost[<span class="number">0</span>]; dp[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i] = cost[i] + min(dp[i- <span class="number">1</span>], dp[i - <span class="number">2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(dp[n - <span class="number">1</span>], dp[n - <span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三"><a href="#方法三" class="headerlink" title="方法三:"></a>方法三:</h3><ul><li>说明: 可以对空间复杂度进行优化，通过前面的分析我们可以发现，当前的dp值仅仅依赖前面两个的值，所以不必把整个dp数组都记录下来，只需用两个变量a和b来记录前两个值，然后不停的用新得到的值来覆盖它们就好了。我们初始化a和b均为0，然后遍历cost数组，首先将a和b中较小值加上num放入临时变量t中，然后把b赋给a，把t赋给b即可，参见代码如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">0</span>, b = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> num : cost) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = min(a, b) + num;</span><br><span class="line">            a = b;</span><br><span class="line">            b = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法四-递归法"><a href="#方法四-递归法" class="headerlink" title="方法四(递归法):"></a>方法四(递归法):</h3><ul><li>说明: 还可以用递归来写，需要优化计算量，即用HashMap来保存已经算过了台阶，用的还是dp的思想，参见代码如下<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        <span class="keyword">return</span> helper(cost, cost.size(), memo);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost, <span class="keyword">int</span> i, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (memo.count(i)) <span class="keyword">return</span> memo[i];</span><br><span class="line">        <span class="keyword">if</span> (i &lt;= <span class="number">1</span>) <span class="keyword">return</span> memo[i] = cost[i];</span><br><span class="line">        <span class="keyword">return</span> memo[i] = (i == cost.size() ? <span class="number">0</span> : cost[i]) + min(helper(cost, i - <span class="number">1</span>, memo), helper(cost, i - <span class="number">2</span>, memo));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Easy </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]167.two sum ii-input array is sorted(两数之和 II - 输入有序数组)</title>
      <link href="/2019/10/02/Leetcode-167-two-sum-ii-input-array-is-sorted/"/>
      <url>/2019/10/02/Leetcode-167-two-sum-ii-input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="#167. 两数之和 II - 输入有序数组"></a>#167. 两数之和 II - 输入有序数组</h1><ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</span><br><span class="line"></span><br><span class="line">函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">返回的下标值（index1 和 index2）不是从零开始的。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure></li><li><p>解答：</p></li></ul><h3 id="方法1-双指针"><a href="#方法1-双指针" class="headerlink" title="方法1. 双指针"></a>方法1. 双指针</h3><ul><li>思路：使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。</li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time: O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> left=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right=numbers.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = numbers[left]+numbers[right];</span><br><span class="line">            <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;left+<span class="number">1</span>,right+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="补充解法：二分查找-效率不如上一种"><a href="#补充解法：二分查找-效率不如上一种" class="headerlink" title="补充解法：二分查找(效率不如上一种)"></a>补充解法：二分查找(效率不如上一种)</h3><ul><li>思路: 因为一定有解，而且数组是有序的，那么第一个数字肯定要小于目标值target，那么我们每次用二分法来搜索target - numbers[i]即可<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time: O(nlgn)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - numbers[i], left = i + <span class="number">1</span>, right = numbers.size();</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (numbers[mid] == t) <span class="keyword">return</span> &#123;i + <span class="number">1</span>, mid + <span class="number">1</span>&#125;;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (numbers[mid] &lt; t) left = mid + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Easy </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 双指针 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]493.Reverse Pairs</title>
      <link href="/2019/10/02/Leetcode-493-Reverse-Pairs/"/>
      <url>/2019/10/02/Leetcode-493-Reverse-Pairs/</url>
      
        <content type="html"><![CDATA[<ul><li>难度: 困难</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组 nums ，如果 i &lt; j 且 nums[i] &gt; 2*nums[j] 我们就将 (i, j) 称作一个重要翻转对。</span><br><span class="line"></span><br><span class="line">你需要返回给定数组中的重要翻转对的数量。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [1,3,2,3,1]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [2,4,3,5,1]</span><br><span class="line">输出: 3</span><br><span class="line"></span><br><span class="line">注意:</span><br><span class="line"></span><br><span class="line">给定数组的长度不会超过50000。</span><br><span class="line">输入数组中的所有数字都在32位整数的表示范围内。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-分治法"><a href="#方法一-分治法" class="headerlink" title="方法一(分治法):"></a>方法一(分治法):</h3></li><li>思路: 基本思路为分割重现关系 (Partition Recurrence Relation)，用式子表示为 <strong>T(i, j) = T(i, m) + T(m+1, j) + C</strong>。这里的 C 就是处理合并两个部分的子问题，那么用文字来描述就是 “已知翻转对的两个数字分别在子数组 nums[i, m] 和 nums[m+1, j] 之中，求满足要求的翻转对的个数”，这里翻转对的两个条件中的顺序条件已经满足，就只需要找到满足大小关系的的数对即可。这里两个数字都是不确定的，如果用暴力搜索肯定会被 OJ 唾弃。但是如果两个子数组是有序的，那么我们可以用双指针的方法在线性时间内就可以统计出符合题意的翻转对的个数。要想办法产生有序的子数组，那么这就和 MergeSort 的核心思想完美匹配了。我们知道混合排序就是不断的将数组对半拆分成子数组，拆到最小的数组后开始排序，然后一层一层的返回，最后原数组也是有序的了。这里我们在混合排序的递归函数中，对于有序的两个子数组进行统计翻转对的个数，区间 [left, mid] 和 [mid+1, right] 内的翻转对儿个数就被分别统计出来了，此时还要统计翻转对儿的两个数字分别在两个区间中的情况，那么i遍历 [left, mid] 区间所有的数字，j则从 mid+1 开始检测，假如 nums[i] 大于 nums[j] 的二倍，则这两个数字就是翻转对，此时j再自增1，直到不满足这个条件停止，则j增加的个数就是符合题意的翻转对的个数，所以用当前的j减去其初始值 mid+1 即为所求，然后再逐层返回，这就完美的实现了上述的分割重现关系的思想。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mergeSort(nums, <span class="number">0</span>, nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">mergeSort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> res = mergeSort(nums, left, mid) + mergeSort(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = mid + <span class="number">1</span>; i &lt;= mid; ++i) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &lt;= right &amp;&amp; nums[i] / <span class="number">2.0</span> &gt; nums[j]) ++j;</span><br><span class="line">            res += j - (mid + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sort(nums.begin() + left, nums.begin() + right + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-树状数组"><a href="#方法二-树状数组" class="headerlink" title="方法二(树状数组):"></a>方法二(树状数组):</h3><ul><li><p>思路: 基本思路为顺序重现关系(Sequential Recurrence Relation)，用式子表示为 <strong>T(i, j) = T(i, j - 1) + C</strong> 。这里的 C 就是处理最后一个数字的子问题，用文字来描述为 “已知翻转对的第二个数字为 nums[j], 在子数组 nums[i, j - 1] 中找翻转对的第一个数字” ，这里翻转对的两个条件中的顺序条件已经满足，就只需要找比 2* nums[j] 大的数即可。当然最简单的方法就是线性扫描，但这样整个时间复杂度就会上升到 O(n^2)。由于二分搜索和 BST 等方法已经被 OJ 阉割，所以这里只能用树状数组 Binary Indexed Tree 来做。由于 BIT 的存储方式不是将数组中的数字对应的一一存入，而是有的对应存入，有的是存若干个数字之和，其设计初衷之一就是要在 O(lgn) 的时间复杂度下完成求和运算。</p><p>  首先我们应该确定一个遍历的方向，这里推荐从后往前遍历数组，这样做的好处是对于当前遍历到的数字，在已遍历过的数字中找小于当前数字的一半 (nums[i]/2.0) 的数，这样的遍历方向也能跟上面的顺序重现关系的定义式统一。当然如果你想强行从前往后遍历，也不是不行，那么就需要在已遍历的数字中找大于当前数字的二倍 (nums[i]* 2) 的数字就行。由于我们要在之前遍历过的数字中找符合条件的数字，怎么样利用 BIT 的特性来快速的找到是这种解法的最大难点。我们需要将之前遍历过的数字存入 BIT 中，怎么存是难点。由于之前那篇博客我们知道 BIT 用 update 函数来存数，需要提供要存入的位置和要存入的数字这两个参数，那么这里难道我们就按照数字在原数组中的位置存入 BIT 吗，这样做毫无意义！我们要存的是该数字在有序数组中的位置，而且存入的也不是该数字本身，而是该数字出现的次数1。我们用题目中的第一个例子来说明，我们先给数组排序，得到：</p><p>  1 1 2 3 3</p><p>  对于每一个数字我们要确定其在 BIT 中的位置，由于有重复数字的存在，那么每个数字对应的位置就是其最后出现的位置，而且因为 BIT 是从1开始的，并不是像一般的数组那样从0开始，那么有如下对应关系：</p><p>  1-&gt;2, 2-&gt;3, 3-&gt;5</p><p>  那么当我们遇到数字1了，就 update(2,1)，遇到数字2了，就 update(3,1)，遇到数字3了，就 update(5,1)。我们之前解释了并不把数字本身存入 BIT，而是将其对应的位置存入 BIT，真正存入的数字是1，这样方便累加，而且由于1是固定的，在下面的代码中就不用将1当作函数的参数了。这样我们知道了如果存入数字，那么我们在遍历到新数字时，为了得到符合要求的数字的个数，需利用 BIT 的 getSum 函数。getSum 函数需要提供一个位置参数，可以返回该位置之前的所有数之和。同理，我们提供的参数既不是当前遍历到的数字本身，也不是其在原数组中的位置，而是该数字的一半 (nums[i]/2.0) 在有序数组中的正确位置，可以用 lower_bound 函数来找第一个不小于目标值的位置，当然我们也可以自己写个二分搜索的子函数来代替 lower_bound 函数。比如我们当前遍历到的数字是3，那么我们在有序数组中找 1.5 的位置，返回是2，此时我们在 BIT 中用 getSum 来返回位置2之前的数字之和，返回几就表示有几个小于 1.5 的数字。下面列出每一步操作后 BIT 中的结果内容：</p><p>  update(2,1) -&gt; BIT: 0 0 1 0 1 0</p><p>  update(5,1) -&gt; BIT: 0 0 1 0 1 1</p><p>  update(3,1) -&gt; BIT: 0 0 1 1 2 1</p><p>  update(5,1) -&gt; BIT: 0 0 1 1 2 2</p><p>  update(2,1) -&gt; BIT: 0 0 2 1 3 2</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">reversePairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, n = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; v = nums, bit(n + <span class="number">1</span>);</span><br><span class="line">        sort(v.begin(), v.end());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) m[v[i]] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            res += getSum(lower_bound(v.begin(), v.end(), nums[i] / <span class="number">2.0</span>) - v.begin(), bit);</span><br><span class="line">            update(m[nums[i]], bit);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getSum</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            sum += bit[i];</span><br><span class="line">            i -= (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bit)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; bit.size()) &#123;</span><br><span class="line">            bit[i] += <span class="number">1</span>;</span><br><span class="line">            i += (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> Hard </tag>
            
            <tag> 归并排序 </tag>
            
            <tag> 线段树 </tag>
            
            <tag> 树状数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]23.Merge k Sorted Lists(合并K个排序链表)</title>
      <link href="/2019/09/25/Leetcode-23-Merge-k-Sorted-Lists/"/>
      <url>/2019/09/25/Leetcode-23-Merge-k-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<ul><li>难度: 困难</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">合并 k 个排序链表，返回合并后的排序链表。请分析和描述算法的复杂度。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">[</span><br><span class="line">  1-&gt;4-&gt;5,</span><br><span class="line">  1-&gt;3-&gt;4,</span><br><span class="line">  2-&gt;6</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">输出: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4-&gt;5-&gt;6</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-最小堆思想"><a href="#方法一-最小堆思想" class="headerlink" title="方法一(最小堆思想):"></a>方法一(最小堆思想):</h3></li><li>思路: 将 k 个链表的首元素都加入最小堆中，通过自己定义的规则自动排好序。每次取出最小的那个元素加入到最终结果的链表中，把取出元素的下一个元素再加入堆中，下次仍从堆中取出最小的元素做相同的操作，以此类推，直到堆空，此时k个链表也合并为了一个链表，返回首节点即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> cmp = [](ListNode*&amp; a, ListNode*&amp; b) &#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val &gt; b-&gt;val;</span><br><span class="line">        &#125;;</span><br><span class="line">        priority_queue&lt;ListNode*, <span class="built_in">vector</span>&lt;ListNode*&gt;, <span class="keyword">decltype</span>(cmp) &gt; q(cmp);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> node : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span> (node) q.push(node);</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.top(); q.pop();</span><br><span class="line">            cur-&gt;next = t;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;next) q.push(cur-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-分治法"><a href="#方法二-分治法" class="headerlink" title="方法二(分治法):"></a>方法二(分治法):</h3><ul><li>思路: 将 k 个链表先划分为合并两个 k/2 个链表的任务，再不停的往下划分，直到划分成只有一个或两个链表的任务，开始合并。</li><li>说明: 加1操作是为了当 n 为奇数的时候，k能始终从后半段开始，比如当 n=5 时，那么此时 k=3，则 0 和 3 合并，1 和 4 合并，最中间的 2 空出来。当n是偶数的时候，加1也不会有影响，比如当 n=4 时，此时 k=2，那么 0 和 2 合并， 1 和 3 合并，完美解决问题<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.empty()) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">int</span> n = lists.size();</span><br><span class="line">        <span class="keyword">while</span> (n &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n / <span class="number">2</span>; ++i) &#123;</span><br><span class="line">                lists[i] = mergeTwoLists(lists[i], lists[i + k]);</span><br><span class="line">            &#125;</span><br><span class="line">            n = k;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> lists[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode *dummy = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), *cur = dummy;</span><br><span class="line">        <span class="keyword">while</span> (l1 &amp;&amp; l2) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">                cur-&gt;next = l1;</span><br><span class="line">                l1 = l1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur-&gt;next = l2;</span><br><span class="line">                l2 = l2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (l1) cur-&gt;next = l1;</span><br><span class="line">        <span class="keyword">if</span> (l2) cur-&gt;next = l2;</span><br><span class="line">        <span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-混合排序思想"><a href="#方法三-混合排序思想" class="headerlink" title="方法三(混合排序思想):"></a>方法三(混合排序思想):</h3><ul><li>思路: 将原链表分成两段，然后对每段调用递归函数，suppose返回的left和right已经合并好了，然后再对left和right进行递归地合并<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(lists, <span class="number">0</span>, (<span class="keyword">int</span>)lists.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;ListNode*&gt;&amp; lists, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span> (start == end) <span class="keyword">return</span> lists[start];</span><br><span class="line">        <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">        ListNode *left = helper(lists, start, mid);</span><br><span class="line">        ListNode *right = helper(lists, mid + <span class="number">1</span>, end);</span><br><span class="line">        <span class="keyword">return</span> mergeTwoLists(left, right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!l1) <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">if</span> (!l2) <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> Hard </tag>
            
            <tag> 最小堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]215.Kth Largest Element in an Array(数组中的第K个最大元素)</title>
      <link href="/2019/09/22/Leetcode-215-Kth-Largest-Element-in-an-Array/"/>
      <url>/2019/09/22/Leetcode-215-Kth-Largest-Element-in-an-Array/</url>
      
        <content type="html"><![CDATA[<h1 id="215-Kth-Largest-Element-in-an-Array-数组中的第K个最大元素"><a href="#215-Kth-Largest-Element-in-an-Array-数组中的第K个最大元素" class="headerlink" title="#215.Kth Largest Element in an Array(数组中的第K个最大元素)"></a>#215.Kth Largest Element in an Array(数组中的第K个最大元素)</h1><ul><li>难度: 中等</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">在未排序的数组中找到第 k 个最大的元素。请注意，你需要找的是数组排序后的第 k 个最大的元素，而不是第 k 个不同的元素。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [3,2,1,5,6,4] 和 k = 2</span><br><span class="line">输出: 5</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [3,2,3,1,2,4,5,5,6] 和 k = 4</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line">你可以假设 k 总是有效的，且 1 ≤ k ≤ 数组的长度。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-STL法"><a href="#方法一-STL法" class="headerlink" title="方法一(STL法):"></a>方法一(STL法):</h3></li><li>思路: 给数组进行顺序排序，后取第k-1位置数即可得到第k大的数字<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">return</span> nums[nums.size() - k];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-priority-queue法"><a href="#方法二-priority-queue法" class="headerlink" title="方法二(priority_queue法):"></a>方法二(priority_queue法):</h3><ul><li>思路: 利用了 priority_queue 的自动排序的特性，思路同上<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="keyword">int</span>&gt; q(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            q.pop();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.top();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-分治算法"><a href="#方法三-分治算法" class="headerlink" title="方法三(分治算法):"></a>方法三(分治算法):</h3><ul><li>思路: 快速排序 Quick Sort 的思想,求出中枢点的位置，如果正好是 k-1，那么直接返回该位置上的数字;如果大于 k-1，说明要求的数字在左半部分，更新右边界，再求新的中枢点位置；反之则更新右半部分，求中枢点的位置.<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> quicksort(nums, k, <span class="number">0</span>, nums.size());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">quicksort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> k,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = partion(nums,begin,end);</span><br><span class="line">        <span class="keyword">if</span>(index==end-k) <span class="keyword">return</span> nums[index];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(index&gt;end-k) <span class="keyword">return</span> quicksort(nums,k-end+index,begin,index);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> quicksort(nums,k,index+<span class="number">1</span>,end);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partion</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums,<span class="keyword">int</span> begin,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> key = nums[begin];</span><br><span class="line">        <span class="keyword">int</span> i = begin,temp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=begin+<span class="number">1</span>;j&lt;end;++j)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j]&lt;key)&#123;</span><br><span class="line">                ++i;</span><br><span class="line">                temp = nums[i];</span><br><span class="line">                nums[i]=nums[j];</span><br><span class="line">                nums[j]=temp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[begin] = nums[i];</span><br><span class="line">        nums[i] = key;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p>简化后代码：<br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> pos = partition(nums, left, right);</span><br><span class="line">            <span class="keyword">if</span> (pos == k - <span class="number">1</span>) <span class="keyword">return</span> nums[pos];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt; k - <span class="number">1</span>) right = pos - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> left = pos + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pivot = nums[left], l = left + <span class="number">1</span>, r = right;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &lt; pivot &amp;&amp; nums[r] &gt; pivot) &#123;</span><br><span class="line">                swap(nums[l++], nums[r--]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (nums[l] &gt;= pivot) ++l;</span><br><span class="line">            <span class="keyword">if</span> (nums[r] &lt;= pivot) --r;</span><br><span class="line">        &#125;</span><br><span class="line">        swap(nums[left], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> 堆 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]53.Maximum Subarray(最大子序和)</title>
      <link href="/2019/09/11/Leetcode-53-Maximum-Subarray/"/>
      <url>/2019/09/11/Leetcode-53-Maximum-Subarray/</url>
      
        <content type="html"><![CDATA[<h1 id="53-Maximum-Subarray-最大子序和"><a href="#53-Maximum-Subarray-最大子序和" class="headerlink" title="#53.Maximum Subarray(最大子序和)"></a>#53.Maximum Subarray(最大子序和)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例:</span><br><span class="line"></span><br><span class="line">输入: [-2,1,-3,4,-1,2,1,-5,4],</span><br><span class="line">输出: 6</span><br><span class="line">解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一(动态规划):"></a>方法一(动态规划):</h3></li><li>思路: 求最大子数组之和，对数组进行遍历，当前最大连续子序列和定义为 sum，结果定义为 res ，sum 初值为 0 ，每遍历一个数字 num , 比较 sum+num 和 num , 较大者存入 sum (保留有增益的部分); 然后再比较 res 和 sum 中的较大者存入 res ，以此类推直到遍历完整个数组，可得到最大子数组的值存在 res 中<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** time : O(n)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res=INT_MIN,sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> num:nums)&#123;</span><br><span class="line">            sum=max(num,sum+num);</span><br><span class="line">            res=max(res,sum);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-分治"><a href="#方法二-分治" class="headerlink" title="方法二(分治) :"></a>方法二(分治) :</h3><ul><li>思路: 分治法的思想类似于二分搜索法，需要把数组一分为二，分别找出左边和右边的最大子数组之和，然后还要从中间开始向左右分别扫描，求出的最大值分别和左右两边得出的最大值相比较，取最大<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** time : O(nlogn)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums.empty()) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> helper(nums, <span class="number">0</span>, (<span class="keyword">int</span>)nums.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (left &gt;= right) <span class="keyword">return</span> nums[left];</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> lmax = helper(nums, left, mid - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> rmax = helper(nums, mid + <span class="number">1</span>, right);</span><br><span class="line">        <span class="keyword">int</span> mmax = nums[mid], t = mmax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid - <span class="number">1</span>; i &gt;= left; --i) &#123;</span><br><span class="line">            t += nums[i];</span><br><span class="line">            mmax = max(mmax, t);</span><br><span class="line">        &#125;</span><br><span class="line">        t = mmax;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = mid + <span class="number">1</span>; i &lt;= right; ++i) &#123;</span><br><span class="line">            t += nums[i];</span><br><span class="line">            mmax = max(mmax, t);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(mmax, max(lmax, rmax));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Easy </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 分治算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]121.Best Time to Buy and Sell Stock(买卖股票的最佳时机)</title>
      <link href="/2019/09/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2019/09/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<h1 id="121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机"><a href="#121-Best-Time-to-Buy-and-Sell-Stock-买卖股票的最佳时机" class="headerlink" title="#121.Best Time to Buy and Sell Stock(买卖股票的最佳时机)"></a>#121.Best Time to Buy and Sell Stock(买卖股票的最佳时机)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</span><br><span class="line"></span><br><span class="line">如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</span><br><span class="line"></span><br><span class="line">注意你不能在买入股票前卖出股票.</span><br></pre></td></tr></table></figure></li><li><p>样例: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: [7,1,5,3,6,4]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。</span><br><span class="line">     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</span><br><span class="line">     </span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: [7,6,4,3,1]</span><br><span class="line">输出: 0</span><br><span class="line">解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 遍历一次数组，用一个变量记录遍历过的最小值，每次计算当前值和其与该最小值间差值的较大者做利润。当遍历完成后当前利润即为所求。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, buy = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> price : prices) &#123;</span><br><span class="line">            buy = min(buy, price);</span><br><span class="line">            res = max(res, price - buy);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-动态规划"><a href="#方法二-动态规划" class="headerlink" title="方法二(动态规划):"></a>方法二(动态规划):</h3><ul><li>思路: 两点之差可以转换成求和问题(牛顿莱布尼茨公式)。所以最大连续子数组和问题可以使用动态规划求解， dp[i] 表示以 i 为结尾的最大连续子数组和，递推公式为<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i] = max(0,dp[i-1])</span><br></pre></td></tr></table></figure></li></ul><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> last = <span class="number">0</span>, profit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; (<span class="keyword">int</span>)prices.size() - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        last = max(<span class="number">0</span>, last + prices[i+<span class="number">1</span>] - prices[i]);</span><br><span class="line">        profit = max(profit, last);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> profit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Easy </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]70.Climbing Stairs Tree(爬楼梯)</title>
      <link href="/2019/09/10/Leetcode-70-Climbing-Stairs-Tree/"/>
      <url>/2019/09/10/Leetcode-70-Climbing-Stairs-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="70-Climbing-Stairs-Tree-爬楼梯"><a href="#70-Climbing-Stairs-Tree-爬楼梯" class="headerlink" title="#70.Climbing Stairs Tree(爬楼梯)"></a>#70.Climbing Stairs Tree(爬楼梯)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">假设你正在爬楼梯。需要 n 阶你才能到达楼顶。</span><br><span class="line"></span><br><span class="line">每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？</span><br><span class="line"></span><br><span class="line">注意：给定 n 是一个正整数。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入： 2</span><br><span class="line">输出： 2</span><br><span class="line">解释： 有两种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶</span><br><span class="line">2.  2 阶</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入： 3</span><br><span class="line">输出： 3</span><br><span class="line">解释： 有三种方法可以爬到楼顶。</span><br><span class="line">1.  1 阶 + 1 阶 + 1 阶</span><br><span class="line">2.  1 阶 + 2 阶</span><br><span class="line">3.  2 阶 + 1 阶</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-动态规划"><a href="#方法一-动态规划" class="headerlink" title="方法一(动态规划):"></a>方法一(动态规划):</h3></li><li>思路: 每次只能爬1或2步，爬到第n层的方法要么从第 n-1 层1步上来，要么是从 n-2 层2步上来，所以递推公式：dp[n] = dp[n-1] + dp[n-2] 。递归耗时较大，这里利用动态规划提高效率<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&lt;=<span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;dp(n);</span><br><span class="line">        dp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>]=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            dp[i]=dp[i<span class="number">-1</span>]+dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp.back();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><ul><li>思路: 用两个整型变量a和b来存储过程值，模拟了上面累加的过程<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> a = <span class="number">1</span>, b = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">            b += a;</span><br><span class="line">            a = b - a;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-记忆数组"><a href="#方法三-记忆数组" class="headerlink" title="方法三(记忆数组):"></a>方法三(记忆数组):</h3><ul><li>思路: 利用记忆数组保存计算过的结果，这样就不会存在重复计算了，大大提高了运行效率，其实递归加记忆数组跟迭代的 DP 形式基本是大同小异的<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; memory(n + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> helper(n, memory);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">helper</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; memory)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (memory[n] &gt; <span class="number">0</span>) <span class="keyword">return</span> memory[n];</span><br><span class="line">        <span class="keyword">return</span> memory[n] = helper(n - <span class="number">1</span>, memory) + helper(n - <span class="number">2</span>, memory);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法四-分治法"><a href="#方法四-分治法" class="headerlink" title="方法四(分治法):"></a>方法四(分治法):</h3><ul><li>思路: 待续……<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;       </span><br><span class="line">        <span class="keyword">return</span> climbStairs(n / <span class="number">2</span>) * climbStairs(n - n / <span class="number">2</span>) + climbStairs(n / <span class="number">2</span> - <span class="number">1</span>) * climbStairs(n - n / <span class="number">2</span> - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法五-公式法"><a href="#方法五-公式法" class="headerlink" title="方法五(公式法):"></a>方法五(公式法):</h3><ul><li>思路: <a href="https://zhuanlan.zhihu.com/p/26679684" target="_blank" rel="noopener">斐波那契数列公式推导思路</a><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> root5 = <span class="built_in">sqrt</span>(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">return</span> (<span class="number">1</span> / root5) * (<span class="built_in">pow</span>((<span class="number">1</span> + root5) / <span class="number">2</span>, n + <span class="number">1</span>) - <span class="built_in">pow</span>((<span class="number">1</span> - root5) / <span class="number">2</span>, n + <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]897.Increasing Order Search(递增顺序查找树)</title>
      <link href="/2019/09/07/Leetcode-897-Increasing-Order-Search/"/>
      <url>/2019/09/07/Leetcode-897-Increasing-Order-Search/</url>
      
        <content type="html"><![CDATA[<h1 id="897-Increasing-Order-Search-Tree-递增顺序查找树"><a href="#897-Increasing-Order-Search-Tree-递增顺序查找树" class="headerlink" title="#897.Increasing Order Search Tree(递增顺序查找树)"></a>#897.Increasing Order Search Tree(递增顺序查找树)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个树，按中序遍历重新排列树，使树中最左边的结点现在是树的根，并且每个结点没有左子结点，只有一个右子结点。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 ：</span><br><span class="line"></span><br><span class="line">输入：[5,3,6,2,4,null,8,1,null,null,null,7,9]</span><br><span class="line"></span><br><span class="line">       5</span><br><span class="line">      / \</span><br><span class="line">    3    6</span><br><span class="line">   / \    \</span><br><span class="line">  2   4    8</span><br><span class="line"> /        / \ </span><br><span class="line">1        7   9</span><br><span class="line"></span><br><span class="line">输出：[1,null,2,null,3,null,4,null,5,null,6,null,7,null,8,null,9]</span><br><span class="line"></span><br><span class="line"> 1</span><br><span class="line">  \</span><br><span class="line">   2</span><br><span class="line">    \</span><br><span class="line">     3</span><br><span class="line">      \</span><br><span class="line">       4</span><br><span class="line">        \</span><br><span class="line">         5</span><br><span class="line">          \</span><br><span class="line">           6</span><br><span class="line">            \</span><br><span class="line">             7</span><br><span class="line">              \</span><br><span class="line">               8</span><br><span class="line">                \</span><br><span class="line">                 9  </span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">提示：</span><br><span class="line">1. 给定树中的结点数介于 1 和 100 之间。</span><br><span class="line">2. 每个结点都有一个从 0 到 1000 范围内的唯一整数值。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-递归"><a href="#方法一-递归" class="headerlink" title="方法一(递归):"></a>方法一(递归):</h3></li><li><p>思路: 依题意可知，排序后的结果是一条向右下方延伸的直线，可以发现遍历顺序其实是 左-&gt;根-&gt;右，即中序遍历顺序，当 root 为空时，直接返回空; 当 root 存在左右子结点时，将左子结点上移变为根结点，将之前的根结点连到新根节点的右子结点上，而之前的右子结点不改变。所以对于每个结点，我们需要知道其父结点的位置，那么就在递归函数的参数中传入一个 pre 结点，再对左右子结点调用递归函数时，都将其下一个要连接的结点传入，这个 pre 结点可能是当前结点或者当前结点的父结点。</p><p>  在递归函数中，首先判空，若当前结点为空，直接返回 pre 结点，说明已遍历到叶结点。那么 pre 就是这个叶结点了。由于是中序遍历，所以要先对左子结点调用递归函数，将返回值保存到一个新的结点 res 中，表示的意义是此时 node 的左子树已经全部捋直了，而且根结点就是 res，而且 node 结点本身也被连到了捋直后的左子树下，即此时左子结点和根结点已经完成了交换位子，当然要断开原来的连接，所以将 node-&gt;left 赋值为 nullptr。然后再对 node 的右子结点调用递归函数，注意此时的 pre 不能传入 node 本身，而是要传 node 结点的 pre 结点，这是因为右子结点后面要连接的是 node 的父结点</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> helper(root, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* node, TreeNode* pre)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span> pre;</span><br><span class="line">        TreeNode* res = helper(node-&gt;left, node);</span><br><span class="line">        node-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">        node-&gt;right = helper(node-&gt;right, pre);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-深度优先搜索"><a href="#方法二-深度优先搜索" class="headerlink" title="方法二(深度优先搜索):"></a>方法二(深度优先搜索):</h3><ul><li>思路: 采用中序遍历的迭代形式，使用栈来辅助。由于根结点可能会产生变化，所以我们需要一个 res 结点，还需要一个移动的 pre 结点。在 while 循环中，先找到最左结点，把路径上的所有结点都压入栈，然后取出栈顶元素，将其连到 pre 的右子结点上，并将 pre 更新为其右子结点，然后断开栈顶元素的左子结点连接，并将其移动到右子结点上，并继续循环，最终返回 res-&gt;right 右子结点即可。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">increasingBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        TreeNode *res = <span class="keyword">new</span> TreeNode(<span class="number">-1</span>),*pre = res;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">while</span>(root||!st.empty())&#123;</span><br><span class="line">            <span class="keyword">while</span>(root)&#123;</span><br><span class="line">                st.push(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = st.top();</span><br><span class="line">            st.pop();</span><br><span class="line">            pre-&gt;right = root;</span><br><span class="line">            pre = pre-&gt;right;</span><br><span class="line">            root-&gt;left = <span class="literal">nullptr</span>;</span><br><span class="line">            root = root-&gt;right;            </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> res-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]559.Maximum Depth of N-ary(N叉树的最大深度)</title>
      <link href="/2019/09/06/Leetcode-559-Maximum-Depth-of-N-ary/"/>
      <url>/2019/09/06/Leetcode-559-Maximum-Depth-of-N-ary/</url>
      
        <content type="html"><![CDATA[<h1 id="559-Maximum-Depth-of-N-ary-Tree-N叉树的最大深度"><a href="#559-Maximum-Depth-of-N-ary-Tree-N叉树的最大深度" class="headerlink" title="#559.Maximum Depth of N-ary Tree(N叉树的最大深度)"></a>#559.Maximum Depth of N-ary Tree(N叉树的最大深度)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个 N 叉树，找到其最大深度。</span><br><span class="line"></span><br><span class="line">最大深度是指从根节点到最远叶子节点的最长路径上的节点总数。</span><br><span class="line"></span><br><span class="line">例如，给定一个 3叉树 :</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定一个 3叉树 :</span><br></pre></td></tr></table></figure></li></ul><p><img alt="image" data-src="https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/10/12/narytreeexample.png" class="lozad"><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">我们应返回其最大深度，3。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">树的深度不会超过 1000。</span><br><span class="line">树的节点总不会超过 5000。</span><br></pre></td></tr></table></figure></p><ul><li>解答：<h3 id="方法一-深度优先搜索"><a href="#方法一-深度优先搜索" class="headerlink" title="方法一(深度优先搜索):"></a>方法一(深度优先搜索):</h3></li><li>思路: 主函数中递归，首先判空，否则遍历子结点数组，然后对每个子结点，调用递归函数的返回值加1后跟res相比，取较大值更新结果res<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(Node* child : root-&gt;children)&#123;</span><br><span class="line">            res = max(res,maxDepth(child)+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-广度优先搜索"><a href="#方法二-广度优先搜索" class="headerlink" title="方法二(广度优先搜索):"></a>方法二(广度优先搜索):</h3><ul><li>思路: 用迭代的形式, 借助队列queue, BFS的经典写法<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    vector&lt;Node*&gt; children;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node() &#123;&#125;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    Node(int _val, vector&lt;Node*&gt; _children) &#123;</span></span><br><span class="line"><span class="comment">        val = _val;</span></span><br><span class="line"><span class="comment">        children = _children;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;Node*&gt;q&#123;&#123;root&#125;&#125;; <span class="comment">//相当于q.push(root);</span></span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = q.size(); i &gt; <span class="number">0</span>; --i)&#123;</span><br><span class="line">                <span class="keyword">auto</span> node = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> child: node-&gt;children)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(child) q.push(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-递归"><a href="#方法三-递归" class="headerlink" title="方法三(递归):"></a>方法三(递归):</h3><ul><li>说明: 常见的递归解法，需要有一个当前深度，然后带一个全局变量 res 进去。在递归函数中，如果 node 为空，直接返回。若子结点数组为空，那么结果 res 和 cur 比较取较大值。否则就遍历子结点数组，对每个子结点调用递归函数，这里的 cur 要自增 1。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        helper(root, <span class="number">1</span>, res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">helper</span><span class="params">(Node* node, <span class="keyword">int</span> cur, <span class="keyword">int</span>&amp; res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!node) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (node-&gt;children.empty()) res = max(res, cur);</span><br><span class="line">        <span class="keyword">for</span> (Node* child : node-&gt;children) &#123;</span><br><span class="line">            helper(child, cur + <span class="number">1</span>, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]104.Maximum Depth of Binary Tree(二叉树的最大深度)</title>
      <link href="/2019/09/06/Leetcode-104-Maximum-Depth-of-Binary-Tree/"/>
      <url>/2019/09/06/Leetcode-104-Maximum-Depth-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<h1 id="104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度"><a href="#104-Maximum-Depth-of-Binary-Tree-二叉树的最大深度" class="headerlink" title="#104.Maximum Depth of Binary Tree(二叉树的最大深度)"></a>#104.Maximum Depth of Binary Tree(二叉树的最大深度)</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉树，找出其最大深度。</span><br><span class="line"></span><br><span class="line">二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</span><br><span class="line"></span><br><span class="line">说明: 叶子节点是指没有子节点的节点。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例：</span><br><span class="line">给定二叉树 [3,9,20,null,null,15,7]，</span><br><span class="line">    3</span><br><span class="line">   / \</span><br><span class="line">  9  20</span><br><span class="line">    /  \</span><br><span class="line">   15   7</span><br><span class="line">返回它的最大深度 3 。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-深度优先搜索"><a href="#方法一-深度优先搜索" class="headerlink" title="方法一(深度优先搜索):"></a>方法一(深度优先搜索):</h3></li><li>思路: 求二叉树的最大深度问题,利用深度优先搜索(Depth First Search)，递归解决<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+max(maxDepth(root-&gt;left),maxDepth(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-层序遍历"><a href="#方法二-层序遍历" class="headerlink" title="方法二(层序遍历):"></a>方法二(层序遍历):</h3><ul><li>思路: 使用层序遍历二叉树，然后计数总层数，即为二叉树的最大深度<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!q.empty())&#123;</span><br><span class="line">            ++res;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=q.size();i&gt;<span class="number">0</span>;--i)&#123;</span><br><span class="line">                TreeNode *t = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 深度优先搜索 </tag>
            
            <tag> 广度优先搜索 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]题目类型分类整理</title>
      <link href="/2019/09/06/Leetcode-%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/"/>
      <url>/2019/09/06/Leetcode-%E9%A2%98%E7%9B%AE%E7%B1%BB%E5%9E%8B%E5%88%86%E7%B1%BB%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h2 id="DFS-深度优先搜索"><a href="#DFS-深度优先搜索" class="headerlink" title="DFS(深度优先搜索)"></a>DFS(深度优先搜索)</h2><div class="table-container"><table><thead><tr><th>题号</th><th>难度</th><th>描述</th><th>地址</th></tr></thead><tbody><tr><td>104</td><td>简单</td><td>深度优先搜索求二叉树的最大深度</td><td><a href="https://fjken.top/2019/09/06/Leetcode-104-Maximum-Depth-of-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" target="_blank" rel="noopener">address</a></td></tr><tr><td>559</td><td>简单</td><td>深度优先搜索求二叉树的最大深度</td><td><a href="https://fjken.top/2019/09/06/Leetcode-559-Maximum-Depth-of-N-ary/" target="_blank" rel="noopener">address</a></td></tr><tr><td>879</td><td>简单</td><td>深度优先搜索求二叉树的最大深度</td><td><a href="https://fjken.top/2019/09/07/Leetcode-897-Increasing-Order-Search/" target="_blank" rel="noopener">address</a></td></tr></tbody></table></div><h2 id="BFS-广度优先搜索"><a href="#BFS-广度优先搜索" class="headerlink" title="BFS(广度优先搜索)"></a>BFS(广度优先搜索)</h2><div class="table-container"><table><thead><tr><th>题号</th><th>难度</th><th>描述</th><th>地址</th></tr></thead><tbody><tr><td>104</td><td>简单</td><td>树的层序遍历求层数(亦即广度优先搜索)，即得二叉树的最大深度</td><td><a href="https://fjken.top/2019/09/06/Leetcode-104-Maximum-Depth-of-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" target="_blank" rel="noopener">address</a></td></tr><tr><td>559</td><td>简单</td><td>广度优先搜索求二叉树的最大深度</td><td><a href="https://fjken.top/2019/09/06/Leetcode-559-Maximum-Depth-of-N-ary/" target="_blank" rel="noopener">address</a></td></tr></tbody></table></div><h2 id="Tree-树"><a href="#Tree-树" class="headerlink" title="Tree(树)"></a>Tree(树)</h2><div class="table-container"><table><thead><tr><th>题号</th><th>难度</th><th>描述</th><th>地址</th></tr></thead><tbody><tr><td>104</td><td>简单</td><td>树的层序遍历求层数(亦即广度优先搜索)，即得二叉树的最大深度</td><td><a href="https://fjken.top/2019/09/06/Leetcode-104-Maximum-Depth-of-Binary-Tree-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E5%A4%A7%E6%B7%B1%E5%BA%A6/" target="_blank" rel="noopener">address</a></td></tr></tbody></table></div><h2 id="Dynamic-Programming-动态规划"><a href="#Dynamic-Programming-动态规划" class="headerlink" title="Dynamic Programming(动态规划)"></a>Dynamic Programming(动态规划)</h2><div class="table-container"><table><thead><tr><th>题号</th><th>难度</th><th>描述</th><th>地址</th></tr></thead><tbody><tr><td>64</td><td>中等</td><td>动态规划</td><td><a href="https://fjken.top/2019/10/07/Leetcode-64-Minimum-Path-Sum/" target="_blank" rel="noopener">address</a></td></tr><tr><td>70</td><td>简单</td><td>动态规划分解成若干小问题</td><td><a href="https://fjken.top/2019/09/10/Leetcode-70-Climbing-Stairs-Tree/" target="_blank" rel="noopener">address</a></td></tr><tr><td>53</td><td>简单</td><td>动态规划</td><td><a href="https://fjken.top/2019/09/11/Leetcode-53-Maximum-Subarray/" target="_blank" rel="noopener">address</a></td></tr><tr><td>121</td><td>简单</td><td>动态规划</td><td><a href="https://fjken.top/2019/09/10/Leetcode-121-Best-Time-to-Buy-and-Sell-Stock/" target="_blank" rel="noopener">address</a></td></tr><tr><td>198</td><td>简单</td><td>动态规划</td><td><a href="https://fjken.top/2019/10/07/Leetcode-198-House-Robber/" target="_blank" rel="noopener">address</a></td></tr><tr><td>746</td><td>简单</td><td>动态规划</td><td><a href="https://fjken.top/2019/10/07/Leetcode-746-Min-Cost-Climbing-Stairs/" target="_blank" rel="noopener">address</a></td></tr></tbody></table></div><h2 id="Divide-And-Conquer-分治算法"><a href="#Divide-And-Conquer-分治算法" class="headerlink" title="Divide And Conquer(分治算法)"></a>Divide And Conquer(分治算法)</h2><div class="table-container"><table><thead><tr><th>题号</th><th>难度</th><th>描述</th><th>地址</th></tr></thead><tbody><tr><td>53</td><td>简单</td><td>分治算法</td><td><a href="https://fjken.top/2019/09/11/Leetcode-53-Maximum-Subarray/" target="_blank" rel="noopener">address</a></td></tr><tr><td>215</td><td>中等</td><td>利用分治算法结合快排思路求得第k大</td><td><a href="https://fjken.top/2019/09/22/Leetcode-215-Kth-Largest-Element-in-an-Array/" target="_blank" rel="noopener">address</a></td></tr><tr><td>23</td><td>困难</td><td>分治算法</td><td><a href="https://fjken.top/2019/09/25/Leetcode-23-Merge-k-Sorted-Lists/" target="_blank" rel="noopener">address</a></td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]5.Longest Palindromic Substring(最长回文子串)</title>
      <link href="/2019/09/01/Leetcode-5-Longest-Palindromic-Substring/"/>
      <url>/2019/09/01/Leetcode-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="#5.Longest Palindromic Substring"></a>#5.Longest Palindromic Substring</h1><ul><li>难度: 中等</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 回文串的长度可奇可偶，对于奇数形式，以遍历到的位置为中心，向两边进行扩散，对于偶数情况，我们就把当前位置和下一个位置当作偶数行回文的最中间两个字符，然后向两边进行搜索。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), maxLen = <span class="number">0</span>, start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">            searchPalindrome(s, i, i, start, maxLen);</span><br><span class="line">            searchPalindrome(s, i, i + <span class="number">1</span>, start, maxLen);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start, maxLen);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">searchPalindrome</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> left, <span class="keyword">int</span> right, <span class="keyword">int</span>&amp; start, <span class="keyword">int</span>&amp; maxLen)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (left &gt;= <span class="number">0</span> &amp;&amp; right &lt; s.size() &amp;&amp; s[left] == s[right]) &#123;</span><br><span class="line">            --left; ++right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (maxLen &lt; right - left - <span class="number">1</span>) &#123;</span><br><span class="line">            start = left + <span class="number">1</span>;</span><br><span class="line">            maxLen = right - left - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二:"></a>方法二:</h3><ul><li>思路: 定义两个变量 start 和 maxl，分别表示最长回文子串的起点跟长度，在遍历s中，首先判断剩余的字符数是否小于等于 maxl 的一半，若从当前到末尾子串长度小于 maxl/2 ，就无需再继续考虑，直接在当前位置 break 。用两个变量 left 和 right 分别指向当前位置，然后是向右遍历跳过重复项，然后再向两边扩散。如此可以同时处理奇、偶数的回文串，之后的操作就是更新 maxl 和 start 了，跟上面的操作一样。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.size() &lt; <span class="number">2</span>) <span class="keyword">return</span> s;</span><br><span class="line">        <span class="keyword">int</span> maxl=<span class="number">0</span>,start=<span class="number">0</span>,n=s.size();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;)&#123;</span><br><span class="line">            <span class="keyword">if</span> (n - i &lt;= maxl/<span class="number">2</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> left=i,right=i;</span><br><span class="line">            <span class="keyword">while</span>(right &lt; n<span class="number">-1</span> &amp;&amp; s[right]==s[right+<span class="number">1</span>]) ++right;</span><br><span class="line">            i=right+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left &gt; <span class="number">0</span> &amp;&amp; right &lt; n<span class="number">-1</span> &amp;&amp; s[left<span class="number">-1</span>]==s[right+<span class="number">1</span>])&#123;</span><br><span class="line">                --left;</span><br><span class="line">                ++right;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(maxl&lt;right-left+<span class="number">1</span>)&#123;</span><br><span class="line">                start=left;</span><br><span class="line">                maxl=right-left+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(start,maxl);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-动态规划"><a href="#方法三-动态规划" class="headerlink" title="方法三(动态规划):"></a>方法三(动态规划):</h3><ul><li><p>思路: 维护一个二维数组 dp，其中 dp[i][j] 表示字符串区间 [i, j] 是否为回文串</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dp[i,j] = 1                                 if i == j</span><br><span class="line"></span><br><span class="line">        = s[i] == s[j]                      if j = i + 1</span><br><span class="line"></span><br><span class="line">        = s[i] == s[j] &amp;&amp; dp[i + 1][j - 1]  if j &gt; i + 1</span><br></pre></td></tr></table></figure></li><li><p>说明: 有个有趣的现象就是如果把代码中的二维数组由 int 改为 vector<vector> 后，就会超时，这说明 int 型的二维数组访问执行速度完爆 std 的 vector 啊，所以以后尽可能的还是用最原始的数据类型吧。</vector></p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.empty()) <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> n = s.size(), dp[n][n] = &#123;<span class="number">0</span>&#125;, left = <span class="number">0</span>, len = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                dp[j][i] = (s[i] == s[j] &amp;&amp; (i - j &lt; <span class="number">2</span> || dp[j + <span class="number">1</span>][i - <span class="number">1</span>]));</span><br><span class="line">                <span class="keyword">if</span> (dp[j][i] &amp;&amp; len &lt; i - j + <span class="number">1</span>) &#123;</span><br><span class="line">                    len = i - j + <span class="number">1</span>;</span><br><span class="line">                    left = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr(left, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法四-马拉车算法"><a href="#方法四-马拉车算法" class="headerlink" title="方法四(马拉车算法):"></a>方法四(马拉车算法):</h3><ul><li>思路: <figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">longestPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> t =<span class="string">"$#"</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            t += s[i];</span><br><span class="line">            t += <span class="string">'#'</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> p[t.size()] = &#123;<span class="number">0</span>&#125;, id = <span class="number">0</span>, mx = <span class="number">0</span>, resId = <span class="number">0</span>, resMx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; t.size(); ++i) &#123;</span><br><span class="line">            p[i] = mx &gt; i ? min(p[<span class="number">2</span> * id - i], mx - i) : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (t[i + p[i]] == t[i - p[i]]) ++p[i];</span><br><span class="line">            <span class="keyword">if</span> (mx &lt; i + p[i]) &#123;</span><br><span class="line">                mx = i + p[i];</span><br><span class="line">                id = i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resMx &lt; p[i]) &#123;</span><br><span class="line">                resMx = p[i];</span><br><span class="line">                resId = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.substr((resId - resMx) / <span class="number">2</span>, resMx - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 动态规划 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)</title>
      <link href="/2019/09/01/Leetcode-4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2019/09/01/Leetcode-4-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="#4.Median of Two Sorted Arrays"></a>#4.Median of Two Sorted Arrays</h1><ul><li>难度: 困难</li><li><p>题目描述: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</span><br><span class="line"></span><br><span class="line">请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</span><br><span class="line"></span><br><span class="line">你可以假设 nums1 和 nums2 不会同时为空。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-二分法"><a href="#方法一-二分法" class="headerlink" title="方法一(二分法):"></a>方法一(二分法):</h3></li><li><p>思路: 目标是求得两个数组的中位数且时间复杂度为 O(log(m + n)) 。假设两个数组的长度分别为 m 和 n，则 m+n 的奇偶未定，若 m+n 为奇数，则中位数就为最中间那个数，若为偶数，则中位数就为最中间两个数的平均值。这里运用简化方法，分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这样就不用再分奇偶分开讨论。</p><p>  定义一个函数来寻找有序数组中的第K个元素，为了避免拷贝产生新的数组从而增加时间复杂度，使用两个变量i和j分别来标记数组 nums1 和 nums2 的起始位置。要找到数组当中的第 K 个元素，需要借助于二分法，对 K 进行二分寻找第 K/2 个元素，因为各个数组的数组长度不定，所以需要对是否存在第 K/2 个元素进行讨论(必定至少会有一个数组是存在第 K/2 个数字的)。若存在就取出，否则就赋值上一个整型最大值。若数组中不存在 第 K/2 个数，那么就淘汰掉另一个数组中的前 K/2个数即可。因为寻找的是混合数组当中的第 K 个数，当有一个数组长度都达不到 K/2 时，另一个数组当中的前 K/2 个元素必不会被取到。</p><p>  接下来就是二分法的思想，比较两个数组的第 K/2 小的数字 midval1 和 midval2 的大小，若 midval1 &lt; midval2 ，那么说明要找的数肯定不在 nums1 中的前 K/2 个数字，所以可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K自减 K/2，调用递归。反之若 midval1 &gt; midval2，就淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减 K/2，调用递归即可。</p></li><li><p>说明: 特殊讨论 (1) 当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组，那么实际上就变成了在另一个数组中找数字。(2) 若 K=1 ，则只需比较 nums1 和 nums2 的起始位置i和j上的数字即可。</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(),n = nums2.size();</span><br><span class="line">        <span class="keyword">int</span> left = (m+n+<span class="number">1</span>)/<span class="number">2</span>, right = (m+n+<span class="number">2</span>)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,left)+findKth(nums1,<span class="number">0</span>,nums2,<span class="number">0</span>,right))/<span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="keyword">int</span> i, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> j, <span class="keyword">int</span> k)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= nums1.size()) <span class="keyword">return</span> nums2[j + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (j &gt;= nums2.size()) <span class="keyword">return</span> nums1[i + k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k==<span class="number">1</span>) <span class="keyword">return</span> min(nums1[i],nums2[j]);</span><br><span class="line">        <span class="keyword">int</span> mid_val1 = ((i + k/<span class="number">2</span> - <span class="number">1</span>) &lt; nums1.size()) ? nums1[i + k/<span class="number">2</span> - <span class="number">1</span>]:INT_MAX;</span><br><span class="line">        <span class="keyword">int</span> mid_val2 = ((j + k/<span class="number">2</span> - <span class="number">1</span>) &lt; nums2.size()) ? nums2[j + k/<span class="number">2</span> - <span class="number">1</span>]:INT_MAX;</span><br><span class="line">        <span class="keyword">if</span>(mid_val1 &lt; mid_val2) <span class="keyword">return</span> findKth(nums1 , i + k/<span class="number">2</span> , nums2 , j ,k - k/<span class="number">2</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> findKth(nums1 , i , nums2 , j + k/<span class="number">2</span> , k - k/<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二 :"></a>方法二 :</h3><ul><li>思路: 上面法一使用原数组，同时用了两个变量来分别标记当前的起始位置。法二则直接生成新的数组，这样就不要用起始位置变量了，不过拷贝数组的操作可能会增加时间复杂度，也许会超出限制，不过就算当个思路拓展也是极好的。首先我们要判断数组是否为空，为空的话，直接在另一个数组找第K个即可。还有一种情况是当 K = 1 时，表示我们要找第一个元素，只要比较两个数组的第一个元素，返回较小的那个即可。这里我们分别取出两个数组的第 K/2 个数字的位置坐标i和j，为了避免数组没有第 K/2 个数组的情况，我们每次都和数组长度做比较，取出较小值。这里跟上面的解法有些许不同，上面解法我们直接取出的是值，而这里我们取出的是位置坐标，但是思想都是很类似的。不同在于，上面解法中我们每次固定淘汰 K/2 个数字，而这里我们由于取出了合法的i和j，所以我们每次淘汰i或j个。也可以让 j = k-i，这样也是对的，可能还更好一些，收敛速度可能会更快一些。</li><li>说明:<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">return</span> (findKth(nums1, nums2, (m + n + <span class="number">1</span>) / <span class="number">2</span>) + findKth(nums1, nums2, (m + n + <span class="number">2</span>) / <span class="number">2</span>)) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKth</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums2, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (nums1.empty()) <span class="keyword">return</span> nums2[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (nums2.empty()) <span class="keyword">return</span> nums1[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">1</span>) <span class="keyword">return</span> min(nums1[<span class="number">0</span>], nums2[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">int</span> i = min((<span class="keyword">int</span>)nums1.size(), k / <span class="number">2</span>), j = min((<span class="keyword">int</span>)nums2.size(), k / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (nums1[i - <span class="number">1</span>] &gt; nums2[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums2.begin() + j, nums2.end()), k - j);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> findKth(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums1.begin() + i, nums1.end()), nums2, k - i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-迭代形式的二分搜索法"><a href="#方法三-迭代形式的二分搜索法" class="headerlink" title="方法三(迭代形式的二分搜索法):"></a>方法三(迭代形式的二分搜索法):</h3><ul><li>思路: 此题还能用迭代形式的二分搜索法来解，是一种相当巧妙的应用，讲解在<a href="https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/2" target="_blank" rel="noopener">这个帖子</a>中写的十分清楚<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">findMedianSortedArrays</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums1, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = nums1.size(), n = nums2.size();</span><br><span class="line">        <span class="keyword">if</span> (m &lt; n) <span class="keyword">return</span> findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> ((<span class="keyword">double</span>)nums1[(m - <span class="number">1</span>) / <span class="number">2</span>] + (<span class="keyword">double</span>)nums1[m / <span class="number">2</span>]) / <span class="number">2.0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = n * <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid2 = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> mid1 = m + n - mid2;</span><br><span class="line">            <span class="keyword">double</span> L1 = mid1 == <span class="number">0</span> ? INT_MIN : nums1[(mid1 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> L2 = mid2 == <span class="number">0</span> ? INT_MIN : nums2[(mid2 - <span class="number">1</span>) / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> R1 = mid1 == m * <span class="number">2</span> ? INT_MAX : nums1[mid1 / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">double</span> R2 = mid2 == n * <span class="number">2</span> ? INT_MAX : nums2[mid2 / <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">if</span> (L1 &gt; R2) left = mid2 + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (L2 &gt; R1) right = mid2 - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> (max(L1, L2) + min(R1, R2)) / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]290.Word Pattern(单词规律)</title>
      <link href="/2019/08/31/Leetcode-290-Word-Pattern/"/>
      <url>/2019/08/31/Leetcode-290-Word-Pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="#290. Word Pattern"></a>#290. Word Pattern</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</span><br><span class="line"></span><br><span class="line">这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-两个HashMap-法"><a href="#方法一-两个HashMap-法" class="headerlink" title="方法一( 两个HashMap 法):"></a>方法一( 两个HashMap 法):</h3></li><li>思路: 用两个 HashMap 来完成，分别将字符和单词都映射到当前的位置加1，注意这里需要加1就是为了避免默认映射值0，因为 C++ 中的 HashMap 的机制是若访问一个不存在的 key 值，会默认建立一个映射值为0的映射。那么我们在遇到新字符和单词时，首先看 i 是否已经是 n 了，若相等了，说明此时 pattern 中的字符已经用完了，而 str 中还有多余的单词，这样是无法建立一对一映射的，直接返回 false。还有当两个 HashMap 的映射值不相同时也返回 false，否则我们同时建立单词和 pattern 字符和当前位置加1之间的映射，循环推出后还是要检测 i 是否和 n 相等;</li><li>说明: 注意字符串的操作，利用 istringstream in(str) 将原本的字符串按以空格为间隔的串流输入(需注意加上头文件<sstream>)<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt;pat_map;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;str_map;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="built_in">string</span> word;in&gt;&gt;word;++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i==pattern.size()||pat_map[pattern[i]]!=str_map[word]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            pat_map[pattern[i]]=i+<span class="number">1</span>;</span><br><span class="line">            str_map[word]=i+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i==pattern.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></sstream></li></ul><h3 id="方法二-HashMap-法"><a href="#方法二-HashMap-法" class="headerlink" title="方法二( HashMap 法):"></a>方法二( HashMap 法):</h3><ul><li>思路: 求单词字符串中单词出现的规律是否符合模式字符串中的规律。那么首先想到就是用 HashMap 来做，建立模式字符串中每个字符和单词字符串每个单词之间的映射，而且这种映射必须是一对一关系的，不能 ‘a’ 和 ‘b’ 同时对应 ‘dog’，也不能 ‘a’ 同时对应到 ‘dog’ 和 ‘cat’，所以我们在碰到一个新字符时，首先检查其是否在 HashMap 中出现，若出现，其映射的单词若不是此时对应的单词，则返回 false。如果没有在 HashMap 中出现，我们还要遍历一遍 HashMap，看新遇到的单词是否已经是其中的映射，若已经有其他映射，直接返回 false，如果没有，再跟新遇到的字符建立映射。最后循环退出后，要检查此时的 i 是否和 n 相同，这是检查一对一映射的最后一步，因为当 str 中的单词处理完了之后，pattern 中就不能有多余的字符了<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">wordPattern</span><span class="params">(<span class="built_in">string</span> pattern, <span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">string</span>&gt; m;</span><br><span class="line">        <span class="function"><span class="built_in">istringstream</span> <span class="title">in</span><span class="params">(str)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, n = pattern.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">string</span> word; in &gt;&gt; word; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= n) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span> (m.count(pattern[i])) &#123;</span><br><span class="line">                <span class="keyword">if</span> (m[pattern[i]] != word) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">auto</span> a : m) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (a.second == word) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                m[pattern[i]] = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]205.Isomorphic Strings(同构字符串)</title>
      <link href="/2019/08/31/Leetcode-205-Isomorphic-Strings/"/>
      <url>/2019/08/31/Leetcode-205-Isomorphic-Strings/</url>
      
        <content type="html"><![CDATA[<h1 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="#205. Isomorphic Strings"></a>#205. Isomorphic Strings</h1><ul><li>难度：简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串 s 和 t，判断它们是否是同构的。</span><br><span class="line"></span><br><span class="line">如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</span><br><span class="line"></span><br><span class="line">所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 s 和 t 具有相同的长度。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路：<br>根据一对一映射的特点，我们需要用两个哈希表分别来记录原字符串和目标字符串中字符出现情况，由于ASCII码只有256个字符，所以我们可以用一个256大小的数组来代替哈希表，并初始化为0，我们遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找其值，若不相等，则返回false，若相等，将其值更新为i + 1，因为默认的值是0，所以我们更新值为i + 1，这样当 i=0 时，则映射为1，如果不加1的话，那么就无法区分是否更新了<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isIsomorphic</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m1[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;, m2[<span class="number">256</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (m1[s[i]] != m2[t[i]]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            m1[s[i]] = i + <span class="number">1</span>;</span><br><span class="line">            m2[t[i]] = i + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]3.Longest Substring Without Repeating Characters(无重复字符的最长子串)</title>
      <link href="/2019/08/30/Leetcode-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2019/08/30/Leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="#3.Longest Substring Without Repeating Characters"></a>#3.Longest Substring Without Repeating Characters</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-HashMap-法"><a href="#方法一-HashMap-法" class="headerlink" title="方法一( HashMap 法):"></a>方法一( HashMap 法):</h3></li><li>思路：这道题字符出现的位置很重要，所以可以使用 HashMap 来建立字符和其出现位置之间的映射。实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，需要一个变量 left 来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界 left 一位一位向右遍历查找，由于 HashMap 已经保存了该重复字符最后出现的位置，所以直接移动 left 指针就可以了( 如果其映射值大于 left 的话，那么更新 left 为当前映射值。然后映射值更新为当前坐标 i ，这样保证了 left 始终为当前边界的前一个位置)。维护一个结果 res，每次用出现过的窗口大小来更新结果 res(计算窗口长度的时候，直接用 i-left 即可，用来更新结果 res )，就可以得到最终结果啦。</li><li>说明: 注意这里是子串，不是子序列，所以必须是连续的。res 用来记录最长无重复子串的长度，left 指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是 -1 。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; links;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;s.size();++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(links.count(s[i])&amp;&amp;links[s[i]]&gt;left)&#123;</span><br><span class="line">                left = links[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            links[s[i]]=i;</span><br><span class="line">            res = max(res,i-left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-数组法"><a href="#方法二-数组法" class="headerlink" title="方法二(数组法):"></a>方法二(数组法):</h3><ul><li>思路: 该方法为上面解法的精简模式，这里建立一个 256 位大小的整型数组来代替 HashMap，这样做的原因是 ASCII 表共能表示 256 个字符，但是由于键盘只能表示 128 个字符，所以用 128 也行，然后全部初始化为 -1，这样的好处是不用像之前的 HashMap 一样要查找当前字符是否存在映射对了，对于每一个遍历到的字符，直接用其在数组中的值来更新 left，因为默认是 -1，而 left 初始化也是 -1，所以并不会产生错误，这样就省了 if 判断的步骤，其余思路都一样<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m(<span class="number">128</span>, <span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            left = max(left, m[s[i]]);</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = max(res, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-HashSet法"><a href="#方法二-HashSet法" class="headerlink" title="方法二(HashSet法):"></a>方法二(HashSet法):</h3><ul><li>思路: 核心算法和上面的很类似，把出现过的字符都放入 HashSet 中，遇到 HashSet 中没有的字符就加入 HashSet 中并更新结果 res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="number">0</span>, left = <span class="number">0</span>, i = <span class="number">0</span>, n = s.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">char</span>&gt; t;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!t.count(s[i])) &#123;</span><br><span class="line">                t.insert(s[i++]);</span><br><span class="line">                res = max(res, (<span class="keyword">int</span>)t.size());</span><br><span class="line">            &#125;  <span class="keyword">else</span> &#123;</span><br><span class="line">                t.erase(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> Medium </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]43.Multiply Strings(字符串相乘)</title>
      <link href="/2019/08/28/Leetcode-43-Multiply-Strings/"/>
      <url>/2019/08/28/Leetcode-43-Multiply-Strings/</url>
      
        <content type="html"><![CDATA[<ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 基本思路即两数按位相乘后错位相加，这里罗列注意要点: 若 num1 长度为m，num2 长度为n，则 num1 x num2 的长度为 m+n ; num1 和 num2 中任意位置的两个数字相乘，得到的两位数在最终结果中的位置是确定的，比如 num1 中位置为i的数字乘以 num2 中位置为j的数字，那么得到的两位数字的位置为 i+j 和 i+j+1</li><li>说明: 从个位上开始相乘，所以从 num1 和 num2 字符串的尾部开始往前遍历，分别提取出对应位置上的字符，将其转为整型后相乘。然后确定相乘后的两位数所在的位置 p1 和 p2，由于 p2 相较于 p1 是低位，所以我们将得到的两位数 temp 先加到 p2 位置上去，这样可能会导致 p2 位上的数字大于9，所以我们将十位上的数字要加到高位 p1 上去，只将余数留在 p2位置，这样每个位上的数字都变成一位。然后要做的是从高位开始，将数字存入结果res中，记住 leading zeros 要跳过，最后处理下 corner case，即若结果 res 为空，则返回 “0”，否则返回结果 res<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">multiply</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.size(), n = num2.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; values(m+n);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i&gt;=<span class="number">0</span>; --i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>; j&gt;=<span class="number">0</span>; --j)&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = (num1[i]-<span class="string">'0'</span>)*(num2[j]-<span class="string">'0'</span>);</span><br><span class="line">                <span class="keyword">int</span> p1 = i+j,p2 = i+j+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> sum = values[p2] + temp;</span><br><span class="line">                values[p1] += sum / <span class="number">10</span>;</span><br><span class="line">                values[p2] = sum % <span class="number">10</span>;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> val:values)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!res.empty() || val!=<span class="number">0</span>) res.push_back(val + <span class="string">'0'</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.empty()? <span class="string">"0"</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数学 </tag>
            
            <tag> Medium </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]415.Add Strings(字符串相加)</title>
      <link href="/2019/08/28/Leetcode-415-Add-Strings/"/>
      <url>/2019/08/28/Leetcode-415-Add-Strings/</url>
      
        <content type="html"><![CDATA[<ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">num1 和num2 的长度都小于 5100.</span><br><span class="line">num1 和num2 都只包含数字 0-9.</span><br><span class="line">num1 和num2 都不包含任何前导零。</span><br><span class="line">你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路：亦即按位相加的思路，注意字符串的处理<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">addStrings</span><span class="params">(<span class="built_in">string</span> num1, <span class="built_in">string</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> res = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> m = num1.size(),n = num2.size();</span><br><span class="line">        <span class="keyword">int</span> i = m<span class="number">-1</span>, j = n<span class="number">-1</span>, carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&gt;=<span class="number">0</span>||j&gt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">int</span> a = i &gt;= <span class="number">0</span>?num1[i--]-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> b = j &gt;= <span class="number">0</span>?num2[j--]-<span class="string">'0'</span>:<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> sum = a + b + carry;</span><br><span class="line">            res.insert(res.begin(),sum % <span class="number">10</span> + <span class="string">'0'</span>);</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> carry? <span class="string">"1"</span>+res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]2.Add Two Numbers(两数相加)</title>
      <link href="/2019/08/27/Leetcode-2-Add-Two-Numbers/"/>
      <url>/2019/08/27/Leetcode-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="#2.Add Two Numbers"></a>#2.Add Two Numbers</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 创建一个新的链表用于两链表 value 相加结果</li><li>说明: 注意两链表的判空操作，若为空则默认其值为 0 ，且在后续不再进行指针的移位，最后对于进位符 carry 需要进行一次判断，若进位存在而相加结束，则需将进位 (1) 作数最高位。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">addTwoNumbers</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        ListNode* add2 = <span class="keyword">new</span> ListNode(<span class="number">-1</span>),*cur = add2;</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (l1 || l2) &#123;</span><br><span class="line">            <span class="keyword">int</span> val1 = l1?l1-&gt;val:<span class="number">0</span>; </span><br><span class="line">            <span class="keyword">int</span> val2 = l2?l2-&gt;val:<span class="number">0</span>; </span><br><span class="line">            <span class="keyword">int</span> sum = val1 + val2 + carry;</span><br><span class="line">            carry = sum / <span class="number">10</span>;</span><br><span class="line">            cur-&gt;next = <span class="keyword">new</span> ListNode(sum % <span class="number">10</span>);</span><br><span class="line">            <span class="keyword">if</span>(l1) l1 = l1-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(l2) l2 = l2-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(carry) cur-&gt;next = <span class="keyword">new</span> ListNode(carry);</span><br><span class="line">        <span class="keyword">return</span> add2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="2.Add Two Numbers" data-src="https://i.loli.net/2019/08/27/H75BpQZA3SN8olO.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数学 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]16.3Sum Closest(最接近的三数之和)</title>
      <link href="/2019/08/27/Leetcode-16-3Sum-Closest/"/>
      <url>/2019/08/27/Leetcode-16-3Sum-Closest/</url>
      
        <content type="html"><![CDATA[<h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="#16.3Sum Closest"></a>#16.3Sum Closest</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3></li><li>思路：先将数组顺序排序，后定义一个变量 temp 用来记录当前三数和跟给定值之间的差的绝对值，接着遍历数组，通过 left 和 right 指针 来滑动寻找另外两个数，比较并更新差值 temp 和结果和 sum</li><li>说明：因为之前已经顺序排序，所以 left 与 right 的更新由三数之和与 target 之间的比较来进行，三数之和小了就 ++left ，大了就 —right ，使得保证三数之和愈加靠近 target 。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">threeSumClosest</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">int</span> sum = nums[<span class="number">0</span>]+nums[<span class="number">1</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = <span class="built_in">abs</span>(sum-target);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;++i)&#123;</span><br><span class="line">            <span class="keyword">int</span> left=i+<span class="number">1</span>,right=nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> three = nums[i]+nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(three-target)&lt;temp)&#123;</span><br><span class="line">                    temp=<span class="built_in">abs</span>(three-target);</span><br><span class="line">                    sum = three;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(three&lt;target) ++left;</span><br><span class="line">                <span class="keyword">else</span> --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="16.3Sum Closest" data-src="https://i.loli.net/2019/08/27/HbaNw4SOUGs9peV.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 链表 </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]653.TwoSum-IV-Input-is-a-BST(两数之和IV-输入BST)</title>
      <link href="/2019/08/22/Leetcode-653-TwoSum-IV-Input-is-a-BST/"/>
      <url>/2019/08/22/Leetcode-653-TwoSum-IV-Input-is-a-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="#653.Two Sum IV-Input is a BST"></a>#653.Two Sum IV-Input is a BST</h1><ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 9</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 28</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法1-HashSet"><a href="#方法1-HashSet" class="headerlink" title="方法1.HashSet"></a>方法1.HashSet</h3></li><li>思路：建立一个HashSet索引，对于当前结点，寻找target与当前节点val之差处是否存在，存在说明两数之和为target找到即返回True，否则将结点值加入HahSet。通过递归调用来遍历整个二叉树，若结点为空即返回false。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> * time: O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; HashSet;</span><br><span class="line">        <span class="keyword">return</span> tools(root,k,HashSet);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">tools</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target,<span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(s.count(target-node-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        s.insert(node-&gt;val);</span><br><span class="line">        <span class="keyword">return</span> tools(node-&gt;left,target,s)||tools(node-&gt;right,target,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="653.TwoSumIV-Input is a BST" data-src="https://i.loli.net/2019/08/22/7JhuwqWTen4LFNa.jpg" class="lozad"></p><h3 id="方法2-层序遍历-HashSet"><a href="#方法2-层序遍历-HashSet" class="headerlink" title="方法2. 层序遍历 + HashSet"></a>方法2. 层序遍历 + HashSet</h3><ul><li>思路：改上述递归调用为迭代的方式，换位层序遍历来进行处理，其余核心的HashSet不变。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span> (!q.empty()) &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = q.front(); q.pop();</span><br><span class="line">            <span class="keyword">if</span> (st.count(k - t-&gt;val)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            st.insert(t-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法3-中序遍历"><a href="#方法3-中序遍历" class="headerlink" title="方法3.中序遍历"></a>方法3.中序遍历</h3><ul><li>思路：将二叉树进行中序遍历得到顺序排列的数组，对于有序数组，可通过左右指针匹配和。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">findTarget</span><span class="params">(TreeNode* root, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; InorderArray;</span><br><span class="line">        inorder(root,InorderArray);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> left=<span class="number">0</span>,right=InorderArray.size()<span class="number">-1</span>;left&lt;right;)&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = InorderArray[left]+InorderArray[right];</span><br><span class="line">            <span class="keyword">if</span>(sum==k) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;k) ++left; <span class="comment">/** 或者写作(nums[i] + nums[j] &lt; k) ? ++i : --j;</span></span><br><span class="line"><span class="comment">            else --right;           */</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inorder</span><span class="params">(TreeNode* node,<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; s)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!node) <span class="keyword">return</span>;</span><br><span class="line">        inorder(node-&gt;left,s);</span><br><span class="line">        s.push_back(node-&gt;val);</span><br><span class="line">        inorder(node-&gt;right,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="653.TwoSumIV-Input is a BST(inorder)" data-src="https://i.loli.net/2019/08/22/twWbZcX7V6MovAe.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]15.3Sum(三数之和)</title>
      <link href="/2019/08/21/Leetcode-15-3Sum/"/>
      <url>/2019/08/21/Leetcode-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="#15. 3Sum"></a>#15. 3Sum</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路：先确立一个目标的匹配值，然后在后续的数组中寻找两个组合之和为目标匹配值的相反数。对于后续两个组合的搜索，盲目的进行组合因为O(n^2)的关系显然不可取，所以可以通过对有序数组以双指针的方式来以线性时间的复杂度来遍历所有满足题意的两个数组合，所以需要对所给数组先进行一次顺序排序。</li><li>说明：为了更加优化算法，可以进行剪枝操作，首先对数组进行初步筛选，empty与size()<2的优先不予考虑，然后若排序后最后一位<0或第一位>0，也代表该数组不符合考虑范畴。然后当我们进行判断的过程中，当目标匹配对象&gt;0时视为退出条件，因为若目标匹配值&gt;0，则后续的两数组合之和无法得到其相反数。最后还要注意的一点，就是筛选组合的过程中，对于重复的值应当进行跳步处理，避免得到重复结论。<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">** time: O(nlogn) 快排nlogn + 搜索n</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        <span class="keyword">if</span>(nums.empty()||nums.back()&lt;<span class="number">0</span>||nums.front()&gt;<span class="number">0</span>||nums.size()&lt;<span class="number">2</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size()<span class="number">-2</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span>&amp;&amp;nums[i]==nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[i];</span><br><span class="line">            <span class="keyword">int</span> left = i+<span class="number">1</span> , right = nums.size()<span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">while</span>(left&lt;right)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = nums[left]+nums[right];</span><br><span class="line">                <span class="keyword">if</span>(sum==target)&#123;</span><br><span class="line">                    result.push_back(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[left]==nums[left+<span class="number">1</span>]) left++;</span><br><span class="line">                    <span class="keyword">while</span>(left&lt;right&amp;&amp;nums[right]==nums[right<span class="number">-1</span>]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(sum&lt;target) left++;</span><br><span class="line">                <span class="keyword">else</span> right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></2的优先不予考虑，然后若排序后最后一位<0或第一位></li></ul><p><img alt="15.3Sum(C++)" data-src="https://i.loli.net/2019/08/21/virlf49hnTFLGSQ.jpg" class="lozad"></p><h3 id="方法二-TreeSet去重法"><a href="#方法二-TreeSet去重法" class="headerlink" title="方法二: TreeSet去重法"></a>方法二: TreeSet去重法</h3><ul><li>思路：可以利用 TreeSet 的不能包含重复项的特点来防止重复项的产生，那么就不需要检测数字是否被 fix 过两次,其余思路基本同上<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; threeSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="built_in">set</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        <span class="keyword">if</span> (nums.empty() || nums.back() &lt; <span class="number">0</span> || nums.front() &gt; <span class="number">0</span>) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; (<span class="keyword">int</span>)nums.size()<span class="number">-2</span>; ++k) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[k] &gt; <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">int</span> target = <span class="number">0</span> - nums[k], left = k + <span class="number">1</span>, right = (<span class="keyword">int</span>)nums.size() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[left] + nums[right] == target) &#123;</span><br><span class="line">                    res.insert(&#123;nums[k], nums[left], nums[right]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[left] == nums[left + <span class="number">1</span>]) ++left;</span><br><span class="line">                    <span class="keyword">while</span> (left &lt; right &amp;&amp; nums[right] == nums[right - <span class="number">1</span>]) --right;</span><br><span class="line">                    ++left; --right;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[left] + nums[right] &lt; target) ++left;</span><br><span class="line">                <span class="keyword">else</span> --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]1.Tow Sum(两数之和)</title>
      <link href="/2019/08/20/Leetcode-1-Tow-Sum/"/>
      <url>/2019/08/20/Leetcode-1-Tow-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1. 两数之和"></a>#1. 两数之和</h1><ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span><br></pre></td></tr></table></figure></li><li><p>样例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></li><li><p>解答</p><h3 id="1-方法一-暴力求解，通过两层循环寻找对应解答"><a href="#1-方法一-暴力求解，通过两层循环寻找对应解答" class="headerlink" title="1. 方法一(暴力求解，通过两层循环寻找对应解答)"></a>1. 方法一(暴力求解，通过两层循环寻找对应解答)</h3></li><li>思路：从第0位开始，向后遍历找到与当前位置之和等于目标数值的另一个位置为止，或遍历到达数组尾部后初始位置向后移动一位继续穷举遍历，直到初始位置达到数组尾部，得到该数组中不存在与目标值相符的位置组<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time: O(n^2) space: O(n)</span></span><br><span class="line"><span class="comment"> * Note: The returned array must be malloced, assume caller calls free().</span></span><br><span class="line"><span class="comment"> * Language: C</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span>* <span class="title">twoSum</span><span class="params">(<span class="keyword">int</span>* nums, <span class="keyword">int</span> numsSize, <span class="keyword">int</span> target, <span class="keyword">int</span>* returnSize)</span></span>&#123;</span><br><span class="line">    *returnSize = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;numsSize<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=numsSize<span class="number">-1</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">int</span> temp = nums[i]+nums[j];</span><br><span class="line">            <span class="keyword">if</span>(temp==target)&#123;</span><br><span class="line">                <span class="keyword">int</span>* result = (<span class="keyword">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">int</span>)* *returnSize);</span><br><span class="line">                result[<span class="number">0</span>]=i;</span><br><span class="line">                result[<span class="number">1</span>]=j;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="1.TwoSum_ViolentSolution(C)" data-src="https://i.loli.net/2019/08/20/B76WHUReXzwC4oG.jpg" class="lozad"></p><h3 id="2-方法二-HashMap法"><a href="#2-方法二-HashMap法" class="headerlink" title="2. 方法二(HashMap法)"></a>2. 方法二(HashMap法)</h3><ul><li>思路: 利用HashMap进行空间换时间，首先遍历一遍数组，建立 HashMap 映射，然后再遍历一遍该数组，开始查找，找到则记录 index，否则返回NULL。</li><li><p>说明: unordered_map.count(i) 用于检验该处是否存在值; hash_map[t]!=i 用于排除原位重复匹配;</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time: O(n) sapce: O(n)</span></span><br><span class="line"><span class="comment"> * Language: C++</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; hash_map;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            hash_map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span> (hash_map.count(t) &amp;&amp; hash_map[t] != i) &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(hash_map[t]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上述代码可以进行简化，在一次遍历的过程中取寻找目标</p><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * time: O(n) sapce: O(n)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;hash_map;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.size();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> t = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(hash_map.count(t))&#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;hash_map[t],i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hash_map[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="1.TwoSum_HashMap(C++)" data-src="https://i.loli.net/2019/08/20/sXdQ62bkJYO1Laf.jpg" class="lozad"></p><ul><li>[附]若所给数组为排序后的顺序数组，则可以通过left与right指针左右并行向中间靠拢进行和的匹配，当 left==right 时，则不存在返回NULL。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析-3</title>
      <link href="/2019/06/10/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-3/"/>
      <url>/2019/06/10/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-3/</url>
      
        <content type="html"><![CDATA[<h3 id="NumPy简介"><a href="#NumPy简介" class="headerlink" title="NumPy简介"></a>NumPy简介</h3><p>NumPy(Numerical Python简称)，高性能科学计算和数据分析的基础包。</p><p>部分功能介绍如下图所示<br><img alt="numpy功能" data-src="https://i.loli.net/2019/06/10/5cfe1c687655064641.jpg" class="lozad"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br></pre></td></tr></table></figure><h4 id="Numpy的ndarray-一种多维数组对象"><a href="#Numpy的ndarray-一种多维数组对象" class="headerlink" title="Numpy的ndarray:一种多维数组对象"></a>Numpy的ndarray:一种多维数组对象</h4><p><img alt="ndarray相关" data-src="https://i.loli.net/2019/06/10/5cfe2290ccdca77085.jpg" class="lozad"></p><p><img alt="numpy数据类型" data-src="https://i.loli.net/2019/06/10/5cfe23914c6fb91125.jpg" class="lozad"><br><img alt="numpy数据类型2" data-src="https://i.loli.net/2019/06/10/5cfe262d6e45d27503.jpg" class="lozad"></p><p>不同大小数组之间的运算叫做广播(broadcasting)</p><h5 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h5><p>数组的切片是原始数据的视图，对切片的操作将直接反映到源数组上。</p><p><code>[x:y]</code>切片取到的是x到y-1字段内的数据，y处数据无法取到。</p><p><img alt="切片索引2维数组示例" data-src="https://i.loli.net/2019/06/10/5cfe2ca5e087324849.jpg" class="lozad"></p><p>关键字and和or在布尔型数组中无效，考虑使用逻辑运算符</p><h5 id="矩阵转置和轴对称"><a href="#矩阵转置和轴对称" class="headerlink" title="矩阵转置和轴对称"></a>矩阵转置和轴对称</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.T:转置</span><br><span class="line">np.dot(X,Y):X和Y的矩阵内积</span><br></pre></td></tr></table></figure><h4 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h4><p><img alt="一元ufunc" data-src="https://i.loli.net/2019/06/10/5cfe4a956172572253.jpg" class="lozad"></p><p><img alt="二元ufunc" data-src="https://i.loli.net/2019/06/10/5cfe4b0bc9b7167268.jpg" class="lozad"></p><h4 id="利用数组进行数组处理-矢量化"><a href="#利用数组进行数组处理-矢量化" class="headerlink" title="利用数组进行数组处理(矢量化)"></a>利用数组进行数组处理(矢量化)</h4><p><img alt="基本数组统计方法" data-src="https://i.loli.net/2019/06/10/5cfe5847dc7df99208.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习笔记-2</title>
      <link href="/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-0-New-Tips"><a href="#Part-0-New-Tips" class="headerlink" title="Part.0 New Tips"></a>Part.0 New Tips</h2><h4 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h4><p>Python用关键词<code>def</code>来定义函数。</p><h4 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h4><p>用class来定义一个类。<code>Person(object)</code>表示继承自object类；<code>__init__</code>函数用来初始化对象； <code>self</code>表示对象自身，类似于C、Java里面<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, first, last, age):</span><br><span class="line">        self.first = first</span><br><span class="line">        self.last = last</span><br><span class="line">        self.age = age</span><br><span class="line">    def full_name(self):</span><br><span class="line">        return self.first + &apos; &apos; + self.last</span><br></pre></td></tr></table></figure></p><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>当对数据进行统计时，可进行初始化操作，方便统计的同时也可以减少对空对象的异常报错（例如<code>int-&gt;0</code>; <code>list-&gt;[]</code>; <code>set-&gt;{}</code>等），最终返回的是字典键值对<code>({x:x},{x:x},...)</code>，可以通过<code>dict.items()</code>以列表返回可遍历的<code>(键, 值)</code>元组数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">    x = defaultdict(int/list/set)</span><br></pre></td></tr></table></figure></p><h2 id="Part-1-Coding-Records"><a href="#Part-1-Coding-Records" class="headerlink" title="Part.1 Coding Records"></a>Part.1 Coding Records</h2><p>当我们获取到Json格式(即JavaScript Object Notation，一种常见的web数据格式)的文本数据时，可以通过<code>json.loads()</code>将其转换为python的字典对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">path = &apos;xxx/xxx/xxxx/xx.txt&apos;</span><br><span class="line">records = [json.loads(line) for line in open(path)]</span><br></pre></td></tr></table></figure></p><h3 id="提取统计量中的前n项"><a href="#提取统计量中的前n项" class="headerlink" title="提取统计量中的前n项"></a>提取统计量中的前n项</h3><h4 id="method-1"><a href="#method-1" class="headerlink" title="method 1"></a>method 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"> def get_count(sequence):</span><br><span class="line">    counts = defaultdict(int)</span><br><span class="line">    for x in sequence :</span><br><span class="line">        counts[x]+=1</span><br><span class="line">    return counts</span><br><span class="line"></span><br><span class="line"> # 操作对象：字典键值对`count_dict`(先将list列表数据进行统计操作后得到)</span><br><span class="line"> def top_count(count_dict,n):</span><br><span class="line">    value_key_pairs=[(count,name) for name,count in count_dict.items()]</span><br><span class="line">    value_key_pairs.sort()</span><br><span class="line">    return value_key_pairs[-n:] #排序后的列表进行倒序输出</span><br><span class="line">    </span><br><span class="line"> counts = get_count(list)</span><br><span class="line"> top_count(counts,n)</span><br></pre></td></tr></table></figure><h4 id="method-2"><a href="#method-2" class="headerlink" title="method 2"></a>method 2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作对象：源数据list列表</span><br><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line"> counts = Counter(list)</span><br><span class="line"> counts.most_common(n)#获取按顺序排列的前n项键值对</span><br></pre></td></tr></table></figure><h4 id="method-3"><a href="#method-3" class="headerlink" title="method 3"></a>method 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pandas import DataFrame,Series</span><br><span class="line">import pandas as pd;import numpy as np</span><br><span class="line">import json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path=&apos;xxx/xxx/xxx.txt&apos;</span><br><span class="line"></span><br><span class="line">records=[json.loads(line) for line in open(path)] #获得字典数据对象</span><br><span class="line">frame=DataFrame(records) #DataFrame可以将数据转化为表格的形式</span><br><span class="line">  </span><br><span class="line">xx_counts= frame[&apos;xx&apos;].value_counts() #frame[&apos;xx&apos;]返回Series对象，其方法value_counts()获得排序后的队列</span><br></pre></td></tr></table></figure><p>此时的数据其实并不完美，内部存在未知或缺失的情形，下述代码进行对记录中的不规范时区进行替代值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean_xx = frame[&apos;xx&apos;].fillna(&apos;Missing&apos;) #fillna函数替换缺失值(NA)</span><br><span class="line"></span><br><span class="line">clean_xx[clean_xx==&apos;&apos;]=&apos;Unknown&apos;  #未知值(空字符串)通过布尔型数组索引替换</span><br><span class="line"></span><br><span class="line">xx_counts=clean_xx.value_counts() #得到修正后的列表排列</span><br></pre></td></tr></table></figure></p><p>为了直观的显示出来，可以调用Series.plot方法得到水平条形图，这里顺带介绍一下啊IPython中如何显示图像的几步步骤<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">  plt.figure()</span><br><span class="line">  </span><br><span class="line">  xx_counts[:n].plot(kind=&apos;barh&apos;,rot=&apos;0&apos;)</span><br><span class="line">  </span><br><span class="line">  plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习笔记-1</title>
      <link href="/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h3 id="IPython的使用"><a href="#IPython的使用" class="headerlink" title="IPython的使用"></a>IPython的使用</h3><p>可以通过命令行(cmd)窗口键入ipython进入ipython解释器</p><p>其中可以使用 <code>?</code> 来查看函数的帮助<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum?</span><br></pre></td></tr></table></figure></p><p>或在导入包以后使用<code>??</code>查看函数帮助和函数源代码.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入numpy和matplotlib两个包</span><br><span class="line">%pylab</span><br><span class="line"># 查看其中sort函数的帮助</span><br><span class="line">sort??</span><br></pre></td></tr></table></figure></p><p><strong>！！！以下代码无特别说明均默认在IPython的解释器下运行！！！</strong></p><h3 id="Anaconda-conda-的使用"><a href="#Anaconda-conda-的使用" class="headerlink" title="Anaconda(conda)的使用"></a>Anaconda(conda)的使用</h3><p>Anaconda是一个很好用的Python IDE，它集成了很多科学计算需要使用的python第三方工具包。</p><p>可以通过<code>!conda list</code>查询已经安装好的python第三方工具包。(注：IPython中使用<code>！</code>来调用系统命令)</p><p>对于 Anaconda 自身，可以在命令行(cmd)输入以下命令使其保持最新：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure></p><p>安装，更新，卸载第三方的 python 工具包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install &lt;some package&gt;</span><br><span class="line">conda update &lt;some package&gt;</span><br><span class="line">conda remove &lt;some package&gt;</span><br></pre></td></tr></table></figure></p><p>在安装或更新时可以指定安装的版本号，例如需要使用 <code>numpy 1.8.1</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install numpy=1.8.1</span><br><span class="line">conda update numpy=1.8.1</span><br></pre></td></tr></table></figure></p><p>在命令行(cmd)下可以使用 conda 产生一个新的环境(命名任意，这里这个环境被命名为 xxx )：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n xxx python=3.7</span><br></pre></td></tr></table></figure></p><p>使用这个环境时，只需要命令行下输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activate xxx</span><br></pre></td></tr></table></figure></p><p>即可实现环境的切换。</p><p>Anaconda 默认使用的编辑器是 spyder，可以在命令行下输入<code>spyder</code>进入。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析[2]</title>
      <link href="/2019/03/29/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-2/"/>
      <url>/2019/03/29/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h3><p>Python是一种解释型语言。Python解释器是通过“一次执行一条语句”的方式运行程序的。标准的交互式Python解释器可以在命令行上通过python命令启动。退出Python解释器并返回命令提示符,输入exit()或按下Ctrl-D即可。</p><p>虽然许多Python程序员用这种方式执行他们的所有Python代码,但Python科学计算程序员则更趋向于使用IPython(一种加强的交互式Python解释器)。通过使用%run命令,IPython会在同一个进程中执行指定文件中的代码。因此,在这些代码执行完毕之后,你就可以通过交互的方式研究其结果。</p><p>默认的IPython提示符采用的是一种编号的风格(如In[2]:),而不是标准的”&gt;&gt;&gt;”提示符。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="语言语义"><a href="#语言语义" class="headerlink" title="语言语义"></a>语言语义</h4><p>Python语言的设计特点是重视可读性、简洁性以及明确性。有些人甚至将它看做“可执行的伪码”。</p><h4 id="缩进-而不是大括号"><a href="#缩进-而不是大括号" class="headerlink" title="缩进,而不是大括号"></a>缩进,而不是大括号</h4><p>Python是通过空白符(制表符或空格)来组织代码的,不像其他语言(如R、C++、Java、Perl等)用的是大括号。以for循环为例,要实现前面说的那个快速排序算法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in array:</span><br><span class="line">  if x &lt; pivot:</span><br><span class="line">    less.append ( x )</span><br><span class="line">  else:</span><br><span class="line">    greater.append ( x )</span><br></pre></td></tr></table></figure></p><p>冒号表示一段缩进代码块的开始,其后的所有代码都必须缩进相同的量,直到代码块结束为止。在别的语言中,你可能会看到下面这样的东西:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in array &#123;</span><br><span class="line">  if x &lt; pivot &#123;</span><br><span class="line">    less.append ( x )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    greater.append ( X )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前缀#作为注释标识符。</p><h4 id="变量和按引用传递"><a href="#变量和按引用传递" class="headerlink" title="变量和按引用传递"></a>变量和按引用传递</h4><p>在Python中对变量赋值时,你其实是在创建等号右侧对象的一个引用。<br>假如我们将a赋值给一个新变量b:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [2]:b=a</span><br></pre></td></tr></table></figure></p><p>在某些语言中,该赋值过程将会导致数据被复制。而在Python中,a和b现在都指向同一个对象。即指向同一个对象的两个引用。</p><p>注意:赋值(assignment)操作也叫做绑定(binding),因为我们其实是将一个名称和一个对象绑定到一起。已经赋过值的变量名有时也被称为已绑定变量(bound variable)。</p><p>当你将对象以参数的形式传入函数时,其实只是传入了一个引用而已,不会发生任何复制。因此,Python被称为是按引用传递的,而某些其他的语言则既支持按值传递(创建副本)又支持按引用传递。也就是说,Python函数可以修改其参数的内容。</p><h4 id="动态引用-强类型"><a href="#动态引用-强类型" class="headerlink" title="动态引用,强类型"></a>动态引用,强类型</h4><p>跟许多编译型语言(如Java和C++)相反,Python中的对象引用没有与之关联的类型信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [245]: a = 5</span><br><span class="line">In [246]: type(a)</span><br><span class="line">Out[246]:int</span><br><span class="line">In [247]: a = &apos; foo&apos;</span><br><span class="line">In [248]: type(a)</span><br><span class="line">Out[2481:str</span><br></pre></td></tr></table></figure></p><p>变量其实就是对象在特定命名空间中的名称而已。对象的类型信息是保存在它自己内部的。有些人可能会轻率地认为Python不是一种“类型化语言”。其实不是这样的。看看下面这个例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [249]: &apos;5&apos; + 5</span><br><span class="line">  TypeError</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-249-f9dbf5f0b234&gt; in &lt;module&gt;(</span><br><span class="line">-----&gt; 1 &apos;5&apos; + 5</span><br><span class="line">TypeError: cannot concatenate &apos;str&apos; and</span><br><span class="line">&apos; int &apos; objects</span><br></pre></td></tr></table></figure></p><p>在有些语言中(比如Visual Basic),字符串’5’可能会被隐式地转换为整数,于是就会得到10。而在另一些语言中(比如JavaScript),整数5可能会被转换为字符串,于是就会得到’55’。而在这一点上,Python可以被认为是一种强类型语言,也就是说,所有对象都有一个特定的类型(或类),隐式转换只在很明显的情况下才会发生,比如下面这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [250]: a = 4.5</span><br><span class="line">In [251]: b = 2</span><br><span class="line">#这个操作是字符串格式化,稍后介绍</span><br><span class="line">In [252]: print &apos;a is %s, b is                %s&apos; % (type(a),type(b))</span><br><span class="line">a is &lt;type &apos;float&apos; , b is &lt;type &apos;int&apos;&gt;</span><br><span class="line">In [253]: a / b</span><br><span class="line">Out[253]: 2.25</span><br></pre></td></tr></table></figure></p><p>了解对象的类型是很重要的。要想编写能够处理多个不同类型输入的函数就必须了解有关类型的知识。通过isinstance函数,你可以检查一个对象是否是某个特定类型的实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [254]: a = 5</span><br><span class="line">In [255]: isinstance(a,int)</span><br><span class="line">Out[255]:True</span><br></pre></td></tr></table></figure></p><p>isinstance可以接受由类型组成的元组。如果想检查某个对象的类型是否属于元组中所指定的那些:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In[256]:a=5;b=4.5</span><br><span class="line">In [257): isinstance(a, (int, float)</span><br><span class="line">Out[257):True</span><br><span class="line">In [258]: isinstance(b,(int,float))</span><br><span class="line">Out/2581:True</span><br></pre></td></tr></table></figure></p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>Python中的对象通常都既有属性(attribute,即存储在该对象“内部”的其他Python对象)又有方法(method,与该对象有关的能够访问其内部数据的函数)。它们都能通过obj.attribute_name这样的语法进行访问:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: a =&apos;foo&apos;</span><br><span class="line">In [2]: a.&lt;Tab&gt;</span><br><span class="line">a.capitalize a.format a.isupper</span><br><span class="line">a.rindex a.strip a.center a.index</span><br><span class="line">a.join a.riust a.swapcase a.count</span><br><span class="line">a.isalnum a.ljust a.rpartition </span><br><span class="line">a.title a.decode a.isalpha a.lower</span><br><span class="line">a.rsplit a.translate a.encode </span><br><span class="line">a.isdigit a.lstrip a.rstrip a.upper</span><br><span class="line">a.endswith a.islower a.partiti</span><br><span class="line">a.split a.zfill a.expandtabs a.isspace a.replace a.splitlines</span><br><span class="line">a.find a.istitle a.rfind a.startswith</span><br></pre></td></tr></table></figure></p><p>属性和方法还可以利用getattr函数通过名称进行访问:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;getattr(a,&apos;split&apos;)</span><br><span class="line">&lt; function split&gt;</span><br></pre></td></tr></table></figure></p><p>虽然本书没怎么用到getattr函数以及与之相关的hasattr和setattr函数,但是它们还是很实用的,尤其是在编写通用的、可复用的代码时。</p><h4 id="“鸭子”类型"><a href="#“鸭子”类型" class="headerlink" title="“鸭子”类型"></a>“鸭子”类型</h4><p>一般来说,你可能不会关心对象的类型,而只是想知道它到底有没有某些方法或行为。<br>比如说,只要一个对象实现了迭代器协议(iterator protocol),你就可以确认它是可迭代的。对于大部分对象而言,这就意味着它拥有一个<em>iter</em>魔术方法。当然,还有一个更好一些的验证办法,即尝试使用iter函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def isiterable(obj):</span><br><span class="line">try:</span><br><span class="line">  iter(obj)</span><br><span class="line">  return True</span><br><span class="line">except TypeError:#不可迭代</span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p><p>对于字符串以及大部分Python集合类型,该函数会返回True:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [260]: isiterable(&apos;a string&apos;) </span><br><span class="line">In [261]: isiterable([1,2,3])</span><br><span class="line">Out[260]:True</span><br><span class="line">Out[261]:True</span><br><span class="line">In [262]: isiterable(5)</span><br><span class="line">Out[262]:False</span><br></pre></td></tr></table></figure></p><p>我常常在编写需要处理多类型输入的函数时用到这个功能。还有一种常见的应用场景:编写可以接受任何序列(列表、元组、ndarray)或迭代器的函数。你可以先检查对象是不是列表(或NumPy数组),如果不是,就将其转换成是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if not isinstance(x, list) and isiterable(x):</span><br><span class="line">  x = list ( x )</span><br></pre></td></tr></table></figure></p><h4 id="引入-import"><a href="#引入-import" class="headerlink" title="引入(import)"></a>引入(import)</h4><p>在Python中,模块(module)就是一个含有函数和变量定义以及从其他.py文件引入的此类东西的.py文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import some module</span><br><span class="line">x=some module.xxx</span><br></pre></td></tr></table></figure></p><p>还可以写成这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from some_module import xxx</span><br><span class="line">x = xxx (x,...)</span><br></pre></td></tr></table></figure></p><p>通过as关键字,你可以引入不同的变量名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import some_module as sm</span><br><span class="line">from some_module import xxx as XXX</span><br><span class="line">x=sm.xxx  </span><br><span class="line">x=XXX(x)</span><br></pre></td></tr></table></figure></p><h4 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h4><p>要判断两个引用是否指向同一个对象,可以使用is关键字。如果想判断两个引用是否不是指向同一个对象,则可以使用is not:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [266]: a = [1, 2, 3]</span><br><span class="line">In [267]:b=a</span><br><span class="line">#注意,list函数始终会创建新列表l  </span><br><span class="line">In [268]: c = list(a)</span><br><span class="line">In [269]: a is b</span><br><span class="line">Out[269]:True</span><br><span class="line">In [270]: a is not C</span><br><span class="line">Out[270]:True</span><br></pre></td></tr></table></figure></p><p>注意,这跟比较运算”==”不是一回事,因<br>为对于上面这个情况,我们将会得到:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [271]: a == c</span><br><span class="line">Out[271]:True</span><br></pre></td></tr></table></figure></p><p>is和is not常常用于判断变量是否为None,<br>因为None的实例只有一个:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [272]: a = None</span><br><span class="line">In [273]: a is None</span><br><span class="line">Out[273]:True</span><br></pre></td></tr></table></figure></p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd116f5e5f092561.jpg" class="lozad"></p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd11aa5007172706.jpg" class="lozad"></p><h4 id="可变和不可变的对象"><a href="#可变和不可变的对象" class="headerlink" title="可变和不可变的对象"></a>可变和不可变的对象</h4><p>大部分Python对象是可变的(mutable),比如列表、字典、NumPy数组以及大部分用户自定义类型(类)。也就是说,它们所包含的<br>对象或值是可以被修改的。</p><p>而其他的(如字符串和元组等)则是不可变的(immutable)</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>很多人都是因为Python强大而灵活的字符串处理能力才使用它的。编写字符串字面量时,既可以用单引号(‘)也可以用双引号(“):</p><p>对于带有换行符的多行字符串,可以使用三重引号(即<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">  C = &quot;&quot;&quot;</span><br><span class="line">      This is a longer string that</span><br><span class="line">      spans multiple lines</span><br><span class="line">      &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p><p>Python字符串是不可变的。要修改字符串就只能创建一个新的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [289]: a = &apos;this is a string&apos;</span><br><span class="line">In[290]:a[10]=&apos;f&apos;</span><br><span class="line">TypeError</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-290-5ca625d1e504&gt; in &lt;module&gt;()</span><br><span class="line"> ----&gt;1 a[10] = &apos;f&apos;</span><br><span class="line">TypeError:&apos;str&apos; object does not support</span><br><span class="line">item assignment</span><br><span class="line"></span><br><span class="line">In [291]:b=a.replace(&apos;string&apos;,&apos;long</span><br><span class="line">er string&apos;)</span><br><span class="line">In [292]: b</span><br><span class="line">Out[292]: &apos;this is a longer string&apos;</span><br></pre></td></tr></table></figure></p><p>许多Python对象都可以用str函数转换为字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [293]: a = 5.6</span><br><span class="line">In [294]: s =str(a)</span><br><span class="line">In [295]: s</span><br><span class="line">Out[295]:&apos;5.6&apos;</span><br></pre></td></tr></table></figure></p><p>由于字符串其实是一串字符序列,因此可以被当做某种序列类型(如列表、元组等)进行处理:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [296]: s=&apos;python&apos;</span><br><span class="line">In [297]: list(s)</span><br><span class="line">Out[297]: [&apos;p&apos;,&apos;y&apos;,&apos;t&apos;,&apos;h&apos;,&apos;o&apos;,&apos;n&apos;]</span><br><span class="line">In [298]: s[:3]</span><br><span class="line">Out[298]:&apos;pyt&apos;</span><br></pre></td></tr></table></figure></p><p>反斜杠()是转义符(escape character),也就是说,它可用于指定特殊字符(比如新行\n或unicode字符)。要编写带有反斜杠的字符串字面量,也需要对其进行转义。</p><p>若在字符串最左边引号的前边加上r，表示所有的字符按照原来的样子进行解释。</p><p>Python 3带来了一些新的字符串格式化手段,以一个%开头且后面跟着一个或多个格式字符的字符串是需要插入值的目标(这非常类似于C语言中的printf函数)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [306]: template=&apos;%.2f %s are worth</span><br><span class="line">$%d&apos;</span><br></pre></td></tr></table></figure></p><p>在这个字符串中,%s表示将参数格式化为字符串,%.2f表示一个带有2位小数的数字,%d表示一个整数。要用实参替换这些格式化形参,需要用到二元运算符%以及由值组成的元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [307]: template % (4.5560,&apos;Argentine Pesos&apos;, 1)</span><br><span class="line">Out[307]:&apos;4.56 Argentine Pesos are worth $1&apos;</span><br></pre></td></tr></table></figure></p><p>几乎所有内置的Python类型以及任何定义了<em>nonzero</em>魔术方法的类都能在if语句中被解释为True或False。</p><p>Python中大部分对象都有真假的概念。比如说,如果空序列(列表、字典、元组等)用于控制流就会被当做False处理。要想知道某个对象究竟会被强制转换成哪个布尔值,使用bool函数即可。</p><h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>如果一个函数没有显式的返回值，则隐式返回None。</p><p>是函数可选参数的一种常见默认值。</p><p>None不是一个保留关键字，而是NoneType的一个实例而已。</p><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>Python内置的datetime模块提供了datetime、date以及time等类型。datetime类型是用得最多的,它合并了保存在date和time中的信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [325]: from datetime import datetime, date , time</span><br><span class="line">In [326]: dt = datetime(2011,10,29,20,30,21)</span><br><span class="line">In [327] : dt.day</span><br><span class="line">In [328]: dt.minute</span><br><span class="line">Out[327]:29</span><br><span class="line">Out[328]:30</span><br></pre></td></tr></table></figure></p><p>给定一个datetime实例,你可以通过调用其date和time方法提取相应的date和time对<br>象:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [329]: dt.date()</span><br><span class="line">In [330] : dt.time ( )</span><br><span class="line">Out[329]:datetime.date(2011,10,29)</span><br><span class="line">Out[330]:datetime.time(20,30,21)</span><br></pre></td></tr></table></figure></p><p>strftime方法用于将datetime格式化为字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [331]: dt.strftime(&apos;%m/%d/%Y%H:%M&apos;)</span><br><span class="line">Out[331]:10/29/2011 20:30&apos;</span><br></pre></td></tr></table></figure></p><p>字符串可以通过strptime函数转换(解析)为datetime对象:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [332] : datetime.strptime (&apos; 20091031 &apos; , &apos;%Y%m%d&apos;)</span><br><span class="line">Out[332]:datetime.datetime(2009,10,31,0,0)</span><br></pre></td></tr></table></figure></p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>调用列表的sort方法可以实现就地排序(无需创建新对象):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [398]: x = [x,...]</span><br><span class="line">In [399]: x.sort()</span><br></pre></td></tr></table></figure></p><p>sort有几个很不错的选项。一个是次要排序键,即一个能够产生可用于排序的值的函数。例如,可以通过长度对一组字符串进行排序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [401]:x=[&apos;xxx&apos;,&apos;xxx&apos;,...]</span><br><span class="line">In [402]:x.sort(key=len)</span><br></pre></td></tr></table></figure></p><h4 id="二分搜索及维护有序列表"><a href="#二分搜索及维护有序列表" class="headerlink" title="二分搜索及维护有序列表"></a>二分搜索及维护有序列表</h4><p>内置的bisect模块实现了二分查找以及对有序列表的插入操作。bisect.bisect可以找出新元素应该被插入到哪个位置才能保持原列表的有序性,而bisect.insort则确实地将新元素插入到那个位置上去（但bisect不会判断原列表是否有序）。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>通过切片标记法,你可以选取序列类型(数组、元组、NumPy数组等)的子集,其基本形式由索引运算符([])以及传入其中的start:stop构成。(stop未包含在其中)<br>负数索引从序列的末尾开始切片。</p><p>还可以在第二个冒号后面加上步长<br>(step)。比如每隔一位取出一个元素:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [418]: seq[::2]</span><br></pre></td></tr></table></figure></p><p>在这里使用-1是一个很巧妙的办法,它可以实现列表或元组的反序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [419]: seq[::-1]</span><br></pre></td></tr></table></figure></p><h4 id="内置的序列函数"><a href="#内置的序列函数" class="headerlink" title="内置的序列函数"></a>内置的序列函数</h4><h5 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h5><p>在对一个序列进行迭代时,常常需要跟踪当前项的索引。Python内置了一个enumerate函数,它可以逐个返回序列的(i,value)元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i,value in enumerate(collection):</span><br><span class="line">  #用value做一些事情</span><br></pre></td></tr></table></figure></p><p>在对数据进行索引时,enumerate还有一种不错的使用模式,即求取一个将序列值(假定是唯一的)映射到其所在位置的字典。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [420]: some_list=[&apos;foo&apos;,&apos;bar&apos;,baz&apos;]</span><br><span class="line">In [421]: mapping = dict((v, i) for i,v in enumerate(some_list))</span><br><span class="line">In [422]: mapping</span><br><span class="line">Out[422]:&#123;&apos;bar&apos;:1,&apos;baz&apos;:2,&apos;foo&apos;:0&#125;</span><br></pre></td></tr></table></figure></p><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>sorted函数可以将任何序列返回为一个新的有序列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [423]: sorted([x,...])</span><br></pre></td></tr></table></figure></p><p>常常将sorted和set结合起来使用以得到一个由序列中的唯一元素组成的有序列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [425]: sorted(set(&apos;xxxxxxxxx&apos;))</span><br></pre></td></tr></table></figure></p><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>zip用于将多个序列(列表、元组等)中的元素“配对”,从而产生一个新的元组列表。</p><p>zip可以接受任意数量的序列,最终得到的元组数量由最短的序列决定:</p><p>zip最常见的用法是同时迭代多个序列,还可以结合enumerate一起使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [431]: for i, (a, b) in enumerate(zip(seq1,seq2)):</span><br><span class="line">print(&apos;%d:%s,%s&apos;%(i,a,b))</span><br><span class="line">0:seq1.x1,seq2.y1</span><br><span class="line">1:seq1.x2,seq2.y2</span><br><span class="line">2:seq1.x3,seq2.y3</span><br></pre></td></tr></table></figure></p><p>对于“已压缩的”(zipped)序列,zip还有一个很巧妙的用法,即对该序列进行“解压”(unzip)。其实就是将一组行转换为一组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [433]: first_xs,last_xs=zip(*seqs)</span><br></pre></td></tr></table></figure></p><h5 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h5><p>reversed用于按逆序迭代序列中的元<br>素:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [436]: list(reversed(range(10))</span><br><span class="line">0ut[436]: [9,8,7,6,5,4,3,2,1,0]</span><br></pre></td></tr></table></figure></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典(dict)可算是Python中最重要的内置数据结构。它更常见的名字是哈希映射(hash map)或相联数组(associative array)。它是一种大小可变的键值对集,其中的键(key)和值(value)都是Python对象。创建字典的方式之一是:使用大括号({})并用冒号分隔键和值。</p><p>keys和values方法分别用于获取键和值的列表。虽然键值对没有特定的顺序,但这两个函数会以相同的顺序输出键和值:</p><p>Python 3中dict.keys()和dict.values()会返回迭代器而不是列表。</p><p>利用update方法,一个字典可以被合并到另一个字典中去:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [451]: x1.update(&#123;x:&apos;xxx&apos;,&apos;x&apos;:xxx&#125;)</span><br></pre></td></tr></table></figure></p><p>从序列类型创建字典有时你可能会想将两个序列中的元素两两配对地组成一个字典。粗略分析一下之后,你可能会写出这样的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapping=&#123;&#125;</span><br><span class="line">for key,value in zip(key_list,value_list):</span><br><span class="line">  mapping[key]=value</span><br></pre></td></tr></table></figure></p><p>由于字典本质上就是一个二元元组集,所以我们完全可以用dict类型函数直接处理二元元组列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [453]: mapping = dict(zip(range(5),reversed(range(5))))</span><br></pre></td></tr></table></figure></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>下面这样的逻辑很常见:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if key in some_dict:</span><br><span class="line">  value=some_dict[key]</span><br><span class="line">else:</span><br><span class="line">  value = default value</span><br></pre></td></tr></table></figure></p><p>其实dict的get和pop方法可以接受一个可供返回的默认值,于是,上面的if-else块就可以被简单地写成:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value=some_dict.get(key,default value)</span><br></pre></td></tr></table></figure></p><p>如果key不存在,则get默认返回None,而pop则会引发一个异常。在设置值的时候,常常会将字典中的值处理成别的集类型(比如列表)。例如,根据首字母对一组单词进行分类并最终产生一个由列表组成的字典:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In[455]:words=[&apos;apple&apos;,&apos;bat&apos;,&apos;bar&apos;,&apos;atom&apos;,&apos;book&apos;]</span><br><span class="line">In [456]: by_letter = &#123;&#125;</span><br><span class="line">In [457] : for word in words:letter=word[0]</span><br><span class="line">  if letter not in by_letter:</span><br><span class="line">    by_letter[letter]=[word]</span><br><span class="line">  else:</span><br><span class="line">    by_letter[letter]. append(n</span><br><span class="line">In [458]: by_letter</span><br><span class="line">Out[458]:&#123;&apos;a&apos;:[&apos;apple&apos;,&apos;atom&apos;],&apos;b&apos;:[&apos;bat&apos;,&apos;bar&apos;,&apos;book&apos;]&#125;</span><br></pre></td></tr></table></figure><p>字典的setdefault方法刚好能达到这个目的。上面的if-else块可以写成:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">by_letter.setdefault(letter,[]).append(word)</span><br></pre></td></tr></table></figure><p>内置的collections模块有一个叫做defaultdict的类,它可以使该过程更简单。传入一个类型或函数(用于生成字典各插槽所使用的默认值)即可创建出一个defaultdict:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"></span><br><span class="line">for word in words:</span><br><span class="line">  by_letter[word[0]].append(word)</span><br></pre></td></tr></table></figure><p>defaultdict的初始化器只需要一个可调用对象(例如各种函数),并不需要明确的类型。因此,如果你想要将默认值设置为4,只需传入一个能够返回4的函数即可:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">counts=defaultdict(1ambda:4)</span><br></pre></td></tr></table></figure><h4 id="字典键的有效类型"><a href="#字典键的有效类型" class="headerlink" title="字典键的有效类型"></a>字典键的有效类型</h4><p>虽然字典的值可以是任何Python对象,但键必须是不可变对象,如标量类型(整数、浮点数、字符串)或元组(元组中的所有对象也必须是不可变的)。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合Set是由唯一元素组成的无序集</p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd13314501789880.jpg" class="lozad"></p><h4 id="列表-集合-字典推导式"><a href="#列表-集合-字典推导式" class="headerlink" title="列表,集合,字典推导式"></a>列表,集合,字典推导式</h4><p>列表推导式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[expr for val in collection if condition]</span><br></pre></td></tr></table></figure></p><p>这相当于下面这段for循环:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = [ ]</span><br><span class="line">for val in collection:</span><br><span class="line">  if condition:</span><br><span class="line">    result . append ( expr )</span><br></pre></td></tr></table></figure></p><p>过滤器条件可以省略,只留下表达式。<br>集合和字典的推导式是该思想的一种自然延伸,它们的语法差不多,只不过产生的是集合和字典而已。字典推导式的基本形式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_comp=&#123;key-expr:value-expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure></p><p>集合推导式跟列表推导式非常相似,唯一的区别就是它用的是花括号而不是方括号:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_comp=&#123;expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure><h4 id="函数亦为对象"><a href="#函数亦为对象" class="headerlink" title="函数亦为对象"></a>函数亦为对象</h4><p>由于Python函数都是对象,因此,在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组,希望对其进行一些数据清理工作并执行一堆转换:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">states = [ &apos; Alabama &apos; , &apos; Georgia ! &apos; , &apos; Georgia&apos;,&apos;georgia&apos;,&apos;F10rIda&apos;,&apos;south carolina##&apos;,&apos;West virginia?&apos;]</span><br></pre></td></tr></table></figure><p>不管是谁,只要处理过由用户提交的调查数据,就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串,需要做很多事情:去除空白符、删除各种标点符号、正确的大写格式等。牟一看上去,我们可能会写出下面这样的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re # 正则表达式模块</span><br><span class="line">def clean_strings(strings):</span><br><span class="line">  result = [ ]</span><br><span class="line">  for value in strings:</span><br><span class="line">    value = value . strip ( )</span><br><span class="line">    value = re . sub ( &apos; ! ! #? ] &apos; , &apos;&apos; , value)#移除标点符号</span><br><span class="line">    value =value.title()</span><br><span class="line">    result.append(value)</span><br><span class="line">  return result</span><br></pre></td></tr></table></figure><p>最终结果如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [15]: clean_strings(states)</span><br><span class="line">Out[15]:</span><br><span class="line">[&apos;Alabama&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Florida&apos;,</span><br><span class="line">&apos;South Carolina&apos;,</span><br><span class="line">&apos; West Virginia &apos; ]</span><br></pre></td></tr></table></figure></p><p>其实还有另外一种不错的办法:将需要在一组给定字符串上执行的所有运算做成一个列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def remove_punctuation(value):</span><br><span class="line">  return re.sub ( &apos;!#?&apos;,&apos;&apos;, value)</span><br><span class="line"></span><br><span class="line">clean_ops=[str.strip,remove_punctuation,str.title]</span><br><span class="line"></span><br><span class="line">def clean_strings(strings,ops):</span><br><span class="line">  result = [ ]</span><br><span class="line">  for value in strings:</span><br><span class="line">    for function in ops:</span><br><span class="line">      value=function(value)</span><br><span class="line">    result.append (value)</span><br><span class="line">  return result</span><br></pre></td></tr></table></figure></p><p>然后我们就有了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [22]: clean_strings(states,clean_ops)</span><br><span class="line">Out[22]:</span><br><span class="line">[&apos;Alabama&apos;</span><br><span class="line">&apos;Georgia&apos;,</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;,</span><br><span class="line">&apos;Florida&apos;,</span><br><span class="line">&apos;South Carolina&apos;,</span><br><span class="line">&apos;West Virginia&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="闭包-返回函数的函数"><a href="#闭包-返回函数的函数" class="headerlink" title="闭包:返回函数的函数"></a>闭包:返回函数的函数</h4><p>闭包(closure)就是由其他函数动态生成并返回的函数。其关键性质是,被返回的函数可以访问其创建者的局部命名空间中的变量。</p><p>闭包和标准Python函数之间的区别在于:即使其创建者已经执行完毕,闭包仍能继续访问其创建者的局部命名空间。虽然闭包的内部状态一般都是静态的,但也允许使用可变对象(如字典、集合、列表等可以被修改的对象)。例如,下面这个函数可以返回一个能够记录其参数(曾经传入的一切参数)的函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def make_watcher():</span><br><span class="line">  have seen = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  def has_been_seen(x):</span><br><span class="line">    if x in have seen:</span><br><span class="line">      return True</span><br><span class="line">    else:</span><br><span class="line">      have_seen[x]=True</span><br><span class="line">      return False</span><br><span class="line">  </span><br><span class="line">  return has been seen</span><br></pre></td></tr></table></figure></p><p>对一组整数使用该函数,可以得到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [496]:watcher=make_watcher()</span><br><span class="line">In [497]:vals=[5,6,1,5,1,6,3,5]</span><br><span class="line">In [498]: [watcher(x) for x in vals]</span><br><span class="line">Out[498]: [False, False, False, True, True, True, False, True]</span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>生成器表达式(generator expression)是构造生成器的最简单方式。生成器也有一个类似于列表、字典、集合推导式的东西,其创建方式为,把列表推导式两端的方括号改成圆括号:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(expr for val in collection if condition)</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/coder2012/p/4990834.html" target="_blank" rel="noopener">生成器与yiely补充</a></p><h4 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h4><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如,groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [514]: import itertools</span><br><span class="line">In [515]: first_letter = lambda x: x[0]</span><br><span class="line">In [516]: names = [&apos;Alan&apos;, &apos;Adam&apos;, &apos;Wes&apos;,Will&apos;,&apos;Albert&apos;,&apos;Steven&apos;]</span><br><span class="line">In [517]: for letter, names in itertools. groupby(names,first_letter):</span><br><span class="line">print letter,list(names)#names是一个生成器</span><br><span class="line"></span><br><span class="line">A [ &apos; Alan &apos; , &apos; Adam &apos; ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析[1]</title>
      <link href="/2019/03/27/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1/"/>
      <url>/2019/03/27/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1/</url>
      
        <content type="html"><![CDATA[<p>Cython项目(<a href="http://cython.org)已经成为Python领域中创建编译型扩展以及对接C/C++代码的一大途径。" target="_blank" rel="noopener">http://cython.org)已经成为Python领域中创建编译型扩展以及对接C/C++代码的一大途径。</a></p><h3 id="为什么不选Python"><a href="#为什么不选Python" class="headerlink" title="为什么不选Python"></a>为什么不选Python</h3><p>虽然Python非常适合构建计算密集型科学应用程序以及几乎各种各样的通用系统,但它对于不少应用场景仍然力有不逮。</p><p>由于Python是一种解释型编程语言,因此大部分Python代码都要比用编译型语言(比如 Java和C++)编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱,因此许多人也愿意在这里做一些权衡。但是,在那些要求延迟非常小的应用程序中(例如高频交易系统),为了尽最大可能地优化性能,耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p><p>对于高并发、多线程的应用程序而言(尤其是拥有许多计算密集型线程的应用程序),Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁(Global Interpreter Lock,GIL)的东西,这是一种防止解释器同时执行多条Python字节码指令的机制。（作注:GIL实质上属于Cython解释器所使用的同步线程的一种机制，使得时刻仅有一个线程在执行。具体的问题剖析可见<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">该博文</a>）</p><p>虽然很多人数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上,但是仍然有一些情况需要用单进程多线程系统来解决。</p><p>这并不是说Python不能执行真正的多线程并行代码,只不过这些代码不能在单个Python进程中执行而已。比如说,Cython项目可以集成OpenMP(一个用于并行计算的C框架)以实现并行处理循环进而大幅度提高数值算法的速度。</p><h3 id="重要的Python库"><a href="#重要的Python库" class="headerlink" title="重要的Python库"></a>重要的Python库</h3><p>考虑到那些还不太了解Python科学计算生态系统和库的读者,下面我先对各个库做一个简单的介绍。</p><h4 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h4><p>NumPy(Numerical Python的简称)是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能(不限于此):</p><ul><li>快速高效的多维数组对象ndarray。</li><li>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</li><li>用于读写硬盘上基于数组的数据集的工具。</li><li>线性代数运算、傅里叶变换,以及随机数生成。</li><li>用于将C、C++、Fortran代码集成到Python的工具。</li></ul><p>除了为Python提供快速的数组处理能力,NumPy在数据分析方面还有另外一个主要作用,即作为在算法之间传递数据的容器。对于数值型数据,NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外,由低级语言(比如C和Fortran)编写的库可以直接操作NumPy数组中的数据,无需进行任何数据复制工作。</p><h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>pandas提供了使我们能够快速便捷地处理结构化数据的大量数据结构和函数。你很快就会发现,它是使Python成为强大而高效的数据分析环境的重要因素之一。本书用得最多的pandas对象是DataFrame,它是一个面向列(column-oriented)的二维表结构,且含有行标和列标.</p><p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库(如SQL)灵活的数据处理功能。它提供了复杂精细的索引功能,以便更为便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。pandas将是我在本书中使用的主要工具。</p><p>对于金融行业的用户,pandas提供了大量适用于金融数据的高性能时间序列功能和工具。适用于金融数据分析应用的工具。</p><p>R的data.frame对象所提供的功能只是DataFrame对象所提供的功能的一个子集。</p><p>pandas这个名字本身源自于panel  data(面板数据,这是计量经济学中关于多维结构化数据集的一个术语)以及Python data analysis(Python数据分析)。</p><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><p>matplotlib是最流行的用于绘制数据图表的Python库。它非常适合创建出版物上用的图表。它跟IPython结合得很好,因而提供了一种非常好用的交互式数据绘图环境。绘制的图表也是交互式的,你可以利用绘图窗口中的工具栏放大图表中的某个区域或对整个图表进行平移浏览。</p><h4 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h4><p>IPython是Python科学计算标准工具集的组成部分,它将其他所有的东西联系到了一起。它为交互式和探索式计算提供了一个强健而高效的环境。它是一个增强的Python shell,目的是提高编写、测试、调试Python代码的速度。它主要用于交互式数据处理和利用matplotlib对数据进行可视化处理。我在用Python编程时,经常会用到IPython,包括运行、调试和测试代码。</p><p>除标准的基于终端的IPython shell外,该项目还提供了:</p><ul><li>一个类似于Mathematica的HTML笔记本(通过Web浏览器连接IPython,稍后将对此进行详细介绍)。</li><li>一个基于Q+框架的GUI控制台,其中含<br>有绘图、多行编辑以及语法高亮显示等功能。</li><li>用于交互式并行和分布式计算的基础架<br>构。</li></ul><p>我将在一章中专门讲解IPython,详细地介绍其大部分功能。强烈建议在阅读本书的过程中使用IPython。</p><h4 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h4><p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合,主要包括下面这些包:</p><ul><li>scipy.integrate:数值积分例程和微分方程求解器。</li><li>scipy.linalg:扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li><li>scipy.optimize:函数优化器(最小化器)以及根查找算法。</li><li>scipy.signal:信号处理工具。</li><li>scipy.sparse:稀疏矩阵和稀疏线性系统求解器。</li><li>scipy.special:SPECFUN(这是一个实现了许多常用数学函数(如伽玛函数)的Fortran库)的包装器。</li><li>scipy.stats:标准连续和离散概率分布(如密度函数、采样器、连续分布函数等)、各种统计检验方法,以及更好的描述统计法。</li><li>scipy.weave:利用内联C++代码加速数组计算的工具。</li></ul><p>NumPy跟SciPy的有机结合完全可以替代MATLAB的计算功能(包括其插件工具箱)。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于购置硬盘的相关注意点</title>
      <link href="/2019/03/22/%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2019/03/22/%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>最近在意硬盘选购的问题，刚好有视频指导，这里贴上B站内有中文翻译的<a href="https://www.bilibili.com/video/av46775323" target="_blank" rel="noopener">视频链接</a>,以下将视频内的内容进行删减总结(其实就是自己看英文字幕照着翻译后对比中文官翻修改，滑稽)，Mark住留作往后参考食用，进入正文。</p><p>其实大家不难意识到，现在你所使用的电子设备存储空间正以惊人的速度迅速被填补，其空间占用被视频、游戏以及大量的图像仓库所充斥。</p><p>当下比较热门的解决方式就是将额外的数据上传至云端，但是这种解决方法其实受限于可能需要的每月云端收费服务以及潜在的受限于网速的要求。</p><p>所以去购置一个专用的独立外置存储设备不失为另外一种方便的选择。</p><h3 id="Part-1-NMVe-or-SATA"><a href="#Part-1-NMVe-or-SATA" class="headerlink" title="Part 1. NMVe or SATA"></a>Part 1. NMVe or SATA</h3><p>从简易的U盘到一批存储服务器，其实都属于外置存储。</p><p>在贴近我们实际的消费级层面上，最快的还当属支持NVMe（Non-Volatile Memory express，是一个逻辑设备接口规范）的外置硬盘(SSD)或者硬盘盒。通过它，你可以用外置接口连接M.2 SSD等内置硬盘。它相较于旧时的SATA协议要快的多，这里列出两者数据来进行直观的对比：</p><div class="table-container"><table><thead><tr><th>类别</th><th>目前最高连续读写速度</th><th>提供给存储协议对象</th></tr></thead><tbody><tr><td>SATA</td><td>600 MB/s</td><td>为机械硬盘设计</td></tr><tr><td>NVMe</td><td>3000 MB/s</td><td>为固态硬盘设计</td></tr></tbody></table></div><p>因此，当你选购硬盘时，NVMe显然性能上会优秀更多。</p><h3 id="Part-2-接口：USB-3-1-or-雷电3"><a href="#Part-2-接口：USB-3-1-or-雷电3" class="headerlink" title="Part 2. 接口：USB 3.1 or 雷电3"></a>Part 2. 接口：USB 3.1 or 雷电3</h3><p>除了注意你购置的硬盘是否是NVMe的，你还需要注意其他更多的事情。例如你预购入高速的NVMe外置SSD或硬盘盒，你可能需要去弄清它所使用的是何种的接口：是USB  3.1的还是Thunderbolt 3(以下简称雷电3)的，其中，USB 3.1会支持更多的设备，但这当中也有你需要注意的点：</p><div class="table-container"><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>USB 3.0 or 3.1 Gen 1</td><td>5 GBit/s</td></tr><tr><td>USB 3.1 Gen 2</td><td>10 GBit/s</td></tr></tbody></table></div><p>如上述数据所示，显然后者的参数更加的可观，但如果你所遇到的是雷电3接口时，就不必我多说了8，参数如下：</p><div class="table-container"><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>Thunderbolt 3.0(雷电3)</td><td>40 GBit/s</td></tr></tbody></table></div><p>也就是说，市面上最快的PCIe(PCI Express) SSD也有足够的速率不会出现瓶颈。而且雷电3接口支持与电脑的PCIe总线直连，其外置硬盘出现的性能损耗问题在NVMe上要比USB小的多，因为USB硬盘通常要先把数据送至更慢的控制器去。</p><p>但是，雷电3也存在着额外需要考虑的问题，因为很少有电脑去支持它并且大量这类型的SSDs的价格也倾向于比同类的USB接口的SSDs更加的昂贵。所以是选择Thunderbolt 3.0还是USB 3.1 Gen 2，两者在同样搭配上NVMe硬盘的基础上，其实速度都要超过标准的SATA接口连接。</p><p>尽管与NVMe配对的雷电3接口在纸面上显然会更快，但在实际的使用过程中，你可能并不会对他们之间的差异有所察觉，除非你只是一味的使用它来拷贝超大文件。</p><p>另外，你其实更需要去注意的是你选的不要是一个USB 3.1 Gen 1的，因为它甚至不如标准SATA连接</p><div class="table-container"><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>USB 3.1 Gen 1</td><td>5 GBit/s</td></tr><tr><td>SATA III</td><td>6 GBit/s</td></tr></tbody></table></div><p>另外，如果你对以上参数都不太敏感的化，你就只需要再三明确检查它不是USB 2的，虽然它更便宜但同时速度更低于以上任何一种接口，其最大的理论速度仅有480 MBit/s。</p><p>当然，如果你只是需要一个入门级别日常存储ppt演示，对于传输速度的要求不是很在意愿意花时间等候的话，你就不必纠结太多，甚至USB 2.0都可以满足。</p><h3 id="Part-3-其他因素"><a href="#Part-3-其他因素" class="headerlink" title="Part 3. 其他因素"></a>Part 3. 其他因素</h3><p>另外这里有一个误区，就算硬盘或者硬盘盒使用的是新USB TYPE-C接口，其实你也无法据此判断它用的是10 GBit/s的USB 3.1还是雷电3 ！！！</p><p>因为USB-C只是一个物理接口而已，它其实也可以使用更慢的数据传输协议，所以别光看外部物理接口就认为没有问题，还是需要花时间多看看参数才是。</p><p>除此之外，金属外壳的硬盘或硬盘盒可以辅助散热，这一点也是挺有用的。</p><p>但只要你购置的硬盘支持10 GBit或更高速度的产品，与内置硬盘相比就不会有太大的性能损失，除非你就是一个一天到晚喜欢测文件传输速度的人。</p>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课前准备—认识XML</title>
      <link href="/2019/01/26/%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%E2%80%94%E8%AE%A4%E8%AF%86XML/"/>
      <url>/2019/01/26/%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%E2%80%94%E8%AE%A4%E8%AF%86XML/</url>
      
        <content type="html"><![CDATA[<h4 id="认识XML"><a href="#认识XML" class="headerlink" title="认识XML"></a>认识XML</h4><p>XML是对HTML的补充,它不会替代 HTML,在大多数Web应用程序中,XML用于传输数据,而HTML用于格式化并显示数据。</p><p>XML是独立于软件和硬件的信息传输工具。(以纯文本格式进行存储)</p><p>XML指可扩展标记语言（eXtensible Markup Language）,XML被设计用来传输和存储数据。</p><p>XML标签没有被预定义,您需要自行定义标签。</p><h4 id="XML把数据从HTML分离"><a href="#XML把数据从HTML分离" class="headerlink" title="XML把数据从HTML分离"></a>XML把数据从HTML分离</h4><p>如果您需要在HTML文档中显示动态数据,那么每当数据改变时将花费大量的时间来编辑HTML。</p><p>通过XML,数据能够存储在独立的XML文件中。这样您就可以专注于使用HTML/CSS进行显示和布局,并确保修改底层数据不再需要对HTML进行任何的改变。</p><p>通过使用几行JavaScript代码,您就可以读取一个外部XML文件,并更新您的网页的数据内容。</p><h4 id="XML树结构"><a href="#XML树结构" class="headerlink" title="XML树结构"></a>XML树结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>第一行是XML声明。它定义XML的版本（1.0）和所使用的编码（ISO-8859-1=Latin-1/西欧字符集）。</p><p>下一行描述文档的根元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;note&gt;</span><br></pre></td></tr></table></figure></p><p>接下来4行描述根的4个子元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>最后一行定义根元素的结尾：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>总结就是,XML文档必须包含根元素。该元素是所有其他元素的父元素。XML文档中的元素形成了一棵文档树。这棵树从根部开始,并扩展到树的最底端。所有的元素都可以有子元素：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">&lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></p><p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p><h4 id="XML-语法规则"><a href="#XML-语法规则" class="headerlink" title="XML 语法规则"></a>XML 语法规则</h4><p>在HTML中,某些元素不必有一个关闭标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中,省略关闭标签是非法的。所有元素都必须有关闭标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>XML标签对大小写敏感。</p><p>在HTML中,常会看到没有正确嵌套的元素：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中，所有元素都必须彼此正确地嵌套：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure></p><p>XML文档必须有根元素。</p><p>XML 属性值必须加引号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;note date=&quot;12/11/2007&quot;&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>实体引用.</p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd10c1ed59924643.jpg" class="lozad"></p><p>注释：在XML中,只有字符”&lt;”和”&amp;”确实是非法的。大于号是合法的,但是用实体引用来代替它是一个好习惯。XML中的注释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- something code --&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中,文档中的空格不会被删减。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> C# </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小废的Introduction</title>
      <link href="/2019/01/21/%E5%B0%8F%E5%BA%9F%E7%9A%84Introduction/"/>
      <url>/2019/01/21/%E5%B0%8F%E5%BA%9F%E7%9A%84Introduction/</url>
      
        <content type="html"><![CDATA[<p>起初从同学那里了解到hexo以后，就一直有一个建站的念头，一个专属于自己的博客网站，这应该是我现下最想完成的一件事情吧，所以借着这次假期的机会，我依照着教程搭建了现在的小废在不在、。</p><p>目前的样式还基本上与范例没有多大的差别，所以需要后期自己的自主学习使他拥有自己的个性，就像看到前辈们指出的那样，如果发现有同一主题出现在两个博客网站里，就要开始筹措着换点新花样使其与众不同。</p><a id="more"></a><p>建立这个网站的初衷其实不单只是练练手而已，这个网站基本上也会伴随着我一直走下去，会不断的通过学习去增加新的功能，去丰富完善界面，当然，这今后也将作为我随时更新自己生活学习娱乐记录的处所，算是自己私人的小小空间吧。</p><p>就说这么多吧，一切都有待自己去实践才有说服力，希望自己真的能对得起自己最初的梦想。</p><p>加油，我是小废，我要走的路还有很长很长，以上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
