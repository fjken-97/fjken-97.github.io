<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>python数据分析[1]</title>
      <link href="/2019/03/27/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1/"/>
      <url>/2019/03/27/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1/</url>
      
        <content type="html"><![CDATA[<p>Cython项目(<a href="http://cython.org)已经成为Python领域中创建编译型扩展以及对接C/C++代码的一大途径。" target="_blank" rel="noopener">http://cython.org)已经成为Python领域中创建编译型扩展以及对接C/C++代码的一大途径。</a></p><h3 id="为什么不选Python"><a href="#为什么不选Python" class="headerlink" title="为什么不选Python"></a>为什么不选Python</h3><p>虽然Python非常适合构建计算密集型科学应用程序以及几乎各种各样的通用系统,但它对于不少应用场景仍然力有不逮。</p><p>由于Python是一种解释型编程语言,因此大部分Python代码都要比用编译型语言(比如 Java和C++)编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱,因此许多人也愿意在这里做一些权衡。但是,在那些要求延迟非常小的应用程序中(例如高频交易系统),为了尽最大可能地优化性能,耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p><p>对于高并发、多线程的应用程序而言(尤其是拥有许多计算密集型线程的应用程序),Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁(Global Interpreter Lock,GIL)的东西,这是一种防止解释器同时执行多条Python字节码指令的机制。（作注:GIL实质上属于Cython解释器所使用的同步线程的一种机制，使得时刻仅有一个线程在执行。具体的问题剖析可见<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">该博文</a>）</p><p>虽然很多人数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上,但是仍然有一些情况需要用单进程多线程系统来解决。</p><p>这并不是说Python不能执行真正的多线程并行代码,只不过这些代码不能在单个Python进程中执行而已。比如说,Cython项目可以集成OpenMP(一个用于并行计算的C框架)以实现并行处理循环进而大幅度提高数值算法的速度。</p><h3 id="重要的Python库"><a href="#重要的Python库" class="headerlink" title="重要的Python库"></a>重要的Python库</h3><p>考虑到那些还不太了解Python科学计算生态系统和库的读者,下面我先对各个库做一个简单的介绍。</p><h4 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h4><p>NumPy(Numerical Python的简称)是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能(不限于此):</p><ul><li>快速高效的多维数组对象ndarray。</li><li>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</li><li>用于读写硬盘上基于数组的数据集的工具。</li><li>线性代数运算、傅里叶变换,以及随机数生成。</li><li>用于将C、C++、Fortran代码集成到Python的工具。</li></ul><p>除了为Python提供快速的数组处理能力,NumPy在数据分析方面还有另外一个主要作用,即作为在算法之间传递数据的容器。对于数值型数据,NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外,由低级语言(比如C和Fortran)编写的库可以直接操作NumPy数组中的数据,无需进行任何数据复制工作。</p><h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>pandas提供了使我们能够快速便捷地处理结构化数据的大量数据结构和函数。你很快就会发现,它是使Python成为强大而高效的数据分析环境的重要因素之一。本书用得最多的pandas对象是DataFrame,它是一个面向列(column-oriented)的二维表结构,且含有行标和列标.</p><p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库(如SQL)灵活的数据处理功能。它提供了复杂精细的索引功能,以便更为便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。pandas将是我在本书中使用的主要工具。</p><p>对于金融行业的用户,pandas提供了大量适用于金融数据的高性能时间序列功能和工具。适用于金融数据分析应用的工具。</p><p>R的data.frame对象所提供的功能只是DataFrame对象所提供的功能的一个子集。</p><p>pandas这个名字本身源自于panel  data(面板数据,这是计量经济学中关于多维结构化数据集的一个术语)以及Python data analysis(Python数据分析)。</p><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><p>matplotlib是最流行的用于绘制数据图表的Python库。它非常适合创建出版物上用的图表。它跟IPython结合得很好,因而提供了一种非常好用的交互式数据绘图环境。绘制的图表也是交互式的,你可以利用绘图窗口中的工具栏放大图表中的某个区域或对整个图表进行平移浏览。</p><h4 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h4><p>IPython是Python科学计算标准工具集的组成部分,它将其他所有的东西联系到了一起。它为交互式和探索式计算提供了一个强健而高效的环境。它是一个增强的Python shell,目的是提高编写、测试、调试Python代码的速度。它主要用于交互式数据处理和利用matplotlib对数据进行可视化处理。我在用Python编程时,经常会用到IPython,包括运行、调试和测试代码。</p><p>除标准的基于终端的IPython shell外,该项目还提供了:</p><ul><li>一个类似于Mathematica的HTML笔记本(通过Web浏览器连接IPython,稍后将对此进行详细介绍)。</li><li>一个基于Q+框架的GUI控制台,其中含<br>有绘图、多行编辑以及语法高亮显示等功能。</li><li>用于交互式并行和分布式计算的基础架<br>构。</li></ul><p>我将在一章中专门讲解IPython,详细地介绍其大部分功能。强烈建议在阅读本书的过程中使用IPython。</p><h4 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h4><p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合,主要包括下面这些包:</p><ul><li>scipy.integrate:数值积分例程和微分方程求解器。</li><li>scipy.linalg:扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li><li>scipy.optimize:函数优化器(最小化器)以及根查找算法。</li><li>scipy.signal:信号处理工具。</li><li>scipy.sparse:稀疏矩阵和稀疏线性系统求解器。</li><li>scipy.special:SPECFUN(这是一个实现了许多常用数学函数(如伽玛函数)的Fortran库)的包装器。</li><li>scipy.stats:标准连续和离散概率分布(如密度函数、采样器、连续分布函数等)、各种统计检验方法,以及更好的描述统计法。</li><li>scipy.weave:利用内联C++代码加速数组计算的工具。</li></ul><p>NumPy跟SciPy的有机结合完全可以替代MATLAB的计算功能(包括其插件工具箱)。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于购置硬盘的相关注意点</title>
      <link href="/2019/03/22/%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2019/03/22/%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>最近在意硬盘选购的问题，刚好有视频指导，这里贴上B站内有中文翻译的<a href="https://www.bilibili.com/video/av46775323" target="_blank" rel="noopener">视频链接</a>,以下将视频内的内容进行删减总结(其实就是自己看英文字幕照着翻译后对比中文官翻修改，滑稽)，Mark住留作往后参考食用，进入正文。</p><p>其实大家不难意识到，现在你所使用的电子设备存储空间正以惊人的速度迅速被填补，其空间占用被视频、游戏以及大量的图像仓库所充斥。</p><p>当下比较热门的解决方式就是将额外的数据上传至云端，但是这种解决方法其实受限于可能需要的每月云端收费服务以及潜在的受限于网速的要求。</p><p>所以去购置一个专用的独立外置存储设备不失为另外一种方便的选择。</p><h3 id="Part-1-NMVe-or-SATA"><a href="#Part-1-NMVe-or-SATA" class="headerlink" title="Part 1. NMVe or SATA"></a>Part 1. NMVe or SATA</h3><p>从简易的U盘到一批存储服务器，其实都属于外置存储。</p><p>在贴近我们实际的消费级层面上，最快的还当属支持NVMe（Non-Volatile Memory express，是一个逻辑设备接口规范）的外置硬盘(SSD)或者硬盘盒。通过它，你可以用外置接口连接M.2 SSD等内置硬盘。它相较于旧时的SATA协议要快的多，这里列出两者数据来进行直观的对比：</p><table><thead><tr><th>类别</th><th>目前最高连续读写速度</th><th>提供给存储协议对象</th></tr></thead><tbody><tr><td>SATA</td><td>600 MB/s</td><td>为机械硬盘设计</td></tr><tr><td>NVMe</td><td>3000 MB/s</td><td>为固态硬盘设计</td></tr></tbody></table><p>因此，当你选购硬盘时，NVMe显然性能上会优秀更多。</p><h3 id="Part-2-接口：USB-3-1-or-雷电3"><a href="#Part-2-接口：USB-3-1-or-雷电3" class="headerlink" title="Part 2. 接口：USB 3.1 or 雷电3"></a>Part 2. 接口：USB 3.1 or 雷电3</h3><p>除了注意你购置的硬盘是否是NVMe的，你还需要注意其他更多的事情。例如你预购入高速的NVMe外置SSD或硬盘盒，你可能需要去弄清它所使用的是何种的接口：是USB  3.1的还是Thunderbolt 3(以下简称雷电3)的，其中，USB 3.1会支持更多的设备，但这当中也有你需要注意的点：</p><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>USB 3.0 or 3.1 Gen 1</td><td>5 GBit/s</td></tr><tr><td>USB 3.1 Gen 2</td><td>10 GBit/s</td></tr></tbody></table><p>如上述数据所示，显然后者的参数更加的可观，但如果你所遇到的是雷电3接口时，就不必我多说了8，参数如下：</p><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>Thunderbolt 3.0(雷电3)</td><td>40 GBit/s</td></tr></tbody></table><p>也就是说，市面上最快的PCIe(PCI Express) SSD也有足够的速率不会出现瓶颈。而且雷电3接口支持与电脑的PCIe总线直连，其外置硬盘出现的性能损耗问题在NVMe上要比USB小的多，因为USB硬盘通常要先把数据送至更慢的控制器去。</p><p>但是，雷电3也存在着额外需要考虑的问题，因为很少有电脑去支持它并且大量这类型的SSDs的价格也倾向于比同类的USB接口的SSDs更加的昂贵。所以是选择Thunderbolt 3.0还是USB 3.1 Gen 2，两者在同样搭配上NVMe硬盘的基础上，其实速度都要超过标准的SATA接口连接。</p><p>尽管与NVMe配对的雷电3接口在纸面上显然会更快，但在实际的使用过程中，你可能并不会对他们之间的差异有所察觉，除非你只是一味的使用它来拷贝超大文件。</p><p>另外，你其实更需要去注意的是你选的不要是一个USB 3.1 Gen 1的，因为它甚至不如标准SATA连接</p><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>USB 3.1 Gen 1</td><td>5 GBit/s</td></tr><tr><td>SATA III</td><td>6 GBit/s</td></tr></tbody></table><p>另外，如果你对以上参数都不太敏感的化，你就只需要再三明确检查它不是USB 2的，虽然它更便宜但同时速度更低于以上任何一种接口，其最大的理论速度仅有480 MBit/s。</p><p>当然，如果你只是需要一个入门级别日常存储ppt演示，对于传输速度的要求不是很在意愿意花时间等候的话，你就不必纠结太多，甚至USB 2.0都可以满足。</p><h3 id="Part-3-其他因素"><a href="#Part-3-其他因素" class="headerlink" title="Part 3. 其他因素"></a>Part 3. 其他因素</h3><p>另外这里有一个误区，就算硬盘或者硬盘盒使用的是新USB TYPE-C接口，其实你也无法据此判断它用的是10 GBit/s的USB 3.1还是雷电3 ！！！</p><p>因为USB-C只是一个物理接口而已，它其实也可以使用更慢的数据传输协议，所以别光看外部物理接口就认为没有问题，还是需要花时间多看看参数才是。</p><p>除此之外，金属外壳的硬盘或硬盘盒可以辅助散热，这一点也是挺有用的。</p><p>但只要你购置的硬盘支持10 GBit或更高速度的产品，与内置硬盘相比就不会有太大的性能损失，除非你就是一个一天到晚喜欢测文件传输速度的人。</p>]]></content>
      
      
      <categories>
          
          <category> 科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课前准备—认识XML</title>
      <link href="/2019/01/26/%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%E2%80%94%E8%AE%A4%E8%AF%86XML/"/>
      <url>/2019/01/26/%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%E2%80%94%E8%AE%A4%E8%AF%86XML/</url>
      
        <content type="html"><![CDATA[<h4 id="认识XML"><a href="#认识XML" class="headerlink" title="认识XML"></a>认识XML</h4><p>XML是对HTML的补充,它不会替代 HTML,在大多数Web应用程序中,XML用于传输数据,而HTML用于格式化并显示数据。</p><p>XML是独立于软件和硬件的信息传输工具。(以纯文本格式进行存储)</p><p>XML指可扩展标记语言（eXtensible Markup Language）,XML被设计用来传输和存储数据。</p><p>XML标签没有被预定义,您需要自行定义标签。</p><h4 id="XML把数据从HTML分离"><a href="#XML把数据从HTML分离" class="headerlink" title="XML把数据从HTML分离"></a>XML把数据从HTML分离</h4><p>如果您需要在HTML文档中显示动态数据,那么每当数据改变时将花费大量的时间来编辑HTML。</p><p>通过XML,数据能够存储在独立的XML文件中。这样您就可以专注于使用HTML/CSS进行显示和布局,并确保修改底层数据不再需要对HTML进行任何的改变。</p><p>通过使用几行JavaScript代码,您就可以读取一个外部XML文件,并更新您的网页的数据内容。</p><h4 id="XML树结构"><a href="#XML树结构" class="headerlink" title="XML树结构"></a>XML树结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>第一行是XML声明。它定义XML的版本（1.0）和所使用的编码（ISO-8859-1=Latin-1/西欧字符集）。</p><p>下一行描述文档的根元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;note&gt;</span><br></pre></td></tr></table></figure></p><p>接下来4行描述根的4个子元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>最后一行定义根元素的结尾：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>总结就是,XML文档必须包含根元素。该元素是所有其他元素的父元素。XML文档中的元素形成了一棵文档树。这棵树从根部开始,并扩展到树的最底端。所有的元素都可以有子元素：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">&lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></p><p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p><h4 id="XML-语法规则"><a href="#XML-语法规则" class="headerlink" title="XML 语法规则"></a>XML 语法规则</h4><p>在HTML中,某些元素不必有一个关闭标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中,省略关闭标签是非法的。所有元素都必须有关闭标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>XML标签对大小写敏感。</p><p>在HTML中,常会看到没有正确嵌套的元素：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中，所有元素都必须彼此正确地嵌套：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure></p><p>XML文档必须有根元素。</p><p>XML 属性值必须加引号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;note date=&quot;12/11/2007&quot;&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>实体引用.</p><p><img src="https://ws2.sinaimg.cn/large/006B4RNogy1g19yqm2glbj30rb066mx8.jpg" alt="image"></p><p>注释：在XML中,只有字符”&lt;”和”&amp;”确实是非法的。大于号是合法的,但是用实体引用来代替它是一个好习惯。XML中的注释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- something code --&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中,文档中的空格不会被删减。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> C# </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小废的Introduction</title>
      <link href="/2019/01/21/%E5%B0%8F%E5%BA%9F%E7%9A%84Introduction/"/>
      <url>/2019/01/21/%E5%B0%8F%E5%BA%9F%E7%9A%84Introduction/</url>
      
        <content type="html"><![CDATA[<p>起初从同学那里了解到hexo以后，就一直有一个建站的念头，一个专属于自己的博客网站，这应该是我现下最想完成的一件事情吧，所以借着这次假期的机会，我依照着教程搭建了现在的小废在不在、。</p><p>目前的样式还基本上与范例没有多大的差别，所以需要后期自己的自主学习使他拥有自己的个性，就像看到前辈们指出的那样，如果发现有同一主题出现在两个博客网站里，就要开始筹措着换点新花样使其与众不同。</p><a id="more"></a><p>建立这个网站的初衷其实不单只是练练手而已，这个网站基本上也会伴随着我一直走下去，会不断的通过学习去增加新的功能，去丰富完善界面，当然，这今后也将作为我随时更新自己生活学习娱乐记录的处所，算是自己私人的小小空间吧。</p><p>就说这么多吧，一切都有待自己去实践才有说服力，希望自己真的能对得起自己最初的梦想。</p><p>加油，我是小废，我要走的路还有很长很长，以上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
