<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>[Leetcode]5.Longest Palindromic Substring(最长回文子串)</title>
      <link href="/2019/09/01/Leetcode-5-Longest-Palindromic-Substring/"/>
      <url>/2019/09/01/Leetcode-5-Longest-Palindromic-Substring/</url>
      
        <content type="html"><![CDATA[<h1 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="#5.Longest Palindromic Substring"></a>#5.Longest Palindromic Substring</h1><ul><li>难度: 中等</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入: &quot;babad&quot;</span><br><span class="line">输出: &quot;bab&quot;</span><br><span class="line">注意: &quot;aba&quot; 也是一个有效答案。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入: &quot;cbbd&quot;</span><br><span class="line">输出: &quot;bb&quot;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 字符串 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]4.Median of Two Sorted Arrays(寻找两个有序数组的中位数)</title>
      <link href="/2019/09/01/Leetcode-4-Median-of-Two-Sorted-Arrays/"/>
      <url>/2019/09/01/Leetcode-4-Median-of-Two-Sorted-Arrays/</url>
      
        <content type="html"><![CDATA[<h1 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="#4.Median of Two Sorted Arrays"></a>#4.Median of Two Sorted Arrays</h1><ul><li>难度: 困难</li><li><p>题目描述: </p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个大小为 m 和 n 的有序数组 nums1 和 nums2。</span><br><span class="line"></span><br><span class="line">请你找出这两个有序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</span><br><span class="line"></span><br><span class="line">你可以假设 nums1 和 nums2 不会同时为空。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 3]</span><br><span class="line">nums2 = [2]</span><br><span class="line"></span><br><span class="line">则中位数是 2.0</span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">nums1 = [1, 2]</span><br><span class="line">nums2 = [3, 4]</span><br><span class="line"></span><br><span class="line">则中位数是 (2 + 3)/2 = 2.5</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-二分法"><a href="#方法一-二分法" class="headerlink" title="方法一(二分法):"></a>方法一(二分法):</h3></li><li><p>思路: 目标是求得两个数组的中位数且时间复杂度为 O(log(m + n)) 。假设两个数组的长度分别为 m 和 n，则 m+n 的奇偶未定，若 m+n 为奇数，则中位数就为最中间那个数，若为偶数，则中位数就为最中间两个数的平均值。这里运用简化方法，分别找第 (m+n+1) / 2 个，和 (m+n+2) / 2 个，然后求其平均值即可，这样就不用再分奇偶分开讨论。</p><p>  定义一个函数来寻找有序数组中的第K个元素，为了避免拷贝产生新的数组从而增加时间复杂度，使用两个变量i和j分别来标记数组 nums1 和 nums2 的起始位置。要找到数组当中的第 K 个元素，需要借助于二分法，对 K 进行二分寻找第 K/2 个元素，因为各个数组的数组长度不定，所以需要对是否存在第 K/2 个元素进行讨论(必定至少会有一个数组是存在第 K/2 个数字的)。若存在就取出，否则就赋值上一个整型最大值。若数组中不存在 第 K/2 个数，那么就淘汰掉另一个数组中的前 K/2个数即可。因为寻找的是混合数组当中的第 K 个数，当有一个数组长度都达不到 K/2 时，另一个数组当中的前 K/2 个元素必不会被取到。</p><p>  接下来就是二分法的思想，比较两个数组的第 K/2 小的数字 midval1 和 midval2 的大小，若 midval1 &lt; midval2 ，那么说明要找的数肯定不在 nums1 中的前 K/2 个数字，所以可以将其淘汰，将 nums1 的起始位置向后移动 K/2 个，并且此时的K自减 K/2，调用递归。反之若 midval1 &gt; midval2，就淘汰 nums2 中的前 K/2 个数字，并将 nums2 的起始位置向后移动 K/2 个，并且此时的K也自减 K/2，调用递归即可。</p></li><li><p>说明: 特殊讨论 (1) 当某一个数组的起始位置大于等于其数组长度时，说明其所有数字均已经被淘汰了，相当于一个空数组，那么实际上就变成了在另一个数组中找数字。(2) 若 K=1 ，则只需比较 nums1 和 nums2 的起始位置i和j上的数字即可。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int m = nums1.size(),n = nums2.size();</span><br><span class="line">        int left = (m+n+1)/2, right = (m+n+2)/2;</span><br><span class="line">        return (findKth(nums1,0,nums2,0,left)+findKth(nums1,0,nums2,0,right))/2.0;</span><br><span class="line">    &#125;</span><br><span class="line">    int findKth(vector&lt;int&gt;&amp; nums1, int i, vector&lt;int&gt;&amp; nums2, int j, int k)&#123;</span><br><span class="line">        if (i &gt;= nums1.size()) return nums2[j + k - 1];</span><br><span class="line">        if (j &gt;= nums2.size()) return nums1[i + k - 1];</span><br><span class="line">        if (k==1) return min(nums1[i],nums2[j]);</span><br><span class="line">        int mid_val1 = ((i + k/2 - 1) &lt; nums1.size()) ? nums1[i + k/2 - 1]:INT_MAX;</span><br><span class="line">        int mid_val2 = ((j + k/2 - 1) &lt; nums2.size()) ? nums2[j + k/2 - 1]:INT_MAX;</span><br><span class="line">        if(mid_val1 &lt; mid_val2) return findKth(nums1 , i + k/2 , nums2 , j ,k - k/2);</span><br><span class="line">        else return findKth(nums1 , i , nums2 , j + k/2 , k - k/2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二"><a href="#方法二" class="headerlink" title="方法二 :"></a>方法二 :</h3><ul><li>思路: 上面法一使用原数组，同时用了两个变量来分别标记当前的起始位置。法二则直接生成新的数组，这样就不要用起始位置变量了，不过拷贝数组的操作可能会增加时间复杂度，也许会超出限制，不过就算当个思路拓展也是极好的。首先我们要判断数组是否为空，为空的话，直接在另一个数组找第K个即可。还有一种情况是当 K = 1 时，表示我们要找第一个元素，只要比较两个数组的第一个元素，返回较小的那个即可。这里我们分别取出两个数组的第 K/2 个数字的位置坐标i和j，为了避免数组没有第 K/2 个数组的情况，我们每次都和数组长度做比较，取出较小值。这里跟上面的解法有些许不同，上面解法我们直接取出的是值，而这里我们取出的是位置坐标，但是思想都是很类似的。不同在于，上面解法中我们每次固定淘汰 K/2 个数字，而这里我们由于取出了合法的i和j，所以我们每次淘汰i或j个。也可以让 j = k-i，这样也是对的，可能还更好一些，收敛速度可能会更快一些。</li><li>说明:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int m = nums1.size(), n = nums2.size();</span><br><span class="line">        return (findKth(nums1, nums2, (m + n + 1) / 2) + findKth(nums1, nums2, (m + n + 2) / 2)) / 2.0;</span><br><span class="line">    &#125;</span><br><span class="line">    int findKth(vector&lt;int&gt; nums1, vector&lt;int&gt; nums2, int k) &#123;</span><br><span class="line">        if (nums1.empty()) return nums2[k - 1];</span><br><span class="line">        if (nums2.empty()) return nums1[k - 1];</span><br><span class="line">        if (k == 1) return min(nums1[0], nums2[0]);</span><br><span class="line">        int i = min((int)nums1.size(), k / 2), j = min((int)nums2.size(), k / 2);</span><br><span class="line">        if (nums1[i - 1] &gt; nums2[j - 1]) &#123;</span><br><span class="line">            return findKth(nums1, vector&lt;int&gt;(nums2.begin() + j, nums2.end()), k - j);</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            return findKth(vector&lt;int&gt;(nums1.begin() + i, nums1.end()), nums2, k - i);</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法三-迭代形式的二分搜索法"><a href="#方法三-迭代形式的二分搜索法" class="headerlink" title="方法三(迭代形式的二分搜索法):"></a>方法三(迭代形式的二分搜索法):</h3><ul><li>思路: 此题还能用迭代形式的二分搜索法来解，是一种相当巧妙的应用，讲解在<a href="https://discuss.leetcode.com/topic/16797/very-concise-o-log-min-m-n-iterative-solution-with-detailed-explanation/2" target="_blank" rel="noopener">这个帖子</a>中写的十分清楚<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) &#123;</span><br><span class="line">        int m = nums1.size(), n = nums2.size();</span><br><span class="line">        if (m &lt; n) return findMedianSortedArrays(nums2, nums1);</span><br><span class="line">        if (n == 0) return ((double)nums1[(m - 1) / 2] + (double)nums1[m / 2]) / 2.0;</span><br><span class="line">        int left = 0, right = n * 2;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid2 = (left + right) / 2;</span><br><span class="line">            int mid1 = m + n - mid2;</span><br><span class="line">            double L1 = mid1 == 0 ? INT_MIN : nums1[(mid1 - 1) / 2];</span><br><span class="line">            double L2 = mid2 == 0 ? INT_MIN : nums2[(mid2 - 1) / 2];</span><br><span class="line">            double R1 = mid1 == m * 2 ? INT_MAX : nums1[mid1 / 2];</span><br><span class="line">            double R2 = mid2 == n * 2 ? INT_MAX : nums2[mid2 / 2];</span><br><span class="line">            if (L1 &gt; R2) left = mid2 + 1;</span><br><span class="line">            else if (L2 &gt; R1) right = mid2 - 1;</span><br><span class="line">            else return (max(L1, L2) + min(R1, R2)) / 2;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 二分查找 </tag>
            
            <tag> 分治算法 </tag>
            
            <tag> Hard </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]290.Word Pattern(单词规律)</title>
      <link href="/2019/08/31/Leetcode-290-Word-Pattern/"/>
      <url>/2019/08/31/Leetcode-290-Word-Pattern/</url>
      
        <content type="html"><![CDATA[<h1 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="#290. Word Pattern"></a>#290. Word Pattern</h1><ul><li>难度: 简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一种规律 pattern 和一个字符串 str ，判断 str 是否遵循相同的规律。</span><br><span class="line"></span><br><span class="line">这里的 遵循 指完全匹配，例如， pattern 里的每个字母和字符串 str 中的每个非空单词之间存在着双向连接的对应规律。。</span><br></pre></td></tr></table></figure></li><li><p>样例:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例1:</span><br><span class="line"></span><br><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入:pattern = &quot;abba&quot;, str = &quot;dog cat cat fish&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: pattern = &quot;aaaa&quot;, str = &quot;dog cat cat dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 4:</span><br><span class="line"></span><br><span class="line">输入: pattern = &quot;abba&quot;, str = &quot;dog dog dog dog&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 pattern 只包含小写字母， str 包含了由单个空格分隔的小写字母</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-两个HashMap-法"><a href="#方法一-两个HashMap-法" class="headerlink" title="方法一( 两个HashMap 法):"></a>方法一( 两个HashMap 法):</h3></li><li>思路: 用两个 HashMap 来完成，分别将字符和单词都映射到当前的位置加1，注意这里需要加1就是为了避免默认映射值0，因为 C++ 中的 HashMap 的机制是若访问一个不存在的 key 值，会默认建立一个映射值为0的映射。那么我们在遇到新字符和单词时，首先看 i 是否已经是 n 了，若相等了，说明此时 pattern 中的字符已经用完了，而 str 中还有多余的单词，这样是无法建立一对一映射的，直接返回 false。还有当两个 HashMap 的映射值不相同时也返回 false，否则我们同时建立单词和 pattern 字符和当前位置加1之间的映射，循环推出后还是要检测 i 是否和 n 相等;</li><li>说明: 注意字符串的操作，利用 istringstream in(str) 将原本的字符串按以空格为间隔的串流输入(需注意加上头文件<sstream>)<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordPattern(string pattern, string str) &#123;</span><br><span class="line">        unordered_map&lt;char,int&gt;pat_map;</span><br><span class="line">        unordered_map&lt;string,int&gt;str_map;</span><br><span class="line">        istringstream in(str);</span><br><span class="line">        int i = 0;</span><br><span class="line">        for(string word;in&gt;&gt;word;++i)&#123;</span><br><span class="line">            if(i==pattern.size()||pat_map[pattern[i]]!=str_map[word]) return false;</span><br><span class="line">            pat_map[pattern[i]]=i+1;</span><br><span class="line">            str_map[word]=i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        return i==pattern.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></sstream></li></ul><h3 id="方法二-HashMap-法"><a href="#方法二-HashMap-法" class="headerlink" title="方法二( HashMap 法):"></a>方法二( HashMap 法):</h3><ul><li>思路: 求单词字符串中单词出现的规律是否符合模式字符串中的规律。那么首先想到就是用 HashMap 来做，建立模式字符串中每个字符和单词字符串每个单词之间的映射，而且这种映射必须是一对一关系的，不能 ‘a’ 和 ‘b’ 同时对应 ‘dog’，也不能 ‘a’ 同时对应到 ‘dog’ 和 ‘cat’，所以我们在碰到一个新字符时，首先检查其是否在 HashMap 中出现，若出现，其映射的单词若不是此时对应的单词，则返回 false。如果没有在 HashMap 中出现，我们还要遍历一遍 HashMap，看新遇到的单词是否已经是其中的映射，若已经有其他映射，直接返回 false，如果没有，再跟新遇到的字符建立映射。最后循环退出后，要检查此时的 i 是否和 n 相同，这是检查一对一映射的最后一步，因为当 str 中的单词处理完了之后，pattern 中就不能有多余的字符了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool wordPattern(string pattern, string str) &#123;</span><br><span class="line">        unordered_map&lt;char, string&gt; m;</span><br><span class="line">        istringstream in(str);</span><br><span class="line">        int i = 0, n = pattern.size();</span><br><span class="line">        for (string word; in &gt;&gt; word; ++i) &#123;</span><br><span class="line">            if (i &gt;= n) continue;</span><br><span class="line">            if (m.count(pattern[i])) &#123;</span><br><span class="line">                if (m[pattern[i]] != word) return false;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                for (auto a : m) &#123;</span><br><span class="line">                    if (a.second == word) return false;</span><br><span class="line">                &#125;</span><br><span class="line">                m[pattern[i]] = word;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return i == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]205.Isomorphic Strings(同构字符串)</title>
      <link href="/2019/08/31/Leetcode-205-Isomorphic-Strings/"/>
      <url>/2019/08/31/Leetcode-205-Isomorphic-Strings/</url>
      
        <content type="html"><![CDATA[<h1 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="#205. Isomorphic Strings"></a>#205. Isomorphic Strings</h1><ul><li>难度：简单</li><li><p>题目描述:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串 s 和 t，判断它们是否是同构的。</span><br><span class="line"></span><br><span class="line">如果 s 中的字符可以被替换得到 t ，那么这两个字符串是同构的。</span><br><span class="line"></span><br><span class="line">所有出现的字符都必须用另一个字符替换，同时保留字符的顺序。两个字符不能映射到同一个字符上，但字符可以映射自己本身。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;egg&quot;, t = &quot;add&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;foo&quot;, t = &quot;bar&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: s = &quot;paper&quot;, t = &quot;title&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">说明: 你可以假设 s 和 t 具有相同的长度。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路：<br>根据一对一映射的特点，我们需要用两个哈希表分别来记录原字符串和目标字符串中字符出现情况，由于ASCII码只有256个字符，所以我们可以用一个256大小的数组来代替哈希表，并初始化为0，我们遍历原字符串，分别从源字符串和目标字符串取出一个字符，然后分别在两个哈希表中查找其值，若不相等，则返回false，若相等，将其值更新为i + 1，因为默认的值是0，所以我们更新值为i + 1，这样当 i=0 时，则映射为1，如果不加1的话，那么就无法区分是否更新了<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool isIsomorphic(string s, string t) &#123;</span><br><span class="line">        int m1[256] = &#123;0&#125;, m2[256] = &#123;0&#125;;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (m1[s[i]] != m2[t[i]]) return false;</span><br><span class="line">            m1[s[i]] = i + 1;</span><br><span class="line">            m2[t[i]] = i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]3.Longest Substring Without Repeating Characters(无重复字符的最长子串)</title>
      <link href="/2019/08/30/Leetcode-3-Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2019/08/30/Leetcode-3-Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<h1 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="#3.Longest Substring Without Repeating Characters"></a>#3.Longest Substring Without Repeating Characters</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个字符串，请你找出其中不含有重复字符的最长子串的长度。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line"></span><br><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line"></span><br><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br><span class="line"></span><br><span class="line">示例 3:</span><br><span class="line"></span><br><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line"></span><br><span class="line">请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一-HashMap-法"><a href="#方法一-HashMap-法" class="headerlink" title="方法一( HashMap 法):"></a>方法一( HashMap 法):</h3></li><li>思路：这道题字符出现的位置很重要，所以可以使用 HashMap 来建立字符和其出现位置之间的映射。实际上是维护了一个滑动窗口，窗口内的都是没有重复的字符，需要尽可能的扩大窗口的大小。由于窗口在不停向右滑动，所以只关心每个字符最后出现的位置，并建立映射。窗口的右边界就是当前遍历到的字符的位置，为了求出窗口的大小，需要一个变量 left 来指向滑动窗口的左边界，这样，如果当前遍历到的字符从未出现过，那么直接扩大右边界，如果之前出现过，那么就分两种情况，在或不在滑动窗口内，如果不在滑动窗口内，那么就没事，当前字符可以加进来，如果在的话，就需要先在滑动窗口内去掉这个已经出现过的字符了，去掉的方法并不需要将左边界 left 一位一位向右遍历查找，由于 HashMap 已经保存了该重复字符最后出现的位置，所以直接移动 left 指针就可以了( 如果其映射值大于 left 的话，那么更新 left 为当前映射值。然后映射值更新为当前坐标 i ，这样保证了 left 始终为当前边界的前一个位置)。维护一个结果 res，每次用出现过的窗口大小来更新结果 res(计算窗口长度的时候，直接用 i-left 即可，用来更新结果 res )，就可以得到最终结果啦。</li><li>说明: 注意这里是子串，不是子序列，所以必须是连续的。res 用来记录最长无重复子串的长度，left 指向该无重复子串左边的起始位置的前一个，由于是前一个，所以初始化就是 -1 。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt; links;</span><br><span class="line">        int res = 0, left = -1;</span><br><span class="line">        for(int i=0;i&lt;s.size();++i)&#123;</span><br><span class="line">            if(links.count(s[i])&amp;&amp;links[s[i]]&gt;left)&#123;</span><br><span class="line">                left = links[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">            links[s[i]]=i;</span><br><span class="line">            res = max(res,i-left);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-数组法"><a href="#方法二-数组法" class="headerlink" title="方法二(数组法):"></a>方法二(数组法):</h3><ul><li>思路: 该方法为上面解法的精简模式，这里建立一个 256 位大小的整型数组来代替 HashMap，这样做的原因是 ASCII 表共能表示 256 个字符，但是由于键盘只能表示 128 个字符，所以用 128 也行，然后全部初始化为 -1，这样的好处是不用像之前的 HashMap 一样要查找当前字符是否存在映射对了，对于每一个遍历到的字符，直接用其在数组中的值来更新 left，因为默认是 -1，而 left 初始化也是 -1，所以并不会产生错误，这样就省了 if 判断的步骤，其余思路都一样<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        vector&lt;int&gt; m(128, -1);</span><br><span class="line">        int res = 0, left = -1;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            left = max(left, m[s[i]]);</span><br><span class="line">            m[s[i]] = i;</span><br><span class="line">            res = max(res, i - left);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法二-HashSet法"><a href="#方法二-HashSet法" class="headerlink" title="方法二(HashSet法):"></a>方法二(HashSet法):</h3><ul><li>思路: 核心算法和上面的很类似，把出现过的字符都放入 HashSet 中，遇到 HashSet 中没有的字符就加入 HashSet 中并更新结果 res，如果遇到重复的，则从左边开始删字符，直到删到重复的字符停止。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int lengthOfLongestSubstring(string s) &#123;</span><br><span class="line">        int res = 0, left = 0, i = 0, n = s.size();</span><br><span class="line">        unordered_set&lt;char&gt; t;</span><br><span class="line">        while (i &lt; n) &#123;</span><br><span class="line">            if (!t.count(s[i])) &#123;</span><br><span class="line">                t.insert(s[i++]);</span><br><span class="line">                res = max(res, (int)t.size());</span><br><span class="line">            &#125;  else &#123;</span><br><span class="line">                t.erase(s[left++]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> Medium </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]43.Multiply Strings(字符串相乘)</title>
      <link href="/2019/08/28/Leetcode-43-Multiply-Strings/"/>
      <url>/2019/08/28/Leetcode-43-Multiply-Strings/</url>
      
        <content type="html"><![CDATA[<ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个以字符串形式表示的非负整数 num1 和 num2，返回 num1 和 num2 的乘积，它们的乘积也表示为字符串形式。</span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">num1 和 num2 的长度小于110。</span><br><span class="line">num1 和 num2 只包含数字 0-9。</span><br><span class="line">num1 和 num2 均不以零开头，除非是数字 0 本身。</span><br><span class="line">不能使用任何标准库的大数类型（比如 BigInteger）或直接将输入转换为整数来处理。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: num1 = &quot;2&quot;, num2 = &quot;3&quot;</span><br><span class="line">输出: &quot;6&quot;</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: num1 = &quot;123&quot;, num2 = &quot;456&quot;</span><br><span class="line">输出: &quot;56088&quot;</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 基本思路即两数按位相乘后错位相加，这里罗列注意要点: 若 num1 长度为m，num2 长度为n，则 num1 x num2 的长度为 m+n ; num1 和 num2 中任意位置的两个数字相乘，得到的两位数在最终结果中的位置是确定的，比如 num1 中位置为i的数字乘以 num2 中位置为j的数字，那么得到的两位数字的位置为 i+j 和 i+j+1</li><li>说明: 从个位上开始相乘，所以从 num1 和 num2 字符串的尾部开始往前遍历，分别提取出对应位置上的字符，将其转为整型后相乘。然后确定相乘后的两位数所在的位置 p1 和 p2，由于 p2 相较于 p1 是低位，所以我们将得到的两位数 temp 先加到 p2 位置上去，这样可能会导致 p2 位上的数字大于9，所以我们将十位上的数字要加到高位 p1 上去，只将余数留在 p2位置，这样每个位上的数字都变成一位。然后要做的是从高位开始，将数字存入结果res中，记住 leading zeros 要跳过，最后处理下 corner case，即若结果 res 为空，则返回 “0”，否则返回结果 res<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string multiply(string num1, string num2) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int m = num1.size(), n = num2.size();</span><br><span class="line">        vector&lt;int&gt; values(m+n);</span><br><span class="line">        for(int i = m-1; i&gt;=0; --i)&#123;</span><br><span class="line">            for(int j = n-1; j&gt;=0; --j)&#123;</span><br><span class="line">                int temp = (num1[i]-&apos;0&apos;)*(num2[j]-&apos;0&apos;);</span><br><span class="line">                int p1 = i+j,p2 = i+j+1;</span><br><span class="line">                int sum = values[p2] + temp;</span><br><span class="line">                values[p1] += sum / 10;</span><br><span class="line">                values[p2] = sum % 10;                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int val:values)&#123;</span><br><span class="line">            if(!res.empty() || val!=0) res.push_back(val + &apos;0&apos;);</span><br><span class="line">        &#125;</span><br><span class="line">        return res.empty()? &quot;0&quot; : res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode - 数学 - 字符串 - Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]415.Add Strings(字符串相加)</title>
      <link href="/2019/08/28/Leetcode-415-Add-Strings/"/>
      <url>/2019/08/28/Leetcode-415-Add-Strings/</url>
      
        <content type="html"><![CDATA[<ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和。</span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line">num1 和num2 的长度都小于 5100.</span><br><span class="line">num1 和num2 都只包含数字 0-9.</span><br><span class="line">num1 和num2 都不包含任何前导零。</span><br><span class="line">你不能使用任何內建 BigInteger 库， 也不能直接将输入的字符串转换为整数形式。</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路：亦即按位相加的思路，注意字符串的处理<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    string addStrings(string num1, string num2) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        int m = num1.size(),n = num2.size();</span><br><span class="line">        int i = m-1, j = n-1, carry = 0;</span><br><span class="line">        while(i&gt;=0||j&gt;=0)&#123;</span><br><span class="line">            int a = i &gt;= 0?num1[i--]-&apos;0&apos;:0;</span><br><span class="line">            int b = j &gt;= 0?num2[j--]-&apos;0&apos;:0;</span><br><span class="line">            int sum = a + b + carry;</span><br><span class="line">            res.insert(res.begin(),sum % 10 + &apos;0&apos;);</span><br><span class="line">            carry = sum / 10;</span><br><span class="line">        &#125; </span><br><span class="line">        return carry? &quot;1&quot;+res:res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]2.Add Two Numbers(两数相加)</title>
      <link href="/2019/08/27/Leetcode-2-Add-Two-Numbers/"/>
      <url>/2019/08/27/Leetcode-2-Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<h1 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="#2.Add Two Numbers"></a>#2.Add Two Numbers</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</span><br><span class="line"></span><br><span class="line">如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</span><br><span class="line"></span><br><span class="line">您可以假设除了数字 0 之外，这两个数都不会以 0 开头</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路: 创建一个新的链表用于两链表 value 相加结果</li><li>说明: 注意两链表的判空操作，若为空则默认其值为 0 ，且在后续不再进行指针的移位，最后对于进位符 carry 需要进行一次判断，若进位存在而相加结束，则需将进位 (1) 作数最高位。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for singly-linked list.</span><br><span class="line"> * struct ListNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     ListNode *next;</span><br><span class="line"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123;</span><br><span class="line">        ListNode* add2 = new ListNode(-1),*cur = add2;</span><br><span class="line">        int carry = 0;</span><br><span class="line">        while (l1 || l2) &#123;</span><br><span class="line">            int val1 = l1?l1-&gt;val:0; </span><br><span class="line">            int val2 = l2?l2-&gt;val:0; </span><br><span class="line">            int sum = val1 + val2 + carry;</span><br><span class="line">            carry = sum / 10;</span><br><span class="line">            cur-&gt;next = new ListNode(sum % 10);</span><br><span class="line">            if(l1) l1 = l1-&gt;next;</span><br><span class="line">            if(l2) l2 = l2-&gt;next;</span><br><span class="line">            cur = cur-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        if(carry) cur-&gt;next = new ListNode(carry);</span><br><span class="line">        return add2-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="2.Add Two Numbers" data-src="https://i.loli.net/2019/08/27/H75BpQZA3SN8olO.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Medium </tag>
            
            <tag> 链表 </tag>
            
            <tag> 数学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]16.3Sum Closest(最接近的三数之和)</title>
      <link href="/2019/08/27/Leetcode-16-3Sum-Closest/"/>
      <url>/2019/08/27/Leetcode-16-3Sum-Closest/</url>
      
        <content type="html"><![CDATA[<h1 id="16-3Sum-Closest"><a href="#16-3Sum-Closest" class="headerlink" title="#16.3Sum Closest"></a>#16.3Sum Closest</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包括 n 个整数的数组 nums 和 一个目标值 target。找出 nums 中的三个整数，使得它们的和与 target 最接近。返回这三个数的和。假定每组输入只存在唯一答案。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如，给定数组 nums = [-1，2，1，-4], 和 target = 1.</span><br><span class="line"></span><br><span class="line">与 target 最接近的三个数的和为 2. (-1 + 2 + 1 = 2).</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法1"><a href="#方法1" class="headerlink" title="方法1"></a>方法1</h3></li><li>思路：先将数组顺序排序，后定义一个变量 temp 用来记录当前三数和跟给定值之间的差的绝对值，接着遍历数组，通过 left 和 right 指针 来滑动寻找另外两个数，比较并更新差值 temp 和结果和 sum</li><li>说明：因为之前已经顺序排序，所以 left 与 right 的更新由三数之和与 target 之间的比较来进行，三数之和小了就 ++left ，大了就 —right ，使得保证三数之和愈加靠近 target 。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int threeSumClosest(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        int sum = nums[0]+nums[1]+nums[2];</span><br><span class="line">        int temp = abs(sum-target);</span><br><span class="line">        for(int i=0;i&lt;nums.size()-2;++i)&#123;</span><br><span class="line">            int left=i+1,right=nums.size()-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                int three = nums[i]+nums[left]+nums[right];</span><br><span class="line">                if(abs(three-target)&lt;temp)&#123;</span><br><span class="line">                    temp=abs(three-target);</span><br><span class="line">                    sum = three;</span><br><span class="line">                &#125;</span><br><span class="line">                if(three&lt;target) ++left;</span><br><span class="line">                else --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="16.3Sum Closest" data-src="https://i.loli.net/2019/08/27/HbaNw4SOUGs9peV.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 双指针 </tag>
            
            <tag> Medium </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]653.TwoSum-IV-Input-is-a-BST(两数之和IV-输入BST)</title>
      <link href="/2019/08/22/Leetcode-653-TwoSum-IV-Input-is-a-BST/"/>
      <url>/2019/08/22/Leetcode-653-TwoSum-IV-Input-is-a-BST/</url>
      
        <content type="html"><![CDATA[<h1 id="653-Two-Sum-IV-Input-is-a-BST"><a href="#653-Two-Sum-IV-Input-is-a-BST" class="headerlink" title="#653.Two Sum IV-Input is a BST"></a>#653.Two Sum IV-Input is a BST</h1><ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个二叉搜索树和一个目标结果，如果 BST 中存在两个元素且它们的和等于给定的目标结果，则返回 true。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 9</span><br><span class="line"></span><br><span class="line">输出: True</span><br><span class="line"></span><br><span class="line">输入: </span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  3   6</span><br><span class="line"> / \   \</span><br><span class="line">2   4   7</span><br><span class="line"></span><br><span class="line">Target = 28</span><br><span class="line"></span><br><span class="line">输出: False</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法1-HashSet"><a href="#方法1-HashSet" class="headerlink" title="方法1.HashSet"></a>方法1.HashSet</h3></li><li>思路：建立一个HashSet索引，对于当前结点，寻找target与当前节点val之差处是否存在，存在说明两数之和为target找到即返回True，否则将结点值加入HahSet。通过递归调用来遍历整个二叉树，若结点为空即返回false。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> * time: O(n)</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findTarget(TreeNode* root, int k) &#123;</span><br><span class="line">        unordered_set&lt;int&gt; HashSet;</span><br><span class="line">        return tools(root,k,HashSet);</span><br><span class="line">    &#125;</span><br><span class="line">    bool tools(TreeNode* node, int target,unordered_set&lt;int&gt;&amp; s)&#123;</span><br><span class="line">        if(!node) return false;</span><br><span class="line">        if(s.count(target-node-&gt;val)) return true;</span><br><span class="line">        s.insert(node-&gt;val);</span><br><span class="line">        return tools(node-&gt;left,target,s)||tools(node-&gt;right,target,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="653.TwoSumIV-Input is a BST" data-src="https://i.loli.net/2019/08/22/7JhuwqWTen4LFNa.jpg" class="lozad"></p><h3 id="方法2-层序遍历-HashSet"><a href="#方法2-层序遍历-HashSet" class="headerlink" title="方法2. 层序遍历 + HashSet"></a>方法2. 层序遍历 + HashSet</h3><ul><li>思路：改上述递归调用为迭代的方式，换位层序遍历来进行处理，其余核心的HashSet不变。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findTarget(TreeNode* root, int k) &#123;</span><br><span class="line">        if (!root) return false;</span><br><span class="line">        unordered_set&lt;int&gt; st;</span><br><span class="line">        queue&lt;TreeNode*&gt; q&#123;&#123;root&#125;&#125;;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            auto t = q.front(); q.pop();</span><br><span class="line">            if (st.count(k - t-&gt;val)) return true;</span><br><span class="line">            st.insert(t-&gt;val);</span><br><span class="line">            if (t-&gt;left) q.push(t-&gt;left);</span><br><span class="line">            if (t-&gt;right) q.push(t-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="方法3-中序遍历"><a href="#方法3-中序遍历" class="headerlink" title="方法3.中序遍历"></a>方法3.中序遍历</h3><ul><li>思路：将二叉树进行中序遍历得到顺序排列的数组，对于有序数组，可通过左右指针匹配和。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Definition for a binary tree node.</span><br><span class="line"> * struct TreeNode &#123;</span><br><span class="line"> *     int val;</span><br><span class="line"> *     TreeNode *left;</span><br><span class="line"> *     TreeNode *right;</span><br><span class="line"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span><br><span class="line"> * &#125;;</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    bool findTarget(TreeNode* root, int k) &#123;</span><br><span class="line">        vector&lt;int&gt; InorderArray;</span><br><span class="line">        inorder(root,InorderArray);</span><br><span class="line">        for(int left=0,right=InorderArray.size()-1;left&lt;right;)&#123;</span><br><span class="line">            int sum = InorderArray[left]+InorderArray[right];</span><br><span class="line">            if(sum==k) return true;</span><br><span class="line">            else if(sum&lt;k) ++left; /** 或者写作(nums[i] + nums[j] &lt; k) ? ++i : --j;</span><br><span class="line">            else --right;           */</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    void inorder(TreeNode* node,vector&lt;int&gt;&amp; s)&#123;</span><br><span class="line">        if(!node) return;</span><br><span class="line">        inorder(node-&gt;left,s);</span><br><span class="line">        s.push_back(node-&gt;val);</span><br><span class="line">        inorder(node-&gt;right,s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="653.TwoSumIV-Input is a BST(inorder)" data-src="https://i.loli.net/2019/08/22/twWbZcX7V6MovAe.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> Easy </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]15.3Sum(三数之和)</title>
      <link href="/2019/08/21/Leetcode-15-3Sum/"/>
      <url>/2019/08/21/Leetcode-15-3Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="#15. 3Sum"></a>#15. 3Sum</h1><ul><li>难度：中等</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a，b，c ，使得 a + b + c = 0 ？找出所有满足条件且不重复的三元组。</span><br><span class="line"></span><br><span class="line">注意：答案中不可以包含重复的三元组。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">例如, 给定数组 nums = [-1, 0, 1, 2, -1, -4]，</span><br><span class="line"></span><br><span class="line">满足要求的三元组集合为：</span><br><span class="line">[</span><br><span class="line">  [-1, 0, 1],</span><br><span class="line">  [-1, -1, 2]</span><br><span class="line">]</span><br></pre></td></tr></table></figure></li><li><p>解答：</p><h3 id="方法一"><a href="#方法一" class="headerlink" title="方法一:"></a>方法一:</h3></li><li>思路：先确立一个目标的匹配值，然后在后续的数组中寻找两个组合之和为目标匹配值的相反数。对于后续两个组合的搜索，盲目的进行组合因为O(n^2)的关系显然不可取，所以可以通过对有序数组以双指针的方式来以线性时间的复杂度来遍历所有满足题意的两个数组合，所以需要对所给数组先进行一次顺序排序。</li><li>说明：为了更加优化算法，可以进行剪枝操作，首先对数组进行初步筛选，empty与size()<2的优先不予考虑，然后若排序后最后一位<0或第一位>0，也代表该数组不符合考虑范畴。然后当我们进行判断的过程中，当目标匹配对象&gt;0时视为退出条件，因为若目标匹配值&gt;0，则后续的两数组合之和无法得到其相反数。最后还要注意的一点，就是筛选组合的过程中，对于重复的值应当进行跳步处理，避免得到重复结论。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">** time: O(nlogn) 快排nlogn + 搜索n</span><br><span class="line">*/</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;int&gt;&gt; result;</span><br><span class="line">        sort(nums.begin(),nums.end());</span><br><span class="line">        if(nums.empty()||nums.back()&lt;0||nums.front()&gt;0||nums.size()&lt;2) return &#123;&#125;;</span><br><span class="line">        for(int i=0;i&lt;nums.size()-2;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;0) break;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;</span><br><span class="line">            int target = 0 - nums[i];</span><br><span class="line">            int left = i+1 , right = nums.size()-1;</span><br><span class="line">            while(left&lt;right)&#123;</span><br><span class="line">                int sum = nums[left]+nums[right];</span><br><span class="line">                if(sum==target)&#123;</span><br><span class="line">                    result.push_back(&#123;nums[i],nums[left],nums[right]&#125;);</span><br><span class="line">                    while(left&lt;right&amp;&amp;nums[left]==nums[left+1]) left++;</span><br><span class="line">                    while(left&lt;right&amp;&amp;nums[right]==nums[right-1]) right--;</span><br><span class="line">                    left++;</span><br><span class="line">                    right--;</span><br><span class="line">                &#125;</span><br><span class="line">                else if(sum&lt;target) left++;</span><br><span class="line">                else right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></2的优先不予考虑，然后若排序后最后一位<0或第一位></li></ul><p><img alt="15.3Sum(C++)" data-src="https://i.loli.net/2019/08/21/virlf49hnTFLGSQ.jpg" class="lozad"></p><h3 id="方法二-TreeSet去重法"><a href="#方法二-TreeSet去重法" class="headerlink" title="方法二: TreeSet去重法"></a>方法二: TreeSet去重法</h3><ul><li>思路：可以利用 TreeSet 的不能包含重复项的特点来防止重复项的产生，那么就不需要检测数字是否被 fix 过两次,其余思路基本同上<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;vector&lt;int&gt;&gt; threeSum(vector&lt;int&gt;&amp; nums) &#123;</span><br><span class="line">        set&lt;vector&lt;int&gt;&gt; res;</span><br><span class="line">        sort(nums.begin(), nums.end());</span><br><span class="line">        if (nums.empty() || nums.back() &lt; 0 || nums.front() &gt; 0) return &#123;&#125;;</span><br><span class="line">        for (int k = 0; k &lt; (int)nums.size()-2; ++k) &#123;</span><br><span class="line">            if (nums[k] &gt; 0) break;</span><br><span class="line">            int target = 0 - nums[k], left = k + 1, right = (int)nums.size() - 1;</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                if (nums[left] + nums[right] == target) &#123;</span><br><span class="line">                    res.insert(&#123;nums[k], nums[left], nums[right]&#125;);</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) ++left;</span><br><span class="line">                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) --right;</span><br><span class="line">                    ++left; --right;</span><br><span class="line">                &#125; else if (nums[left] + nums[right] &lt; target) ++left;</span><br><span class="line">                else --right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return vector&lt;vector&lt;int&gt;&gt;(res.begin(), res.end());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 双指针 </tag>
            
            <tag> Medium </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]167.Two Sum II-Input array is sorted(两数之和II-输入有序数组)</title>
      <link href="/2019/08/21/Leetcode-167-Two-Sum-II-Input-array-is-sorted/"/>
      <url>/2019/08/21/Leetcode-167-Two-Sum-II-Input-array-is-sorted/</url>
      
        <content type="html"><![CDATA[<h1 id="167-两数之和-II-输入有序数组"><a href="#167-两数之和-II-输入有序数组" class="headerlink" title="#167. 两数之和 II - 输入有序数组"></a>#167. 两数之和 II - 输入有序数组</h1><ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</span><br><span class="line"></span><br><span class="line">函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</span><br><span class="line"></span><br><span class="line">说明:</span><br><span class="line"></span><br><span class="line">返回的下标值（index1 和 index2）不是从零开始的。</span><br><span class="line">你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。</span><br></pre></td></tr></table></figure></li><li><p>样例：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure></li><li><p>解答：</p></li></ul><h3 id="方法1-双指针"><a href="#方法1-双指针" class="headerlink" title="方法1. 双指针"></a>方法1. 双指针</h3><ul><li>思路：使用两个指针，初始分别位于第一个元素和最后一个元素位置，比较这两个元素之和与目标值的大小。如果和等于目标值，我们发现了这个唯一解。如果比目标值小，我们将较小元素指针增加一。如果比目标值大，我们将较大指针减小一。移动指针后重复上述比较知道找到答案。<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * time: O(n)</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        int left=0;</span><br><span class="line">        int right=numbers.size()-1;</span><br><span class="line">        while(left&lt;right)&#123;</span><br><span class="line">            int sum = numbers[left]+numbers[right];</span><br><span class="line">            if(sum==target)&#123;</span><br><span class="line">                return &#123;left+1,right+1&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            else if(sum&lt;target)&#123;</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h3 id="补充解法：二分查找-效率不如上一种"><a href="#补充解法：二分查找-效率不如上一种" class="headerlink" title="补充解法：二分查找(效率不如上一种)"></a>补充解法：二分查找(效率不如上一种)</h3><ul><li>思路: 因为一定有解，而且数组是有序的，那么第一个数字肯定要小于目标值target，那么我们每次用二分法来搜索target - numbers[i]即可<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * time: O(nlgn)</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; numbers, int target) &#123;</span><br><span class="line">        for (int i = 0; i &lt; numbers.size(); ++i) &#123;</span><br><span class="line">            int t = target - numbers[i], left = i + 1, right = numbers.size();</span><br><span class="line">            while (left &lt; right) &#123;</span><br><span class="line">                int mid = left + (right - left) / 2;</span><br><span class="line">                if (numbers[mid] == t) return &#123;i + 1, mid + 1&#125;;</span><br><span class="line">                else if (numbers[mid] &lt; t) left = mid + 1;</span><br><span class="line">                else right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> Easy </tag>
            
            <tag> 双指针 </tag>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Leetcode]1.Tow Sum(两数之和)</title>
      <link href="/2019/08/20/Leetcode-1-Tow-Sum/"/>
      <url>/2019/08/20/Leetcode-1-Tow-Sum/</url>
      
        <content type="html"><![CDATA[<h1 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="#1. 两数之和"></a>#1. 两数之和</h1><ul><li>难度：简单</li><li><p>题目描述：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</span><br><span class="line"></span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</span><br></pre></td></tr></table></figure></li><li><p>样例</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure></li><li><p>解答</p><h3 id="1-方法一-暴力求解，通过两层循环寻找对应解答"><a href="#1-方法一-暴力求解，通过两层循环寻找对应解答" class="headerlink" title="1. 方法一(暴力求解，通过两层循环寻找对应解答)"></a>1. 方法一(暴力求解，通过两层循环寻找对应解答)</h3></li><li>思路：从第0位开始，向后遍历找到与当前位置之和等于目标数值的另一个位置为止，或遍历到达数组尾部后初始位置向后移动一位继续穷举遍历，直到初始位置达到数组尾部，得到该数组中不存在与目标值相符的位置组<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * time: O(n^2) space: O(n)</span><br><span class="line"> * Note: The returned array must be malloced, assume caller calls free().</span><br><span class="line"> * Language: C</span><br><span class="line"> */</span><br><span class="line">int* twoSum(int* nums, int numsSize, int target, int* returnSize)&#123;</span><br><span class="line">    *returnSize = 2;</span><br><span class="line">    for(int i=0;i&lt;numsSize-1;i++)&#123;</span><br><span class="line">        for(int j=i+1;j&lt;=numsSize-1;j++)&#123;</span><br><span class="line">            int temp = nums[i]+nums[j];</span><br><span class="line">            if(temp==target)&#123;</span><br><span class="line">                int* result = (int*)malloc(sizeof(int)* *returnSize);</span><br><span class="line">                result[0]=i;</span><br><span class="line">                result[1]=j;</span><br><span class="line">                return result;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return NULL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="1.TwoSum_ViolentSolution(C)" data-src="https://i.loli.net/2019/08/20/B76WHUReXzwC4oG.jpg" class="lozad"></p><h3 id="2-方法二-HashMap法"><a href="#2-方法二-HashMap法" class="headerlink" title="2. 方法二(HashMap法)"></a>2. 方法二(HashMap法)</h3><ul><li>思路: 利用HashMap进行空间换时间，首先遍历一遍数组，建立 HashMap 映射，然后再遍历一遍该数组，开始查找，找到则记录 index，否则返回NULL。</li><li><p>说明: unordered_map.count(i) 用于检验该处是否存在值; hash_map[t]!=i 用于排除原位重复匹配;</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * time: O(n) sapce: O(n)</span><br><span class="line"> * Language: C++</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int, int&gt; hash_map;</span><br><span class="line">        vector&lt;int&gt; res;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            hash_map[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            int t = target - nums[i];</span><br><span class="line">            if (hash_map.count(t) &amp;&amp; hash_map[t] != i) &#123;</span><br><span class="line">                res.push_back(i);</span><br><span class="line">                res.push_back(hash_map[t]);</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>上述代码可以进行简化，在一次遍历的过程中取寻找目标</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/**</span><br><span class="line"> * time: O(n) sapce: O(n)</span><br><span class="line"> */</span><br><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) &#123;</span><br><span class="line">        unordered_map&lt;int,int&gt;hash_map;</span><br><span class="line">        vector&lt;int&gt;result;</span><br><span class="line">        for(int i=0;i&lt;nums.size();i++)&#123;</span><br><span class="line">            int t = target - nums[i];</span><br><span class="line">            if(hash_map.count(t))&#123;</span><br><span class="line">                return &#123;hash_map[t],i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">            hash_map[nums[i]]=i;</span><br><span class="line">        &#125;</span><br><span class="line">        return &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><p><img alt="1.TwoSum_HashMap(C++)" data-src="https://i.loli.net/2019/08/20/sXdQ62bkJYO1Laf.jpg" class="lozad"></p><ul><li>[附]若所给数组为排序后的顺序数组，则可以通过left与right指针左右并行向中间靠拢进行和的匹配，当 left==right 时，则不存在返回NULL。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Leetcode </tag>
            
            <tag> 数组 </tag>
            
            <tag> 哈希表 </tag>
            
            <tag> Easy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析-3</title>
      <link href="/2019/06/10/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-3/"/>
      <url>/2019/06/10/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-3/</url>
      
        <content type="html"><![CDATA[<h3 id="NumPy简介"><a href="#NumPy简介" class="headerlink" title="NumPy简介"></a>NumPy简介</h3><p>NumPy(Numerical Python简称)，高性能科学计算和数据分析的基础包。</p><p>部分功能介绍如下图所示<br><img alt="numpy功能" data-src="https://i.loli.net/2019/06/10/5cfe1c687655064641.jpg" class="lozad"></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br></pre></td></tr></table></figure><h4 id="Numpy的ndarray-一种多维数组对象"><a href="#Numpy的ndarray-一种多维数组对象" class="headerlink" title="Numpy的ndarray:一种多维数组对象"></a>Numpy的ndarray:一种多维数组对象</h4><p><img alt="ndarray相关" data-src="https://i.loli.net/2019/06/10/5cfe2290ccdca77085.jpg" class="lozad"></p><p><img alt="numpy数据类型" data-src="https://i.loli.net/2019/06/10/5cfe23914c6fb91125.jpg" class="lozad"><br><img alt="numpy数据类型2" data-src="https://i.loli.net/2019/06/10/5cfe262d6e45d27503.jpg" class="lozad"></p><p>不同大小数组之间的运算叫做广播(broadcasting)</p><h5 id="基本的索引和切片"><a href="#基本的索引和切片" class="headerlink" title="基本的索引和切片"></a>基本的索引和切片</h5><p>数组的切片是原始数据的视图，对切片的操作将直接反映到源数组上。</p><p><code>[x:y]</code>切片取到的是x到y-1字段内的数据，y处数据无法取到。</p><p><img alt="切片索引2维数组示例" data-src="https://i.loli.net/2019/06/10/5cfe2ca5e087324849.jpg" class="lozad"></p><p>关键字and和or在布尔型数组中无效，考虑使用逻辑运算符</p><h5 id="矩阵转置和轴对称"><a href="#矩阵转置和轴对称" class="headerlink" title="矩阵转置和轴对称"></a>矩阵转置和轴对称</h5><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">array.T:转置</span><br><span class="line">np.dot(X,Y):X和Y的矩阵内积</span><br></pre></td></tr></table></figure><h4 id="通用函数：快速的元素级数组函数"><a href="#通用函数：快速的元素级数组函数" class="headerlink" title="通用函数：快速的元素级数组函数"></a>通用函数：快速的元素级数组函数</h4><p><img alt="一元ufunc" data-src="https://i.loli.net/2019/06/10/5cfe4a956172572253.jpg" class="lozad"></p><p><img alt="二元ufunc" data-src="https://i.loli.net/2019/06/10/5cfe4b0bc9b7167268.jpg" class="lozad"></p><h4 id="利用数组进行数组处理-矢量化"><a href="#利用数组进行数组处理-矢量化" class="headerlink" title="利用数组进行数组处理(矢量化)"></a>利用数组进行数组处理(矢量化)</h4><p><img alt="基本数组统计方法" data-src="https://i.loli.net/2019/06/10/5cfe5847dc7df99208.jpg" class="lozad"></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何高效率地学习、工作与生活</title>
      <link href="/2019/05/15/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%8E%87%E5%9C%B0%E5%AD%A6%E4%B9%A0%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB/"/>
      <url>/2019/05/15/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E7%8E%87%E5%9C%B0%E5%AD%A6%E4%B9%A0%E3%80%81%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB/</url>
      
        <content type="html"><![CDATA[<p>很久没有更新博客了，总是想逼迫自己做点什么，于是便有了如下的这篇杂录摘记。</p><p>摘记之前我想先谈谈自己的个人感受吧，我的大学生活已渐入迟暮，思来想去，自己的自控能力实属过分的糟糕，应该很难想象过去的自己是多么的勤奋努力，确实，当太多的诱惑迎面而来，对于一个过去接触面太少的我而言，有点没办法把持的太好。以目前的能力而言，我觉得自己的水平远没有达到该专业对于一个应届毕业生的基本要求。高效率一直是我过去最经常追求的目标之一，可现如今却让我大感不易。所以有了下文，我也觉得有尝试的必要。</p><p>我很喜欢知友提到的那句诤言“很多人心怀远大目标，想要成为至少有一方面专精的高手，却总是不得其门而入，找不到入道之门，只能整天看着高墙一味悲观消沉下去，心中的壁垒也越垒越高，直到某天终于化作一滩废墟。其实我们需要的，只是一种具体可实现的方法而言”</p><h3 id="txt学习法"><a href="#txt学习法" class="headerlink" title="txt学习法"></a>txt学习法</h3>]]></content>
      
      
      <categories>
          
          <category> 生活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 知乎 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习笔记-2</title>
      <link href="/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/"/>
      <url>/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-2/</url>
      
        <content type="html"><![CDATA[<h2 id="Part-0-New-Tips"><a href="#Part-0-New-Tips" class="headerlink" title="Part.0 New Tips"></a>Part.0 New Tips</h2><h4 id="函数-Function"><a href="#函数-Function" class="headerlink" title="函数 Function"></a>函数 Function</h4><p>Python用关键词<code>def</code>来定义函数。</p><h4 id="类-Class"><a href="#类-Class" class="headerlink" title="类 Class"></a>类 Class</h4><p>用class来定义一个类。<code>Person(object)</code>表示继承自object类；<code>__init__</code>函数用来初始化对象； <code>self</code>表示对象自身，类似于C、Java里面<code>this</code>。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">class Person(object):</span><br><span class="line">    def __init__(self, first, last, age):</span><br><span class="line">        self.first = first</span><br><span class="line">        self.last = last</span><br><span class="line">        self.age = age</span><br><span class="line">    def full_name(self):</span><br><span class="line">        return self.first + &apos; &apos; + self.last</span><br></pre></td></tr></table></figure></p><h4 id="对象初始化"><a href="#对象初始化" class="headerlink" title="对象初始化"></a>对象初始化</h4><p>当对数据进行统计时，可进行初始化操作，方便统计的同时也可以减少对空对象的异常报错（例如<code>int-&gt;0</code>; <code>list-&gt;[]</code>; <code>set-&gt;{}</code>等），最终返回的是字典键值对<code>({x:x},{x:x},...)</code>，可以通过<code>dict.items()</code>以列表返回可遍历的<code>(键, 值)</code>元组数组。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">    x = defaultdict(int/list/set)</span><br></pre></td></tr></table></figure></p><h2 id="Part-1-Coding-Records"><a href="#Part-1-Coding-Records" class="headerlink" title="Part.1 Coding Records"></a>Part.1 Coding Records</h2><p>当我们获取到Json格式(即JavaScript Object Notation，一种常见的web数据格式)的文本数据时，可以通过<code>json.loads()</code>将其转换为python的字典对象。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import json</span><br><span class="line">path = &apos;xxx/xxx/xxxx/xx.txt&apos;</span><br><span class="line">records = [json.loads(line) for line in open(path)]</span><br></pre></td></tr></table></figure></p><h3 id="提取统计量中的前n项"><a href="#提取统计量中的前n项" class="headerlink" title="提取统计量中的前n项"></a>提取统计量中的前n项</h3><h4 id="method-1"><a href="#method-1" class="headerlink" title="method 1"></a>method 1</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line"> def get_count(sequence):</span><br><span class="line">    counts = defaultdict(int)</span><br><span class="line">    for x in sequence :</span><br><span class="line">        counts[x]+=1</span><br><span class="line">    return counts</span><br><span class="line"></span><br><span class="line"> # 操作对象：字典键值对`count_dict`(先将list列表数据进行统计操作后得到)</span><br><span class="line"> def top_count(count_dict,n):</span><br><span class="line">    value_key_pairs=[(count,name) for name,count in count_dict.items()]</span><br><span class="line">    value_key_pairs.sort()</span><br><span class="line">    return value_key_pairs[-n:] #排序后的列表进行倒序输出</span><br><span class="line">    </span><br><span class="line"> counts = get_count(list)</span><br><span class="line"> top_count(counts,n)</span><br></pre></td></tr></table></figure><h4 id="method-2"><a href="#method-2" class="headerlink" title="method 2"></a>method 2</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#操作对象：源数据list列表</span><br><span class="line">from collections import Counter</span><br><span class="line"></span><br><span class="line"> counts = Counter(list)</span><br><span class="line"> counts.most_common(n)#获取按顺序排列的前n项键值对</span><br></pre></td></tr></table></figure><h4 id="method-3"><a href="#method-3" class="headerlink" title="method 3"></a>method 3</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from pandas import DataFrame,Series</span><br><span class="line">import pandas as pd;import numpy as np</span><br><span class="line">import json</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">path=&apos;xxx/xxx/xxx.txt&apos;</span><br><span class="line"></span><br><span class="line">records=[json.loads(line) for line in open(path)] #获得字典数据对象</span><br><span class="line">frame=DataFrame(records) #DataFrame可以将数据转化为表格的形式</span><br><span class="line">  </span><br><span class="line">xx_counts= frame[&apos;xx&apos;].value_counts() #frame[&apos;xx&apos;]返回Series对象，其方法value_counts()获得排序后的队列</span><br></pre></td></tr></table></figure><p>此时的数据其实并不完美，内部存在未知或缺失的情形，下述代码进行对记录中的不规范时区进行替代值。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">clean_xx = frame[&apos;xx&apos;].fillna(&apos;Missing&apos;) #fillna函数替换缺失值(NA)</span><br><span class="line"></span><br><span class="line">clean_xx[clean_xx==&apos;&apos;]=&apos;Unknown&apos;  #未知值(空字符串)通过布尔型数组索引替换</span><br><span class="line"></span><br><span class="line">xx_counts=clean_xx.value_counts() #得到修正后的列表排列</span><br></pre></td></tr></table></figure></p><p>为了直观的显示出来，可以调用Series.plot方法得到水平条形图，这里顺带介绍一下啊IPython中如何显示图像的几步步骤<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line">  plt.figure()</span><br><span class="line">  </span><br><span class="line">  xx_counts[:n].plot(kind=&apos;barh&apos;,rot=&apos;0&apos;)</span><br><span class="line">  </span><br><span class="line">  plt.show()</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python基础学习笔记-1</title>
      <link href="/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/"/>
      <url>/2019/04/01/Python%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0-1/</url>
      
        <content type="html"><![CDATA[<h3 id="IPython的使用"><a href="#IPython的使用" class="headerlink" title="IPython的使用"></a>IPython的使用</h3><p>可以通过命令行(cmd)窗口键入ipython进入ipython解释器</p><p>其中可以使用 <code>?</code> 来查看函数的帮助<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum?</span><br></pre></td></tr></table></figure></p><p>或在导入包以后使用<code>??</code>查看函数帮助和函数源代码.<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 导入numpy和matplotlib两个包</span><br><span class="line">%pylab</span><br><span class="line"># 查看其中sort函数的帮助</span><br><span class="line">sort??</span><br></pre></td></tr></table></figure></p><p><strong>！！！以下代码无特别说明均默认在IPython的解释器下运行！！！</strong></p><h3 id="Anaconda-conda-的使用"><a href="#Anaconda-conda-的使用" class="headerlink" title="Anaconda(conda)的使用"></a>Anaconda(conda)的使用</h3><p>Anaconda是一个很好用的Python IDE，它集成了很多科学计算需要使用的python第三方工具包。</p><p>可以通过<code>!conda list</code>查询已经安装好的python第三方工具包。(注：IPython中使用<code>！</code>来调用系统命令)</p><p>对于 Anaconda 自身，可以在命令行(cmd)输入以下命令使其保持最新：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda update conda</span><br><span class="line">conda update anaconda</span><br></pre></td></tr></table></figure></p><p>安装，更新，卸载第三方的 python 工具包：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install &lt;some package&gt;</span><br><span class="line">conda update &lt;some package&gt;</span><br><span class="line">conda remove &lt;some package&gt;</span><br></pre></td></tr></table></figure></p><p>在安装或更新时可以指定安装的版本号，例如需要使用 <code>numpy 1.8.1</code>：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda install numpy=1.8.1</span><br><span class="line">conda update numpy=1.8.1</span><br></pre></td></tr></table></figure></p><p>在命令行(cmd)下可以使用 conda 产生一个新的环境(命名任意，这里这个环境被命名为 xxx )：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">conda create -n xxx python=3.7</span><br></pre></td></tr></table></figure></p><p>使用这个环境时，只需要命令行下输入：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">activate xxx</span><br></pre></td></tr></table></figure></p><p>即可实现环境的切换。</p><p>Anaconda 默认使用的编辑器是 spyder，可以在命令行下输入<code>spyder</code>进入。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析[2]</title>
      <link href="/2019/03/29/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-2/"/>
      <url>/2019/03/29/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h3><p>Python是一种解释型语言。Python解释器是通过“一次执行一条语句”的方式运行程序的。标准的交互式Python解释器可以在命令行上通过python命令启动。退出Python解释器并返回命令提示符,输入exit()或按下Ctrl-D即可。</p><p>虽然许多Python程序员用这种方式执行他们的所有Python代码,但Python科学计算程序员则更趋向于使用IPython(一种加强的交互式Python解释器)。通过使用%run命令,IPython会在同一个进程中执行指定文件中的代码。因此,在这些代码执行完毕之后,你就可以通过交互的方式研究其结果。</p><p>默认的IPython提示符采用的是一种编号的风格(如In[2]:),而不是标准的”&gt;&gt;&gt;”提示符。</p><h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="语言语义"><a href="#语言语义" class="headerlink" title="语言语义"></a>语言语义</h4><p>Python语言的设计特点是重视可读性、简洁性以及明确性。有些人甚至将它看做“可执行的伪码”。</p><h4 id="缩进-而不是大括号"><a href="#缩进-而不是大括号" class="headerlink" title="缩进,而不是大括号"></a>缩进,而不是大括号</h4><p>Python是通过空白符(制表符或空格)来组织代码的,不像其他语言(如R、C++、Java、Perl等)用的是大括号。以for循环为例,要实现前面说的那个快速排序算法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in array:</span><br><span class="line">  if x &lt; pivot:</span><br><span class="line">    less.append ( x )</span><br><span class="line">  else:</span><br><span class="line">    greater.append ( x )</span><br></pre></td></tr></table></figure></p><p>冒号表示一段缩进代码块的开始,其后的所有代码都必须缩进相同的量,直到代码块结束为止。在别的语言中,你可能会看到下面这样的东西:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in array &#123;</span><br><span class="line">  if x &lt; pivot &#123;</span><br><span class="line">    less.append ( x )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    greater.append ( X )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>前缀#作为注释标识符。</p><h4 id="变量和按引用传递"><a href="#变量和按引用传递" class="headerlink" title="变量和按引用传递"></a>变量和按引用传递</h4><p>在Python中对变量赋值时,你其实是在创建等号右侧对象的一个引用。<br>假如我们将a赋值给一个新变量b:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [2]:b=a</span><br></pre></td></tr></table></figure></p><p>在某些语言中,该赋值过程将会导致数据被复制。而在Python中,a和b现在都指向同一个对象。即指向同一个对象的两个引用。</p><p>注意:赋值(assignment)操作也叫做绑定(binding),因为我们其实是将一个名称和一个对象绑定到一起。已经赋过值的变量名有时也被称为已绑定变量(bound variable)。</p><p>当你将对象以参数的形式传入函数时,其实只是传入了一个引用而已,不会发生任何复制。因此,Python被称为是按引用传递的,而某些其他的语言则既支持按值传递(创建副本)又支持按引用传递。也就是说,Python函数可以修改其参数的内容。</p><h4 id="动态引用-强类型"><a href="#动态引用-强类型" class="headerlink" title="动态引用,强类型"></a>动态引用,强类型</h4><p>跟许多编译型语言(如Java和C++)相反,Python中的对象引用没有与之关联的类型信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [245]: a = 5</span><br><span class="line">In [246]: type(a)</span><br><span class="line">Out[246]:int</span><br><span class="line">In [247]: a = &apos; foo&apos;</span><br><span class="line">In [248]: type(a)</span><br><span class="line">Out[2481:str</span><br></pre></td></tr></table></figure></p><p>变量其实就是对象在特定命名空间中的名称而已。对象的类型信息是保存在它自己内部的。有些人可能会轻率地认为Python不是一种“类型化语言”。其实不是这样的。看看下面这个例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [249]: &apos;5&apos; + 5</span><br><span class="line">  TypeError</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-249-f9dbf5f0b234&gt; in &lt;module&gt;(</span><br><span class="line">-----&gt; 1 &apos;5&apos; + 5</span><br><span class="line">TypeError: cannot concatenate &apos;str&apos; and</span><br><span class="line">&apos; int &apos; objects</span><br></pre></td></tr></table></figure></p><p>在有些语言中(比如Visual Basic),字符串’5’可能会被隐式地转换为整数,于是就会得到10。而在另一些语言中(比如JavaScript),整数5可能会被转换为字符串,于是就会得到’55’。而在这一点上,Python可以被认为是一种强类型语言,也就是说,所有对象都有一个特定的类型(或类),隐式转换只在很明显的情况下才会发生,比如下面这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [250]: a = 4.5</span><br><span class="line">In [251]: b = 2</span><br><span class="line">#这个操作是字符串格式化,稍后介绍</span><br><span class="line">In [252]: print &apos;a is %s, b is                %s&apos; % (type(a),type(b))</span><br><span class="line">a is &lt;type &apos;float&apos; , b is &lt;type &apos;int&apos;&gt;</span><br><span class="line">In [253]: a / b</span><br><span class="line">Out[253]: 2.25</span><br></pre></td></tr></table></figure></p><p>了解对象的类型是很重要的。要想编写能够处理多个不同类型输入的函数就必须了解有关类型的知识。通过isinstance函数,你可以检查一个对象是否是某个特定类型的实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [254]: a = 5</span><br><span class="line">In [255]: isinstance(a,int)</span><br><span class="line">Out[255]:True</span><br></pre></td></tr></table></figure></p><p>isinstance可以接受由类型组成的元组。如果想检查某个对象的类型是否属于元组中所指定的那些:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In[256]:a=5;b=4.5</span><br><span class="line">In [257): isinstance(a, (int, float)</span><br><span class="line">Out[257):True</span><br><span class="line">In [258]: isinstance(b,(int,float))</span><br><span class="line">Out/2581:True</span><br></pre></td></tr></table></figure></p><h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>Python中的对象通常都既有属性(attribute,即存储在该对象“内部”的其他Python对象)又有方法(method,与该对象有关的能够访问其内部数据的函数)。它们都能通过obj.attribute_name这样的语法进行访问:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: a =&apos;foo&apos;</span><br><span class="line">In [2]: a.&lt;Tab&gt;</span><br><span class="line">a.capitalize a.format a.isupper</span><br><span class="line">a.rindex a.strip a.center a.index</span><br><span class="line">a.join a.riust a.swapcase a.count</span><br><span class="line">a.isalnum a.ljust a.rpartition </span><br><span class="line">a.title a.decode a.isalpha a.lower</span><br><span class="line">a.rsplit a.translate a.encode </span><br><span class="line">a.isdigit a.lstrip a.rstrip a.upper</span><br><span class="line">a.endswith a.islower a.partiti</span><br><span class="line">a.split a.zfill a.expandtabs a.isspace a.replace a.splitlines</span><br><span class="line">a.find a.istitle a.rfind a.startswith</span><br></pre></td></tr></table></figure></p><p>属性和方法还可以利用getattr函数通过名称进行访问:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;getattr(a,&apos;split&apos;)</span><br><span class="line">&lt; function split&gt;</span><br></pre></td></tr></table></figure></p><p>虽然本书没怎么用到getattr函数以及与之相关的hasattr和setattr函数,但是它们还是很实用的,尤其是在编写通用的、可复用的代码时。</p><h4 id="“鸭子”类型"><a href="#“鸭子”类型" class="headerlink" title="“鸭子”类型"></a>“鸭子”类型</h4><p>一般来说,你可能不会关心对象的类型,而只是想知道它到底有没有某些方法或行为。<br>比如说,只要一个对象实现了迭代器协议(iterator protocol),你就可以确认它是可迭代的。对于大部分对象而言,这就意味着它拥有一个<em>iter</em>魔术方法。当然,还有一个更好一些的验证办法,即尝试使用iter函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def isiterable(obj):</span><br><span class="line">try:</span><br><span class="line">  iter(obj)</span><br><span class="line">  return True</span><br><span class="line">except TypeError:#不可迭代</span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p><p>对于字符串以及大部分Python集合类型,该函数会返回True:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [260]: isiterable(&apos;a string&apos;) </span><br><span class="line">In [261]: isiterable([1,2,3])</span><br><span class="line">Out[260]:True</span><br><span class="line">Out[261]:True</span><br><span class="line">In [262]: isiterable(5)</span><br><span class="line">Out[262]:False</span><br></pre></td></tr></table></figure></p><p>我常常在编写需要处理多类型输入的函数时用到这个功能。还有一种常见的应用场景:编写可以接受任何序列(列表、元组、ndarray)或迭代器的函数。你可以先检查对象是不是列表(或NumPy数组),如果不是,就将其转换成是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if not isinstance(x, list) and isiterable(x):</span><br><span class="line">  x = list ( x )</span><br></pre></td></tr></table></figure></p><h4 id="引入-import"><a href="#引入-import" class="headerlink" title="引入(import)"></a>引入(import)</h4><p>在Python中,模块(module)就是一个含有函数和变量定义以及从其他.py文件引入的此类东西的.py文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import some module</span><br><span class="line">x=some module.xxx</span><br></pre></td></tr></table></figure></p><p>还可以写成这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from some_module import xxx</span><br><span class="line">x = xxx (x,...)</span><br></pre></td></tr></table></figure></p><p>通过as关键字,你可以引入不同的变量名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import some_module as sm</span><br><span class="line">from some_module import xxx as XXX</span><br><span class="line">x=sm.xxx  </span><br><span class="line">x=XXX(x)</span><br></pre></td></tr></table></figure></p><h4 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h4><p>要判断两个引用是否指向同一个对象,可以使用is关键字。如果想判断两个引用是否不是指向同一个对象,则可以使用is not:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [266]: a = [1, 2, 3]</span><br><span class="line">In [267]:b=a</span><br><span class="line">#注意,list函数始终会创建新列表l  </span><br><span class="line">In [268]: c = list(a)</span><br><span class="line">In [269]: a is b</span><br><span class="line">Out[269]:True</span><br><span class="line">In [270]: a is not C</span><br><span class="line">Out[270]:True</span><br></pre></td></tr></table></figure></p><p>注意,这跟比较运算”==”不是一回事,因<br>为对于上面这个情况,我们将会得到:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [271]: a == c</span><br><span class="line">Out[271]:True</span><br></pre></td></tr></table></figure></p><p>is和is not常常用于判断变量是否为None,<br>因为None的实例只有一个:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [272]: a = None</span><br><span class="line">In [273]: a is None</span><br><span class="line">Out[273]:True</span><br></pre></td></tr></table></figure></p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd116f5e5f092561.jpg" class="lozad"></p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd11aa5007172706.jpg" class="lozad"></p><h4 id="可变和不可变的对象"><a href="#可变和不可变的对象" class="headerlink" title="可变和不可变的对象"></a>可变和不可变的对象</h4><p>大部分Python对象是可变的(mutable),比如列表、字典、NumPy数组以及大部分用户自定义类型(类)。也就是说,它们所包含的<br>对象或值是可以被修改的。</p><p>而其他的(如字符串和元组等)则是不可变的(immutable)</p><h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>很多人都是因为Python强大而灵活的字符串处理能力才使用它的。编写字符串字面量时,既可以用单引号(‘)也可以用双引号(“):</p><p>对于带有换行符的多行字符串,可以使用三重引号(即<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">  C = &quot;&quot;&quot;</span><br><span class="line">      This is a longer string that</span><br><span class="line">      spans multiple lines</span><br><span class="line">      &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p><p>Python字符串是不可变的。要修改字符串就只能创建一个新的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [289]: a = &apos;this is a string&apos;</span><br><span class="line">In[290]:a[10]=&apos;f&apos;</span><br><span class="line">TypeError</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-290-5ca625d1e504&gt; in &lt;module&gt;()</span><br><span class="line"> ----&gt;1 a[10] = &apos;f&apos;</span><br><span class="line">TypeError:&apos;str&apos; object does not support</span><br><span class="line">item assignment</span><br><span class="line"></span><br><span class="line">In [291]:b=a.replace(&apos;string&apos;,&apos;long</span><br><span class="line">er string&apos;)</span><br><span class="line">In [292]: b</span><br><span class="line">Out[292]: &apos;this is a longer string&apos;</span><br></pre></td></tr></table></figure></p><p>许多Python对象都可以用str函数转换为字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [293]: a = 5.6</span><br><span class="line">In [294]: s =str(a)</span><br><span class="line">In [295]: s</span><br><span class="line">Out[295]:&apos;5.6&apos;</span><br></pre></td></tr></table></figure></p><p>由于字符串其实是一串字符序列,因此可以被当做某种序列类型(如列表、元组等)进行处理:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [296]: s=&apos;python&apos;</span><br><span class="line">In [297]: list(s)</span><br><span class="line">Out[297]: [&apos;p&apos;,&apos;y&apos;,&apos;t&apos;,&apos;h&apos;,&apos;o&apos;,&apos;n&apos;]</span><br><span class="line">In [298]: s[:3]</span><br><span class="line">Out[298]:&apos;pyt&apos;</span><br></pre></td></tr></table></figure></p><p>反斜杠()是转义符(escape character),也就是说,它可用于指定特殊字符(比如新行\n或unicode字符)。要编写带有反斜杠的字符串字面量,也需要对其进行转义。</p><p>若在字符串最左边引号的前边加上r，表示所有的字符按照原来的样子进行解释。</p><p>Python 3带来了一些新的字符串格式化手段,以一个%开头且后面跟着一个或多个格式字符的字符串是需要插入值的目标(这非常类似于C语言中的printf函数)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [306]: template=&apos;%.2f %s are worth</span><br><span class="line">$%d&apos;</span><br></pre></td></tr></table></figure></p><p>在这个字符串中,%s表示将参数格式化为字符串,%.2f表示一个带有2位小数的数字,%d表示一个整数。要用实参替换这些格式化形参,需要用到二元运算符%以及由值组成的元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [307]: template % (4.5560,&apos;Argentine Pesos&apos;, 1)</span><br><span class="line">Out[307]:&apos;4.56 Argentine Pesos are worth $1&apos;</span><br></pre></td></tr></table></figure></p><p>几乎所有内置的Python类型以及任何定义了<em>nonzero</em>魔术方法的类都能在if语句中被解释为True或False。</p><p>Python中大部分对象都有真假的概念。比如说,如果空序列(列表、字典、元组等)用于控制流就会被当做False处理。要想知道某个对象究竟会被强制转换成哪个布尔值,使用bool函数即可。</p><h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>如果一个函数没有显式的返回值，则隐式返回None。</p><p>是函数可选参数的一种常见默认值。</p><p>None不是一个保留关键字，而是NoneType的一个实例而已。</p><h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>Python内置的datetime模块提供了datetime、date以及time等类型。datetime类型是用得最多的,它合并了保存在date和time中的信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [325]: from datetime import datetime, date , time</span><br><span class="line">In [326]: dt = datetime(2011,10,29,20,30,21)</span><br><span class="line">In [327] : dt.day</span><br><span class="line">In [328]: dt.minute</span><br><span class="line">Out[327]:29</span><br><span class="line">Out[328]:30</span><br></pre></td></tr></table></figure></p><p>给定一个datetime实例,你可以通过调用其date和time方法提取相应的date和time对<br>象:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [329]: dt.date()</span><br><span class="line">In [330] : dt.time ( )</span><br><span class="line">Out[329]:datetime.date(2011,10,29)</span><br><span class="line">Out[330]:datetime.time(20,30,21)</span><br></pre></td></tr></table></figure></p><p>strftime方法用于将datetime格式化为字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [331]: dt.strftime(&apos;%m/%d/%Y%H:%M&apos;)</span><br><span class="line">Out[331]:10/29/2011 20:30&apos;</span><br></pre></td></tr></table></figure></p><p>字符串可以通过strptime函数转换(解析)为datetime对象:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [332] : datetime.strptime (&apos; 20091031 &apos; , &apos;%Y%m%d&apos;)</span><br><span class="line">Out[332]:datetime.datetime(2009,10,31,0,0)</span><br></pre></td></tr></table></figure></p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>调用列表的sort方法可以实现就地排序(无需创建新对象):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [398]: x = [x,...]</span><br><span class="line">In [399]: x.sort()</span><br></pre></td></tr></table></figure></p><p>sort有几个很不错的选项。一个是次要排序键,即一个能够产生可用于排序的值的函数。例如,可以通过长度对一组字符串进行排序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [401]:x=[&apos;xxx&apos;,&apos;xxx&apos;,...]</span><br><span class="line">In [402]:x.sort(key=len)</span><br></pre></td></tr></table></figure></p><h4 id="二分搜索及维护有序列表"><a href="#二分搜索及维护有序列表" class="headerlink" title="二分搜索及维护有序列表"></a>二分搜索及维护有序列表</h4><p>内置的bisect模块实现了二分查找以及对有序列表的插入操作。bisect.bisect可以找出新元素应该被插入到哪个位置才能保持原列表的有序性,而bisect.insort则确实地将新元素插入到那个位置上去（但bisect不会判断原列表是否有序）。</p><h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>通过切片标记法,你可以选取序列类型(数组、元组、NumPy数组等)的子集,其基本形式由索引运算符([])以及传入其中的start:stop构成。(stop未包含在其中)<br>负数索引从序列的末尾开始切片。</p><p>还可以在第二个冒号后面加上步长<br>(step)。比如每隔一位取出一个元素:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [418]: seq[::2]</span><br></pre></td></tr></table></figure></p><p>在这里使用-1是一个很巧妙的办法,它可以实现列表或元组的反序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [419]: seq[::-1]</span><br></pre></td></tr></table></figure></p><h4 id="内置的序列函数"><a href="#内置的序列函数" class="headerlink" title="内置的序列函数"></a>内置的序列函数</h4><h5 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h5><p>在对一个序列进行迭代时,常常需要跟踪当前项的索引。Python内置了一个enumerate函数,它可以逐个返回序列的(i,value)元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i,value in enumerate(collection):</span><br><span class="line">  #用value做一些事情</span><br></pre></td></tr></table></figure></p><p>在对数据进行索引时,enumerate还有一种不错的使用模式,即求取一个将序列值(假定是唯一的)映射到其所在位置的字典。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [420]: some_list=[&apos;foo&apos;,&apos;bar&apos;,baz&apos;]</span><br><span class="line">In [421]: mapping = dict((v, i) for i,v in enumerate(some_list))</span><br><span class="line">In [422]: mapping</span><br><span class="line">Out[422]:&#123;&apos;bar&apos;:1,&apos;baz&apos;:2,&apos;foo&apos;:0&#125;</span><br></pre></td></tr></table></figure></p><h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>sorted函数可以将任何序列返回为一个新的有序列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [423]: sorted([x,...])</span><br></pre></td></tr></table></figure></p><p>常常将sorted和set结合起来使用以得到一个由序列中的唯一元素组成的有序列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [425]: sorted(set(&apos;xxxxxxxxx&apos;))</span><br></pre></td></tr></table></figure></p><h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>zip用于将多个序列(列表、元组等)中的元素“配对”,从而产生一个新的元组列表。</p><p>zip可以接受任意数量的序列,最终得到的元组数量由最短的序列决定:</p><p>zip最常见的用法是同时迭代多个序列,还可以结合enumerate一起使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [431]: for i, (a, b) in enumerate(zip(seq1,seq2)):</span><br><span class="line">print(&apos;%d:%s,%s&apos;%(i,a,b))</span><br><span class="line">0:seq1.x1,seq2.y1</span><br><span class="line">1:seq1.x2,seq2.y2</span><br><span class="line">2:seq1.x3,seq2.y3</span><br></pre></td></tr></table></figure></p><p>对于“已压缩的”(zipped)序列,zip还有一个很巧妙的用法,即对该序列进行“解压”(unzip)。其实就是将一组行转换为一组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [433]: first_xs,last_xs=zip(*seqs)</span><br></pre></td></tr></table></figure></p><h5 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h5><p>reversed用于按逆序迭代序列中的元<br>素:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [436]: list(reversed(range(10))</span><br><span class="line">0ut[436]: [9,8,7,6,5,4,3,2,1,0]</span><br></pre></td></tr></table></figure></p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典(dict)可算是Python中最重要的内置数据结构。它更常见的名字是哈希映射(hash map)或相联数组(associative array)。它是一种大小可变的键值对集,其中的键(key)和值(value)都是Python对象。创建字典的方式之一是:使用大括号({})并用冒号分隔键和值。</p><p>keys和values方法分别用于获取键和值的列表。虽然键值对没有特定的顺序,但这两个函数会以相同的顺序输出键和值:</p><p>Python 3中dict.keys()和dict.values()会返回迭代器而不是列表。</p><p>利用update方法,一个字典可以被合并到另一个字典中去:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [451]: x1.update(&#123;x:&apos;xxx&apos;,&apos;x&apos;:xxx&#125;)</span><br></pre></td></tr></table></figure></p><p>从序列类型创建字典有时你可能会想将两个序列中的元素两两配对地组成一个字典。粗略分析一下之后,你可能会写出这样的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapping=&#123;&#125;</span><br><span class="line">for key,value in zip(key_list,value_list):</span><br><span class="line">  mapping[key]=value</span><br></pre></td></tr></table></figure></p><p>由于字典本质上就是一个二元元组集,所以我们完全可以用dict类型函数直接处理二元元组列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [453]: mapping = dict(zip(range(5),reversed(range(5))))</span><br></pre></td></tr></table></figure></p><h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>下面这样的逻辑很常见:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if key in some_dict:</span><br><span class="line">  value=some_dict[key]</span><br><span class="line">else:</span><br><span class="line">  value = default value</span><br></pre></td></tr></table></figure></p><p>其实dict的get和pop方法可以接受一个可供返回的默认值,于是,上面的if-else块就可以被简单地写成:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value=some_dict.get(key,default value)</span><br></pre></td></tr></table></figure></p><p>如果key不存在,则get默认返回None,而pop则会引发一个异常。在设置值的时候,常常会将字典中的值处理成别的集类型(比如列表)。例如,根据首字母对一组单词进行分类并最终产生一个由列表组成的字典:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In[455]:words=[&apos;apple&apos;,&apos;bat&apos;,&apos;bar&apos;,&apos;atom&apos;,&apos;book&apos;]</span><br><span class="line">In [456]: by_letter = &#123;&#125;</span><br><span class="line">In [457] : for word in words:letter=word[0]</span><br><span class="line">  if letter not in by_letter:</span><br><span class="line">    by_letter[letter]=[word]</span><br><span class="line">  else:</span><br><span class="line">    by_letter[letter]. append(n</span><br><span class="line">In [458]: by_letter</span><br><span class="line">Out[458]:&#123;&apos;a&apos;:[&apos;apple&apos;,&apos;atom&apos;],&apos;b&apos;:[&apos;bat&apos;,&apos;bar&apos;,&apos;book&apos;]&#125;</span><br></pre></td></tr></table></figure><p>字典的setdefault方法刚好能达到这个目的。上面的if-else块可以写成:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">by_letter.setdefault(letter,[]).append(word)</span><br></pre></td></tr></table></figure><p>内置的collections模块有一个叫做defaultdict的类,它可以使该过程更简单。传入一个类型或函数(用于生成字典各插槽所使用的默认值)即可创建出一个defaultdict:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"></span><br><span class="line">for word in words:</span><br><span class="line">  by_letter[word[0]].append(word)</span><br></pre></td></tr></table></figure><p>defaultdict的初始化器只需要一个可调用对象(例如各种函数),并不需要明确的类型。因此,如果你想要将默认值设置为4,只需传入一个能够返回4的函数即可:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">counts=defaultdict(1ambda:4)</span><br></pre></td></tr></table></figure><h4 id="字典键的有效类型"><a href="#字典键的有效类型" class="headerlink" title="字典键的有效类型"></a>字典键的有效类型</h4><p>虽然字典的值可以是任何Python对象,但键必须是不可变对象,如标量类型(整数、浮点数、字符串)或元组(元组中的所有对象也必须是不可变的)。</p><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合Set是由唯一元素组成的无序集</p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd13314501789880.jpg" class="lozad"></p><h4 id="列表-集合-字典推导式"><a href="#列表-集合-字典推导式" class="headerlink" title="列表,集合,字典推导式"></a>列表,集合,字典推导式</h4><p>列表推导式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[expr for val in collection if condition]</span><br></pre></td></tr></table></figure></p><p>这相当于下面这段for循环:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = [ ]</span><br><span class="line">for val in collection:</span><br><span class="line">  if condition:</span><br><span class="line">    result . append ( expr )</span><br></pre></td></tr></table></figure></p><p>过滤器条件可以省略,只留下表达式。<br>集合和字典的推导式是该思想的一种自然延伸,它们的语法差不多,只不过产生的是集合和字典而已。字典推导式的基本形式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_comp=&#123;key-expr:value-expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure></p><p>集合推导式跟列表推导式非常相似,唯一的区别就是它用的是花括号而不是方括号:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_comp=&#123;expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure><h4 id="函数亦为对象"><a href="#函数亦为对象" class="headerlink" title="函数亦为对象"></a>函数亦为对象</h4><p>由于Python函数都是对象,因此,在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组,希望对其进行一些数据清理工作并执行一堆转换:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">states = [ &apos; Alabama &apos; , &apos; Georgia ! &apos; , &apos; Georgia&apos;,&apos;georgia&apos;,&apos;F10rIda&apos;,&apos;south carolina##&apos;,&apos;West virginia?&apos;]</span><br></pre></td></tr></table></figure><p>不管是谁,只要处理过由用户提交的调查数据,就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串,需要做很多事情:去除空白符、删除各种标点符号、正确的大写格式等。牟一看上去,我们可能会写出下面这样的代码:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re # 正则表达式模块</span><br><span class="line">def clean_strings(strings):</span><br><span class="line">  result = [ ]</span><br><span class="line">  for value in strings:</span><br><span class="line">    value = value . strip ( )</span><br><span class="line">    value = re . sub ( &apos; ! ! #? ] &apos; , &apos;&apos; , value)#移除标点符号</span><br><span class="line">    value =value.title()</span><br><span class="line">    result.append(value)</span><br><span class="line">  return result</span><br></pre></td></tr></table></figure><p>最终结果如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [15]: clean_strings(states)</span><br><span class="line">Out[15]:</span><br><span class="line">[&apos;Alabama&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Florida&apos;,</span><br><span class="line">&apos;South Carolina&apos;,</span><br><span class="line">&apos; West Virginia &apos; ]</span><br></pre></td></tr></table></figure></p><p>其实还有另外一种不错的办法:将需要在一组给定字符串上执行的所有运算做成一个列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def remove_punctuation(value):</span><br><span class="line">  return re.sub ( &apos;!#?&apos;,&apos;&apos;, value)</span><br><span class="line"></span><br><span class="line">clean_ops=[str.strip,remove_punctuation,str.title]</span><br><span class="line"></span><br><span class="line">def clean_strings(strings,ops):</span><br><span class="line">  result = [ ]</span><br><span class="line">  for value in strings:</span><br><span class="line">    for function in ops:</span><br><span class="line">      value=function(value)</span><br><span class="line">    result.append (value)</span><br><span class="line">  return result</span><br></pre></td></tr></table></figure></p><p>然后我们就有了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [22]: clean_strings(states,clean_ops)</span><br><span class="line">Out[22]:</span><br><span class="line">[&apos;Alabama&apos;</span><br><span class="line">&apos;Georgia&apos;,</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;,</span><br><span class="line">&apos;Florida&apos;,</span><br><span class="line">&apos;South Carolina&apos;,</span><br><span class="line">&apos;West Virginia&apos;]</span><br></pre></td></tr></table></figure></p><h4 id="闭包-返回函数的函数"><a href="#闭包-返回函数的函数" class="headerlink" title="闭包:返回函数的函数"></a>闭包:返回函数的函数</h4><p>闭包(closure)就是由其他函数动态生成并返回的函数。其关键性质是,被返回的函数可以访问其创建者的局部命名空间中的变量。</p><p>闭包和标准Python函数之间的区别在于:即使其创建者已经执行完毕,闭包仍能继续访问其创建者的局部命名空间。虽然闭包的内部状态一般都是静态的,但也允许使用可变对象(如字典、集合、列表等可以被修改的对象)。例如,下面这个函数可以返回一个能够记录其参数(曾经传入的一切参数)的函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def make_watcher():</span><br><span class="line">  have seen = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  def has_been_seen(x):</span><br><span class="line">    if x in have seen:</span><br><span class="line">      return True</span><br><span class="line">    else:</span><br><span class="line">      have_seen[x]=True</span><br><span class="line">      return False</span><br><span class="line">  </span><br><span class="line">  return has been seen</span><br></pre></td></tr></table></figure></p><p>对一组整数使用该函数,可以得到:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [496]:watcher=make_watcher()</span><br><span class="line">In [497]:vals=[5,6,1,5,1,6,3,5]</span><br><span class="line">In [498]: [watcher(x) for x in vals]</span><br><span class="line">Out[498]: [False, False, False, True, True, True, False, True]</span><br></pre></td></tr></table></figure><h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>生成器表达式(generator expression)是构造生成器的最简单方式。生成器也有一个类似于列表、字典、集合推导式的东西,其创建方式为,把列表推导式两端的方括号改成圆括号:</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(expr for val in collection if condition)</span><br></pre></td></tr></table></figure><p><a href="http://www.cnblogs.com/coder2012/p/4990834.html" target="_blank" rel="noopener">生成器与yiely补充</a></p><h4 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h4><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如,groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [514]: import itertools</span><br><span class="line">In [515]: first_letter = lambda x: x[0]</span><br><span class="line">In [516]: names = [&apos;Alan&apos;, &apos;Adam&apos;, &apos;Wes&apos;,Will&apos;,&apos;Albert&apos;,&apos;Steven&apos;]</span><br><span class="line">In [517]: for letter, names in itertools. groupby(names,first_letter):</span><br><span class="line">print letter,list(names)#names是一个生成器</span><br><span class="line"></span><br><span class="line">A [ &apos; Alan &apos; , &apos; Adam &apos; ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python数据分析[1]</title>
      <link href="/2019/03/27/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1/"/>
      <url>/2019/03/27/python%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90-1/</url>
      
        <content type="html"><![CDATA[<p>Cython项目(<a href="http://cython.org)已经成为Python领域中创建编译型扩展以及对接C/C++代码的一大途径。" target="_blank" rel="noopener">http://cython.org)已经成为Python领域中创建编译型扩展以及对接C/C++代码的一大途径。</a></p><h3 id="为什么不选Python"><a href="#为什么不选Python" class="headerlink" title="为什么不选Python"></a>为什么不选Python</h3><p>虽然Python非常适合构建计算密集型科学应用程序以及几乎各种各样的通用系统,但它对于不少应用场景仍然力有不逮。</p><p>由于Python是一种解释型编程语言,因此大部分Python代码都要比用编译型语言(比如 Java和C++)编写的代码运行慢得多。由于程序员的时间通常都比CPU时间值钱,因此许多人也愿意在这里做一些权衡。但是,在那些要求延迟非常小的应用程序中(例如高频交易系统),为了尽最大可能地优化性能,耗费时间使用诸如C++这样更低级、更低生产率的语言进行编程也是值得的。</p><p>对于高并发、多线程的应用程序而言(尤其是拥有许多计算密集型线程的应用程序),Python并不是一种理想的编程语言。这是因为Python有一个叫做全局解释器锁(Global Interpreter Lock,GIL)的东西,这是一种防止解释器同时执行多条Python字节码指令的机制。（作注:GIL实质上属于Cython解释器所使用的同步线程的一种机制，使得时刻仅有一个线程在执行。具体的问题剖析可见<a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">该博文</a>）</p><p>虽然很多人数据处理应用程序为了能在较短的时间内完成数据集的处理工作都需要运行在计算机集群上,但是仍然有一些情况需要用单进程多线程系统来解决。</p><p>这并不是说Python不能执行真正的多线程并行代码,只不过这些代码不能在单个Python进程中执行而已。比如说,Cython项目可以集成OpenMP(一个用于并行计算的C框架)以实现并行处理循环进而大幅度提高数值算法的速度。</p><h3 id="重要的Python库"><a href="#重要的Python库" class="headerlink" title="重要的Python库"></a>重要的Python库</h3><p>考虑到那些还不太了解Python科学计算生态系统和库的读者,下面我先对各个库做一个简单的介绍。</p><h4 id="NumPy"><a href="#NumPy" class="headerlink" title="NumPy"></a>NumPy</h4><p>NumPy(Numerical Python的简称)是Python科学计算的基础包。本书大部分内容都基于NumPy以及构建于其上的库。它提供了以下功能(不限于此):</p><ul><li>快速高效的多维数组对象ndarray。</li><li>用于对数组执行元素级计算以及直接对数组执行数学运算的函数。</li><li>用于读写硬盘上基于数组的数据集的工具。</li><li>线性代数运算、傅里叶变换,以及随机数生成。</li><li>用于将C、C++、Fortran代码集成到Python的工具。</li></ul><p>除了为Python提供快速的数组处理能力,NumPy在数据分析方面还有另外一个主要作用,即作为在算法之间传递数据的容器。对于数值型数据,NumPy数组在存储和处理数据时要比内置的Python数据结构高效得多。此外,由低级语言(比如C和Fortran)编写的库可以直接操作NumPy数组中的数据,无需进行任何数据复制工作。</p><h4 id="pandas"><a href="#pandas" class="headerlink" title="pandas"></a>pandas</h4><p>pandas提供了使我们能够快速便捷地处理结构化数据的大量数据结构和函数。你很快就会发现,它是使Python成为强大而高效的数据分析环境的重要因素之一。本书用得最多的pandas对象是DataFrame,它是一个面向列(column-oriented)的二维表结构,且含有行标和列标.</p><p>pandas兼具NumPy高性能的数组计算功能以及电子表格和关系型数据库(如SQL)灵活的数据处理功能。它提供了复杂精细的索引功能,以便更为便捷地完成重塑、切片和切块、聚合以及选取数据子集等操作。pandas将是我在本书中使用的主要工具。</p><p>对于金融行业的用户,pandas提供了大量适用于金融数据的高性能时间序列功能和工具。适用于金融数据分析应用的工具。</p><p>R的data.frame对象所提供的功能只是DataFrame对象所提供的功能的一个子集。</p><p>pandas这个名字本身源自于panel  data(面板数据,这是计量经济学中关于多维结构化数据集的一个术语)以及Python data analysis(Python数据分析)。</p><h4 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h4><p>matplotlib是最流行的用于绘制数据图表的Python库。它非常适合创建出版物上用的图表。它跟IPython结合得很好,因而提供了一种非常好用的交互式数据绘图环境。绘制的图表也是交互式的,你可以利用绘图窗口中的工具栏放大图表中的某个区域或对整个图表进行平移浏览。</p><h4 id="IPython"><a href="#IPython" class="headerlink" title="IPython"></a>IPython</h4><p>IPython是Python科学计算标准工具集的组成部分,它将其他所有的东西联系到了一起。它为交互式和探索式计算提供了一个强健而高效的环境。它是一个增强的Python shell,目的是提高编写、测试、调试Python代码的速度。它主要用于交互式数据处理和利用matplotlib对数据进行可视化处理。我在用Python编程时,经常会用到IPython,包括运行、调试和测试代码。</p><p>除标准的基于终端的IPython shell外,该项目还提供了:</p><ul><li>一个类似于Mathematica的HTML笔记本(通过Web浏览器连接IPython,稍后将对此进行详细介绍)。</li><li>一个基于Q+框架的GUI控制台,其中含<br>有绘图、多行编辑以及语法高亮显示等功能。</li><li>用于交互式并行和分布式计算的基础架<br>构。</li></ul><p>我将在一章中专门讲解IPython,详细地介绍其大部分功能。强烈建议在阅读本书的过程中使用IPython。</p><h4 id="SciPy"><a href="#SciPy" class="headerlink" title="SciPy"></a>SciPy</h4><p>SciPy是一组专门解决科学计算中各种标准问题域的包的集合,主要包括下面这些包:</p><ul><li>scipy.integrate:数值积分例程和微分方程求解器。</li><li>scipy.linalg:扩展了由numpy.linalg提供的线性代数例程和矩阵分解功能。</li><li>scipy.optimize:函数优化器(最小化器)以及根查找算法。</li><li>scipy.signal:信号处理工具。</li><li>scipy.sparse:稀疏矩阵和稀疏线性系统求解器。</li><li>scipy.special:SPECFUN(这是一个实现了许多常用数学函数(如伽玛函数)的Fortran库)的包装器。</li><li>scipy.stats:标准连续和离散概率分布(如密度函数、采样器、连续分布函数等)、各种统计检验方法,以及更好的描述统计法。</li><li>scipy.weave:利用内联C++代码加速数组计算的工具。</li></ul><p>NumPy跟SciPy的有机结合完全可以替代MATLAB的计算功能(包括其插件工具箱)。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> DataAnalysis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于购置硬盘的相关注意点</title>
      <link href="/2019/03/22/%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9/"/>
      <url>/2019/03/22/%E5%85%B3%E4%BA%8E%E8%B4%AD%E7%BD%AE%E7%A1%AC%E7%9B%98%E7%9A%84%E7%9B%B8%E5%85%B3%E6%B3%A8%E6%84%8F%E7%82%B9/</url>
      
        <content type="html"><![CDATA[<p>最近在意硬盘选购的问题，刚好有视频指导，这里贴上B站内有中文翻译的<a href="https://www.bilibili.com/video/av46775323" target="_blank" rel="noopener">视频链接</a>,以下将视频内的内容进行删减总结(其实就是自己看英文字幕照着翻译后对比中文官翻修改，滑稽)，Mark住留作往后参考食用，进入正文。</p><p>其实大家不难意识到，现在你所使用的电子设备存储空间正以惊人的速度迅速被填补，其空间占用被视频、游戏以及大量的图像仓库所充斥。</p><p>当下比较热门的解决方式就是将额外的数据上传至云端，但是这种解决方法其实受限于可能需要的每月云端收费服务以及潜在的受限于网速的要求。</p><p>所以去购置一个专用的独立外置存储设备不失为另外一种方便的选择。</p><h3 id="Part-1-NMVe-or-SATA"><a href="#Part-1-NMVe-or-SATA" class="headerlink" title="Part 1. NMVe or SATA"></a>Part 1. NMVe or SATA</h3><p>从简易的U盘到一批存储服务器，其实都属于外置存储。</p><p>在贴近我们实际的消费级层面上，最快的还当属支持NVMe（Non-Volatile Memory express，是一个逻辑设备接口规范）的外置硬盘(SSD)或者硬盘盒。通过它，你可以用外置接口连接M.2 SSD等内置硬盘。它相较于旧时的SATA协议要快的多，这里列出两者数据来进行直观的对比：</p><div class="table-container"><table><thead><tr><th>类别</th><th>目前最高连续读写速度</th><th>提供给存储协议对象</th></tr></thead><tbody><tr><td>SATA</td><td>600 MB/s</td><td>为机械硬盘设计</td></tr><tr><td>NVMe</td><td>3000 MB/s</td><td>为固态硬盘设计</td></tr></tbody></table></div><p>因此，当你选购硬盘时，NVMe显然性能上会优秀更多。</p><h3 id="Part-2-接口：USB-3-1-or-雷电3"><a href="#Part-2-接口：USB-3-1-or-雷电3" class="headerlink" title="Part 2. 接口：USB 3.1 or 雷电3"></a>Part 2. 接口：USB 3.1 or 雷电3</h3><p>除了注意你购置的硬盘是否是NVMe的，你还需要注意其他更多的事情。例如你预购入高速的NVMe外置SSD或硬盘盒，你可能需要去弄清它所使用的是何种的接口：是USB  3.1的还是Thunderbolt 3(以下简称雷电3)的，其中，USB 3.1会支持更多的设备，但这当中也有你需要注意的点：</p><div class="table-container"><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>USB 3.0 or 3.1 Gen 1</td><td>5 GBit/s</td></tr><tr><td>USB 3.1 Gen 2</td><td>10 GBit/s</td></tr></tbody></table></div><p>如上述数据所示，显然后者的参数更加的可观，但如果你所遇到的是雷电3接口时，就不必我多说了8，参数如下：</p><div class="table-container"><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>Thunderbolt 3.0(雷电3)</td><td>40 GBit/s</td></tr></tbody></table></div><p>也就是说，市面上最快的PCIe(PCI Express) SSD也有足够的速率不会出现瓶颈。而且雷电3接口支持与电脑的PCIe总线直连，其外置硬盘出现的性能损耗问题在NVMe上要比USB小的多，因为USB硬盘通常要先把数据送至更慢的控制器去。</p><p>但是，雷电3也存在着额外需要考虑的问题，因为很少有电脑去支持它并且大量这类型的SSDs的价格也倾向于比同类的USB接口的SSDs更加的昂贵。所以是选择Thunderbolt 3.0还是USB 3.1 Gen 2，两者在同样搭配上NVMe硬盘的基础上，其实速度都要超过标准的SATA接口连接。</p><p>尽管与NVMe配对的雷电3接口在纸面上显然会更快，但在实际的使用过程中，你可能并不会对他们之间的差异有所察觉，除非你只是一味的使用它来拷贝超大文件。</p><p>另外，你其实更需要去注意的是你选的不要是一个USB 3.1 Gen 1的，因为它甚至不如标准SATA连接</p><div class="table-container"><table><thead><tr><th>类别</th><th>最高数据传输速率</th></tr></thead><tbody><tr><td>USB 3.1 Gen 1</td><td>5 GBit/s</td></tr><tr><td>SATA III</td><td>6 GBit/s</td></tr></tbody></table></div><p>另外，如果你对以上参数都不太敏感的化，你就只需要再三明确检查它不是USB 2的，虽然它更便宜但同时速度更低于以上任何一种接口，其最大的理论速度仅有480 MBit/s。</p><p>当然，如果你只是需要一个入门级别日常存储ppt演示，对于传输速度的要求不是很在意愿意花时间等候的话，你就不必纠结太多，甚至USB 2.0都可以满足。</p><h3 id="Part-3-其他因素"><a href="#Part-3-其他因素" class="headerlink" title="Part 3. 其他因素"></a>Part 3. 其他因素</h3><p>另外这里有一个误区，就算硬盘或者硬盘盒使用的是新USB TYPE-C接口，其实你也无法据此判断它用的是10 GBit/s的USB 3.1还是雷电3 ！！！</p><p>因为USB-C只是一个物理接口而已，它其实也可以使用更慢的数据传输协议，所以别光看外部物理接口就认为没有问题，还是需要花时间多看看参数才是。</p><p>除此之外，金属外壳的硬盘或硬盘盒可以辅助散热，这一点也是挺有用的。</p><p>但只要你购置的硬盘支持10 GBit或更高速度的产品，与内置硬盘相比就不会有太大的性能损失，除非你就是一个一天到晚喜欢测文件传输速度的人。</p>]]></content>
      
      
      <categories>
          
          <category> 科普 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hardware </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>课前准备—认识XML</title>
      <link href="/2019/01/26/%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%E2%80%94%E8%AE%A4%E8%AF%86XML/"/>
      <url>/2019/01/26/%E8%AF%BE%E5%89%8D%E5%87%86%E5%A4%87%E2%80%94%E8%AE%A4%E8%AF%86XML/</url>
      
        <content type="html"><![CDATA[<h4 id="认识XML"><a href="#认识XML" class="headerlink" title="认识XML"></a>认识XML</h4><p>XML是对HTML的补充,它不会替代 HTML,在大多数Web应用程序中,XML用于传输数据,而HTML用于格式化并显示数据。</p><p>XML是独立于软件和硬件的信息传输工具。(以纯文本格式进行存储)</p><p>XML指可扩展标记语言（eXtensible Markup Language）,XML被设计用来传输和存储数据。</p><p>XML标签没有被预定义,您需要自行定义标签。</p><h4 id="XML把数据从HTML分离"><a href="#XML把数据从HTML分离" class="headerlink" title="XML把数据从HTML分离"></a>XML把数据从HTML分离</h4><p>如果您需要在HTML文档中显示动态数据,那么每当数据改变时将花费大量的时间来编辑HTML。</p><p>通过XML,数据能够存储在独立的XML文件中。这样您就可以专注于使用HTML/CSS进行显示和布局,并确保修改底层数据不再需要对HTML进行任何的改变。</p><p>通过使用几行JavaScript代码,您就可以读取一个外部XML文件,并更新您的网页的数据内容。</p><h4 id="XML树结构"><a href="#XML树结构" class="headerlink" title="XML树结构"></a>XML树结构</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;ISO-8859-1&quot;?&gt;</span><br><span class="line">&lt;note&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure><p>第一行是XML声明。它定义XML的版本（1.0）和所使用的编码（ISO-8859-1=Latin-1/西欧字符集）。</p><p>下一行描述文档的根元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;note&gt;</span><br></pre></td></tr></table></figure></p><p>接下来4行描述根的4个子元素<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;heading&gt;Reminder&lt;/heading&gt;</span><br><span class="line">&lt;body&gt;Don&apos;t forget me this weekend!&lt;/body&gt;</span><br></pre></td></tr></table></figure></p><p>最后一行定义根元素的结尾：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>总结就是,XML文档必须包含根元素。该元素是所有其他元素的父元素。XML文档中的元素形成了一棵文档树。这棵树从根部开始,并扩展到树的最底端。所有的元素都可以有子元素：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;root&gt;</span><br><span class="line">&lt;child&gt;</span><br><span class="line">&lt;subchild&gt;.....&lt;/subchild&gt;</span><br><span class="line">&lt;/child&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></p><p>所有的元素都可以有文本内容和属性（类似 HTML 中）。</p><h4 id="XML-语法规则"><a href="#XML-语法规则" class="headerlink" title="XML 语法规则"></a>XML 语法规则</h4><p>在HTML中,某些元素不必有一个关闭标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;This is a paragraph.</span><br><span class="line">&lt;br&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中,省略关闭标签是非法的。所有元素都必须有关闭标签：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;p&gt;This is a paragraph.&lt;/p&gt;</span><br></pre></td></tr></table></figure></p><p>XML标签对大小写敏感。</p><p>在HTML中,常会看到没有正确嵌套的元素：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/b&gt;&lt;/i&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中，所有元素都必须彼此正确地嵌套：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;b&gt;&lt;i&gt;This text is bold and italic&lt;/i&gt;&lt;/b&gt;</span><br></pre></td></tr></table></figure></p><p>XML文档必须有根元素。</p><p>XML 属性值必须加引号。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;note date=&quot;12/11/2007&quot;&gt;</span><br><span class="line">&lt;to&gt;Tove&lt;/to&gt;</span><br><span class="line">&lt;from&gt;Jani&lt;/from&gt;</span><br><span class="line">&lt;/note&gt;</span><br></pre></td></tr></table></figure></p><p>实体引用.</p><p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd10c1ed59924643.jpg" class="lozad"></p><p>注释：在XML中,只有字符”&lt;”和”&amp;”确实是非法的。大于号是合法的,但是用实体引用来代替它是一个好习惯。XML中的注释<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- something code --&gt;</span><br></pre></td></tr></table></figure></p><p>在XML中,文档中的空格不会被删减。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> C# </tag>
            
            <tag> WPF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小废的Introduction</title>
      <link href="/2019/01/21/%E5%B0%8F%E5%BA%9F%E7%9A%84Introduction/"/>
      <url>/2019/01/21/%E5%B0%8F%E5%BA%9F%E7%9A%84Introduction/</url>
      
        <content type="html"><![CDATA[<p>起初从同学那里了解到hexo以后，就一直有一个建站的念头，一个专属于自己的博客网站，这应该是我现下最想完成的一件事情吧，所以借着这次假期的机会，我依照着教程搭建了现在的小废在不在、。</p><p>目前的样式还基本上与范例没有多大的差别，所以需要后期自己的自主学习使他拥有自己的个性，就像看到前辈们指出的那样，如果发现有同一主题出现在两个博客网站里，就要开始筹措着换点新花样使其与众不同。</p><a id="more"></a><p>建立这个网站的初衷其实不单只是练练手而已，这个网站基本上也会伴随着我一直走下去，会不断的通过学习去增加新的功能，去丰富完善界面，当然，这今后也将作为我随时更新自己生活学习娱乐记录的处所，算是自己私人的小小空间吧。</p><p>就说这么多吧，一切都有待自己去实践才有说服力，希望自己真的能对得起自己最初的梦想。</p><p>加油，我是小废，我要走的路还有很长很长，以上。</p>]]></content>
      
      
      <categories>
          
          <category> 学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
