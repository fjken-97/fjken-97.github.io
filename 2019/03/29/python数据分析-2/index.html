<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.8.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>python数据分析[2] | 小废在不在、</title><meta name="description" content="python数据分析[2]"><meta name="keywords" content="python,DataAnalysis"><meta name="author" content="小废在不在、"><meta name="copyright" content="小废在不在、"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/github-character.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="http://yoursite.com/2019/03/29/python数据分析-2/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="python数据分析[2]"><meta name="twitter:description" content="python数据分析[2]"><meta name="twitter:image" content="https://i.loli.net/2019/06/09/5cfd104ee601168066.jpg"><meta property="og:type" content="article"><meta property="og:title" content="python数据分析[2]"><meta property="og:url" content="http://yoursite.com/2019/03/29/python数据分析-2/"><meta property="og:site_name" content="小废在不在、"><meta property="og:description" content="python数据分析[2]"><meta property="og:image" content="https://i.loli.net/2019/06/09/5cfd104ee601168066.jpg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="python基础学习笔记-1" href="http://yoursite.com/2019/04/01/Python基础学习笔记-1/"><link rel="next" title="python数据分析[1]" href="http://yoursite.com/2019/03/27/python数据分析-1/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"找不到您查询的内容:${query}"}},
  translate: {"defaultEncoding":2,"translateDelay":0,"cookieDomain":"https://fjken.top/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    title: '添加书签',
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天'

  
}</script></head><body><canvas class="fireworks"></canvas><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#Python解释器"><span class="toc-number">1.</span> <span class="toc-text">Python解释器</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基础知识"><span class="toc-number">2.</span> <span class="toc-text">基础知识</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#语言语义"><span class="toc-number">2.1.</span> <span class="toc-text">语言语义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缩进-而不是大括号"><span class="toc-number">2.2.</span> <span class="toc-text">缩进,而不是大括号</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#变量和按引用传递"><span class="toc-number">2.3.</span> <span class="toc-text">变量和按引用传递</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态引用-强类型"><span class="toc-number">2.4.</span> <span class="toc-text">动态引用,强类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#属性和方法"><span class="toc-number">2.5.</span> <span class="toc-text">属性和方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#“鸭子”类型"><span class="toc-number">2.6.</span> <span class="toc-text">“鸭子”类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#引入-import"><span class="toc-number">2.7.</span> <span class="toc-text">引入(import)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二元运算符和比较运算符"><span class="toc-number">2.8.</span> <span class="toc-text">二元运算符和比较运算符</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可变和不可变的对象"><span class="toc-number">2.9.</span> <span class="toc-text">可变和不可变的对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串"><span class="toc-number">2.10.</span> <span class="toc-text">字符串</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#None"><span class="toc-number">2.11.</span> <span class="toc-text">None</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期和时间"><span class="toc-number">2.12.</span> <span class="toc-text">日期和时间</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#排序"><span class="toc-number">2.13.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#二分搜索及维护有序列表"><span class="toc-number">2.14.</span> <span class="toc-text">二分搜索及维护有序列表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#切片"><span class="toc-number">2.15.</span> <span class="toc-text">切片</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#内置的序列函数"><span class="toc-number">2.16.</span> <span class="toc-text">内置的序列函数</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#enumerate"><span class="toc-number">2.16.1.</span> <span class="toc-text">enumerate</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#sorted"><span class="toc-number">2.16.2.</span> <span class="toc-text">sorted</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#zip"><span class="toc-number">2.16.3.</span> <span class="toc-text">zip</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#reversed"><span class="toc-number">2.16.4.</span> <span class="toc-text">reversed</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字典"><span class="toc-number">2.17.</span> <span class="toc-text">字典</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#默认值"><span class="toc-number">2.18.</span> <span class="toc-text">默认值</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字典键的有效类型"><span class="toc-number">2.19.</span> <span class="toc-text">字典键的有效类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#集合"><span class="toc-number">2.20.</span> <span class="toc-text">集合</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#列表-集合-字典推导式"><span class="toc-number">2.21.</span> <span class="toc-text">列表,集合,字典推导式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#函数亦为对象"><span class="toc-number">2.22.</span> <span class="toc-text">函数亦为对象</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#闭包-返回函数的函数"><span class="toc-number">2.23.</span> <span class="toc-text">闭包:返回函数的函数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#生成器表达式"><span class="toc-number">2.24.</span> <span class="toc-text">生成器表达式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#itertools模块"><span class="toc-number">2.25.</span> <span class="toc-text">itertools模块</span></a></li></ol></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://i.loli.net/2019/06/09/5cfd14efc834866434.jpg)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">小废在不在、</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><div class="menu_mask"></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" src="https://i.loli.net/2019/06/09/5cfd104ee601168066.jpg" onerror="onerror=null;src='/img/friend_404.gif'"></div><div class="mobile_post_data"><div class="mobile_data_item text-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">37</div></a></div></div><div class="mobile_data_item text-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item text-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">3</div></a></div></div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/gallery/"><i class="fa-fw fa fa-camera-retro"></i><span> 相册</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> 搜索</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">python数据分析[2]</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> 发表于 2019-03-29<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> 更新于 2019-06-09</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/学习/">学习</a></span><div class="post-meta-wordcount"><span>字数总计: </span><span class="word-count">5.5k</span><span class="post-meta__separator">|</span><span>阅读时长: 20 分钟</span><span class="post-meta__separator">|</span><span>阅读量: </span><span id="busuanzi_value_page_pv"></span></div></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><h3 id="Python解释器"><a href="#Python解释器" class="headerlink" title="Python解释器"></a>Python解释器</h3><p>Python是一种解释型语言。Python解释器是通过“一次执行一条语句”的方式运行程序的。标准的交互式Python解释器可以在命令行上通过python命令启动。退出Python解释器并返回命令提示符,输入exit()或按下Ctrl-D即可。</p>
<p>虽然许多Python程序员用这种方式执行他们的所有Python代码,但Python科学计算程序员则更趋向于使用IPython(一种加强的交互式Python解释器)。通过使用%run命令,IPython会在同一个进程中执行指定文件中的代码。因此,在这些代码执行完毕之后,你就可以通过交互的方式研究其结果。</p>
<p>默认的IPython提示符采用的是一种编号的风格(如In[2]:),而不是标准的”&gt;&gt;&gt;”提示符。</p>
<h3 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h3><h4 id="语言语义"><a href="#语言语义" class="headerlink" title="语言语义"></a>语言语义</h4><p>Python语言的设计特点是重视可读性、简洁性以及明确性。有些人甚至将它看做“可执行的伪码”。</p>
<h4 id="缩进-而不是大括号"><a href="#缩进-而不是大括号" class="headerlink" title="缩进,而不是大括号"></a>缩进,而不是大括号</h4><p>Python是通过空白符(制表符或空格)来组织代码的,不像其他语言(如R、C++、Java、Perl等)用的是大括号。以for循环为例,要实现前面说的那个快速排序算法:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in array:</span><br><span class="line">  if x &lt; pivot:</span><br><span class="line">    less.append ( x )</span><br><span class="line">  else:</span><br><span class="line">    greater.append ( x )</span><br></pre></td></tr></table></figure></p>
<p>冒号表示一段缩进代码块的开始,其后的所有代码都必须缩进相同的量,直到代码块结束为止。在别的语言中,你可能会看到下面这样的东西:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for x in array &#123;</span><br><span class="line">  if x &lt; pivot &#123;</span><br><span class="line">    less.append ( x )</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    greater.append ( X )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>前缀#作为注释标识符。</p>
<h4 id="变量和按引用传递"><a href="#变量和按引用传递" class="headerlink" title="变量和按引用传递"></a>变量和按引用传递</h4><p>在Python中对变量赋值时,你其实是在创建等号右侧对象的一个引用。<br>假如我们将a赋值给一个新变量b:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [2]:b=a</span><br></pre></td></tr></table></figure></p>
<p>在某些语言中,该赋值过程将会导致数据被复制。而在Python中,a和b现在都指向同一个对象。即指向同一个对象的两个引用。</p>
<p>注意:赋值(assignment)操作也叫做绑定(binding),因为我们其实是将一个名称和一个对象绑定到一起。已经赋过值的变量名有时也被称为已绑定变量(bound variable)。</p>
<p>当你将对象以参数的形式传入函数时,其实只是传入了一个引用而已,不会发生任何复制。因此,Python被称为是按引用传递的,而某些其他的语言则既支持按值传递(创建副本)又支持按引用传递。也就是说,Python函数可以修改其参数的内容。</p>
<h4 id="动态引用-强类型"><a href="#动态引用-强类型" class="headerlink" title="动态引用,强类型"></a>动态引用,强类型</h4><p>跟许多编译型语言(如Java和C++)相反,Python中的对象引用没有与之关联的类型信息。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [245]: a = 5</span><br><span class="line">In [246]: type(a)</span><br><span class="line">Out[246]:int</span><br><span class="line">In [247]: a = &apos; foo&apos;</span><br><span class="line">In [248]: type(a)</span><br><span class="line">Out[2481:str</span><br></pre></td></tr></table></figure></p>
<p>变量其实就是对象在特定命名空间中的名称而已。对象的类型信息是保存在它自己内部的。有些人可能会轻率地认为Python不是一种“类型化语言”。其实不是这样的。看看下面这个例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [249]: &apos;5&apos; + 5</span><br><span class="line">  TypeError</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-249-f9dbf5f0b234&gt; in &lt;module&gt;(</span><br><span class="line">-----&gt; 1 &apos;5&apos; + 5</span><br><span class="line">TypeError: cannot concatenate &apos;str&apos; and</span><br><span class="line">&apos; int &apos; objects</span><br></pre></td></tr></table></figure></p>
<p>在有些语言中(比如Visual Basic),字符串’5’可能会被隐式地转换为整数,于是就会得到10。而在另一些语言中(比如JavaScript),整数5可能会被转换为字符串,于是就会得到’55’。而在这一点上,Python可以被认为是一种强类型语言,也就是说,所有对象都有一个特定的类型(或类),隐式转换只在很明显的情况下才会发生,比如下面这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [250]: a = 4.5</span><br><span class="line">In [251]: b = 2</span><br><span class="line">#这个操作是字符串格式化,稍后介绍</span><br><span class="line">In [252]: print &apos;a is %s, b is                %s&apos; % (type(a),type(b))</span><br><span class="line">a is &lt;type &apos;float&apos; , b is &lt;type &apos;int&apos;&gt;</span><br><span class="line">In [253]: a / b</span><br><span class="line">Out[253]: 2.25</span><br></pre></td></tr></table></figure></p>
<p>了解对象的类型是很重要的。要想编写能够处理多个不同类型输入的函数就必须了解有关类型的知识。通过isinstance函数,你可以检查一个对象是否是某个特定类型的实例:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [254]: a = 5</span><br><span class="line">In [255]: isinstance(a,int)</span><br><span class="line">Out[255]:True</span><br></pre></td></tr></table></figure></p>
<p>isinstance可以接受由类型组成的元组。如果想检查某个对象的类型是否属于元组中所指定的那些:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In[256]:a=5;b=4.5</span><br><span class="line">In [257): isinstance(a, (int, float)</span><br><span class="line">Out[257):True</span><br><span class="line">In [258]: isinstance(b,(int,float))</span><br><span class="line">Out/2581:True</span><br></pre></td></tr></table></figure></p>
<h4 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h4><p>Python中的对象通常都既有属性(attribute,即存储在该对象“内部”的其他Python对象)又有方法(method,与该对象有关的能够访问其内部数据的函数)。它们都能通过obj.attribute_name这样的语法进行访问:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [1]: a =&apos;foo&apos;</span><br><span class="line">In [2]: a.&lt;Tab&gt;</span><br><span class="line">a.capitalize a.format a.isupper</span><br><span class="line">a.rindex a.strip a.center a.index</span><br><span class="line">a.join a.riust a.swapcase a.count</span><br><span class="line">a.isalnum a.ljust a.rpartition </span><br><span class="line">a.title a.decode a.isalpha a.lower</span><br><span class="line">a.rsplit a.translate a.encode </span><br><span class="line">a.isdigit a.lstrip a.rstrip a.upper</span><br><span class="line">a.endswith a.islower a.partiti</span><br><span class="line">a.split a.zfill a.expandtabs a.isspace a.replace a.splitlines</span><br><span class="line">a.find a.istitle a.rfind a.startswith</span><br></pre></td></tr></table></figure></p>
<p>属性和方法还可以利用getattr函数通过名称进行访问:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;&gt;&gt;getattr(a,&apos;split&apos;)</span><br><span class="line">&lt; function split&gt;</span><br></pre></td></tr></table></figure></p>
<p>虽然本书没怎么用到getattr函数以及与之相关的hasattr和setattr函数,但是它们还是很实用的,尤其是在编写通用的、可复用的代码时。</p>
<h4 id="“鸭子”类型"><a href="#“鸭子”类型" class="headerlink" title="“鸭子”类型"></a>“鸭子”类型</h4><p>一般来说,你可能不会关心对象的类型,而只是想知道它到底有没有某些方法或行为。<br>比如说,只要一个对象实现了迭代器协议(iterator protocol),你就可以确认它是可迭代的。对于大部分对象而言,这就意味着它拥有一个<em>iter</em>魔术方法。当然,还有一个更好一些的验证办法,即尝试使用iter函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def isiterable(obj):</span><br><span class="line">try:</span><br><span class="line">  iter(obj)</span><br><span class="line">  return True</span><br><span class="line">except TypeError:#不可迭代</span><br><span class="line">  return False</span><br></pre></td></tr></table></figure></p>
<p>对于字符串以及大部分Python集合类型,该函数会返回True:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [260]: isiterable(&apos;a string&apos;) </span><br><span class="line">In [261]: isiterable([1,2,3])</span><br><span class="line">Out[260]:True</span><br><span class="line">Out[261]:True</span><br><span class="line">In [262]: isiterable(5)</span><br><span class="line">Out[262]:False</span><br></pre></td></tr></table></figure></p>
<p>我常常在编写需要处理多类型输入的函数时用到这个功能。还有一种常见的应用场景:编写可以接受任何序列(列表、元组、ndarray)或迭代器的函数。你可以先检查对象是不是列表(或NumPy数组),如果不是,就将其转换成是:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if not isinstance(x, list) and isiterable(x):</span><br><span class="line">  x = list ( x )</span><br></pre></td></tr></table></figure></p>
<h4 id="引入-import"><a href="#引入-import" class="headerlink" title="引入(import)"></a>引入(import)</h4><p>在Python中,模块(module)就是一个含有函数和变量定义以及从其他.py文件引入的此类东西的.py文件。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import some module</span><br><span class="line">x=some module.xxx</span><br></pre></td></tr></table></figure></p>
<p>还可以写成这样:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from some_module import xxx</span><br><span class="line">x = xxx (x,...)</span><br></pre></td></tr></table></figure></p>
<p>通过as关键字,你可以引入不同的变量名<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import some_module as sm</span><br><span class="line">from some_module import xxx as XXX</span><br><span class="line">x=sm.xxx  </span><br><span class="line">x=XXX(x)</span><br></pre></td></tr></table></figure></p>
<h4 id="二元运算符和比较运算符"><a href="#二元运算符和比较运算符" class="headerlink" title="二元运算符和比较运算符"></a>二元运算符和比较运算符</h4><p>要判断两个引用是否指向同一个对象,可以使用is关键字。如果想判断两个引用是否不是指向同一个对象,则可以使用is not:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [266]: a = [1, 2, 3]</span><br><span class="line">In [267]:b=a</span><br><span class="line">#注意,list函数始终会创建新列表l  </span><br><span class="line">In [268]: c = list(a)</span><br><span class="line">In [269]: a is b</span><br><span class="line">Out[269]:True</span><br><span class="line">In [270]: a is not C</span><br><span class="line">Out[270]:True</span><br></pre></td></tr></table></figure></p>
<p>注意,这跟比较运算”==”不是一回事,因<br>为对于上面这个情况,我们将会得到:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [271]: a == c</span><br><span class="line">Out[271]:True</span><br></pre></td></tr></table></figure></p>
<p>is和is not常常用于判断变量是否为None,<br>因为None的实例只有一个:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [272]: a = None</span><br><span class="line">In [273]: a is None</span><br><span class="line">Out[273]:True</span><br></pre></td></tr></table></figure></p>
<p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd116f5e5f092561.jpg" class="lozad"></p>
<p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd11aa5007172706.jpg" class="lozad"></p>
<h4 id="可变和不可变的对象"><a href="#可变和不可变的对象" class="headerlink" title="可变和不可变的对象"></a>可变和不可变的对象</h4><p>大部分Python对象是可变的(mutable),比如列表、字典、NumPy数组以及大部分用户自定义类型(类)。也就是说,它们所包含的<br>对象或值是可以被修改的。</p>
<p>而其他的(如字符串和元组等)则是不可变的(immutable)</p>
<h4 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h4><p>很多人都是因为Python强大而灵活的字符串处理能力才使用它的。编写字符串字面量时,既可以用单引号(‘)也可以用双引号(“):</p>
<p>对于带有换行符的多行字符串,可以使用三重引号(即<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">```</span><br><span class="line">  C = &quot;&quot;&quot;</span><br><span class="line">      This is a longer string that</span><br><span class="line">      spans multiple lines</span><br><span class="line">      &quot;&quot;&quot;</span><br></pre></td></tr></table></figure></p>
<p>Python字符串是不可变的。要修改字符串就只能创建一个新的。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [289]: a = &apos;this is a string&apos;</span><br><span class="line">In[290]:a[10]=&apos;f&apos;</span><br><span class="line">TypeError</span><br><span class="line">Traceback (most recent call last)</span><br><span class="line">&lt;ipython-input-290-5ca625d1e504&gt; in &lt;module&gt;()</span><br><span class="line"> ----&gt;1 a[10] = &apos;f&apos;</span><br><span class="line">TypeError:&apos;str&apos; object does not support</span><br><span class="line">item assignment</span><br><span class="line"></span><br><span class="line">In [291]:b=a.replace(&apos;string&apos;,&apos;long</span><br><span class="line">er string&apos;)</span><br><span class="line">In [292]: b</span><br><span class="line">Out[292]: &apos;this is a longer string&apos;</span><br></pre></td></tr></table></figure></p>
<p>许多Python对象都可以用str函数转换为字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [293]: a = 5.6</span><br><span class="line">In [294]: s =str(a)</span><br><span class="line">In [295]: s</span><br><span class="line">Out[295]:&apos;5.6&apos;</span><br></pre></td></tr></table></figure></p>
<p>由于字符串其实是一串字符序列,因此可以被当做某种序列类型(如列表、元组等)进行处理:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [296]: s=&apos;python&apos;</span><br><span class="line">In [297]: list(s)</span><br><span class="line">Out[297]: [&apos;p&apos;,&apos;y&apos;,&apos;t&apos;,&apos;h&apos;,&apos;o&apos;,&apos;n&apos;]</span><br><span class="line">In [298]: s[:3]</span><br><span class="line">Out[298]:&apos;pyt&apos;</span><br></pre></td></tr></table></figure></p>
<p>反斜杠()是转义符(escape character),也就是说,它可用于指定特殊字符(比如新行\n或unicode字符)。要编写带有反斜杠的字符串字面量,也需要对其进行转义。</p>
<p>若在字符串最左边引号的前边加上r，表示所有的字符按照原来的样子进行解释。</p>
<p>Python 3带来了一些新的字符串格式化手段,以一个%开头且后面跟着一个或多个格式字符的字符串是需要插入值的目标(这非常类似于C语言中的printf函数)。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [306]: template=&apos;%.2f %s are worth</span><br><span class="line">$%d&apos;</span><br></pre></td></tr></table></figure></p>
<p>在这个字符串中,%s表示将参数格式化为字符串,%.2f表示一个带有2位小数的数字,%d表示一个整数。要用实参替换这些格式化形参,需要用到二元运算符%以及由值组成的元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [307]: template % (4.5560,&apos;Argentine Pesos&apos;, 1)</span><br><span class="line">Out[307]:&apos;4.56 Argentine Pesos are worth $1&apos;</span><br></pre></td></tr></table></figure></p>
<p>几乎所有内置的Python类型以及任何定义了<em>nonzero</em>魔术方法的类都能在if语句中被解释为True或False。</p>
<p>Python中大部分对象都有真假的概念。比如说,如果空序列(列表、字典、元组等)用于控制流就会被当做False处理。要想知道某个对象究竟会被强制转换成哪个布尔值,使用bool函数即可。</p>
<h4 id="None"><a href="#None" class="headerlink" title="None"></a>None</h4><p>如果一个函数没有显式的返回值，则隐式返回None。</p>
<p>是函数可选参数的一种常见默认值。</p>
<p>None不是一个保留关键字，而是NoneType的一个实例而已。</p>
<h4 id="日期和时间"><a href="#日期和时间" class="headerlink" title="日期和时间"></a>日期和时间</h4><p>Python内置的datetime模块提供了datetime、date以及time等类型。datetime类型是用得最多的,它合并了保存在date和time中的信息:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [325]: from datetime import datetime, date , time</span><br><span class="line">In [326]: dt = datetime(2011,10,29,20,30,21)</span><br><span class="line">In [327] : dt.day</span><br><span class="line">In [328]: dt.minute</span><br><span class="line">Out[327]:29</span><br><span class="line">Out[328]:30</span><br></pre></td></tr></table></figure></p>
<p>给定一个datetime实例,你可以通过调用其date和time方法提取相应的date和time对<br>象:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [329]: dt.date()</span><br><span class="line">In [330] : dt.time ( )</span><br><span class="line">Out[329]:datetime.date(2011,10,29)</span><br><span class="line">Out[330]:datetime.time(20,30,21)</span><br></pre></td></tr></table></figure></p>
<p>strftime方法用于将datetime格式化为字符串:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [331]: dt.strftime(&apos;%m/%d/%Y%H:%M&apos;)</span><br><span class="line">Out[331]:10/29/2011 20:30&apos;</span><br></pre></td></tr></table></figure></p>
<p>字符串可以通过strptime函数转换(解析)为datetime对象:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [332] : datetime.strptime (&apos; 20091031 &apos; , &apos;%Y%m%d&apos;)</span><br><span class="line">Out[332]:datetime.datetime(2009,10,31,0,0)</span><br></pre></td></tr></table></figure></p>
<h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>调用列表的sort方法可以实现就地排序(无需创建新对象):<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [398]: x = [x,...]</span><br><span class="line">In [399]: x.sort()</span><br></pre></td></tr></table></figure></p>
<p>sort有几个很不错的选项。一个是次要排序键,即一个能够产生可用于排序的值的函数。例如,可以通过长度对一组字符串进行排序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [401]:x=[&apos;xxx&apos;,&apos;xxx&apos;,...]</span><br><span class="line">In [402]:x.sort(key=len)</span><br></pre></td></tr></table></figure></p>
<h4 id="二分搜索及维护有序列表"><a href="#二分搜索及维护有序列表" class="headerlink" title="二分搜索及维护有序列表"></a>二分搜索及维护有序列表</h4><p>内置的bisect模块实现了二分查找以及对有序列表的插入操作。bisect.bisect可以找出新元素应该被插入到哪个位置才能保持原列表的有序性,而bisect.insort则确实地将新元素插入到那个位置上去（但bisect不会判断原列表是否有序）。</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>通过切片标记法,你可以选取序列类型(数组、元组、NumPy数组等)的子集,其基本形式由索引运算符([])以及传入其中的start:stop构成。(stop未包含在其中)<br>负数索引从序列的末尾开始切片。</p>
<p>还可以在第二个冒号后面加上步长<br>(step)。比如每隔一位取出一个元素:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [418]: seq[::2]</span><br></pre></td></tr></table></figure></p>
<p>在这里使用-1是一个很巧妙的办法,它可以实现列表或元组的反序:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [419]: seq[::-1]</span><br></pre></td></tr></table></figure></p>
<h4 id="内置的序列函数"><a href="#内置的序列函数" class="headerlink" title="内置的序列函数"></a>内置的序列函数</h4><h5 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate"></a>enumerate</h5><p>在对一个序列进行迭代时,常常需要跟踪当前项的索引。Python内置了一个enumerate函数,它可以逐个返回序列的(i,value)元组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i,value in enumerate(collection):</span><br><span class="line">  #用value做一些事情</span><br></pre></td></tr></table></figure></p>
<p>在对数据进行索引时,enumerate还有一种不错的使用模式,即求取一个将序列值(假定是唯一的)映射到其所在位置的字典。<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [420]: some_list=[&apos;foo&apos;,&apos;bar&apos;,baz&apos;]</span><br><span class="line">In [421]: mapping = dict((v, i) for i,v in enumerate(some_list))</span><br><span class="line">In [422]: mapping</span><br><span class="line">Out[422]:&#123;&apos;bar&apos;:1,&apos;baz&apos;:2,&apos;foo&apos;:0&#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="sorted"><a href="#sorted" class="headerlink" title="sorted"></a>sorted</h5><p>sorted函数可以将任何序列返回为一个新的有序列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [423]: sorted([x,...])</span><br></pre></td></tr></table></figure></p>
<p>常常将sorted和set结合起来使用以得到一个由序列中的唯一元素组成的有序列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [425]: sorted(set(&apos;xxxxxxxxx&apos;))</span><br></pre></td></tr></table></figure></p>
<h5 id="zip"><a href="#zip" class="headerlink" title="zip"></a>zip</h5><p>zip用于将多个序列(列表、元组等)中的元素“配对”,从而产生一个新的元组列表。</p>
<p>zip可以接受任意数量的序列,最终得到的元组数量由最短的序列决定:</p>
<p>zip最常见的用法是同时迭代多个序列,还可以结合enumerate一起使用:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [431]: for i, (a, b) in enumerate(zip(seq1,seq2)):</span><br><span class="line">print(&apos;%d:%s,%s&apos;%(i,a,b))</span><br><span class="line">0:seq1.x1,seq2.y1</span><br><span class="line">1:seq1.x2,seq2.y2</span><br><span class="line">2:seq1.x3,seq2.y3</span><br></pre></td></tr></table></figure></p>
<p>对于“已压缩的”(zipped)序列,zip还有一个很巧妙的用法,即对该序列进行“解压”(unzip)。其实就是将一组行转换为一组:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [433]: first_xs,last_xs=zip(*seqs)</span><br></pre></td></tr></table></figure></p>
<h5 id="reversed"><a href="#reversed" class="headerlink" title="reversed"></a>reversed</h5><p>reversed用于按逆序迭代序列中的元<br>素:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [436]: list(reversed(range(10))</span><br><span class="line">0ut[436]: [9,8,7,6,5,4,3,2,1,0]</span><br></pre></td></tr></table></figure></p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>字典(dict)可算是Python中最重要的内置数据结构。它更常见的名字是哈希映射(hash map)或相联数组(associative array)。它是一种大小可变的键值对集,其中的键(key)和值(value)都是Python对象。创建字典的方式之一是:使用大括号({})并用冒号分隔键和值。</p>
<p>keys和values方法分别用于获取键和值的列表。虽然键值对没有特定的顺序,但这两个函数会以相同的顺序输出键和值:</p>
<p>Python 3中dict.keys()和dict.values()会返回迭代器而不是列表。</p>
<p>利用update方法,一个字典可以被合并到另一个字典中去:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [451]: x1.update(&#123;x:&apos;xxx&apos;,&apos;x&apos;:xxx&#125;)</span><br></pre></td></tr></table></figure></p>
<p>从序列类型创建字典有时你可能会想将两个序列中的元素两两配对地组成一个字典。粗略分析一下之后,你可能会写出这样的代码:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mapping=&#123;&#125;</span><br><span class="line">for key,value in zip(key_list,value_list):</span><br><span class="line">  mapping[key]=value</span><br></pre></td></tr></table></figure></p>
<p>由于字典本质上就是一个二元元组集,所以我们完全可以用dict类型函数直接处理二元元组列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [453]: mapping = dict(zip(range(5),reversed(range(5))))</span><br></pre></td></tr></table></figure></p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>下面这样的逻辑很常见:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if key in some_dict:</span><br><span class="line">  value=some_dict[key]</span><br><span class="line">else:</span><br><span class="line">  value = default value</span><br></pre></td></tr></table></figure></p>
<p>其实dict的get和pop方法可以接受一个可供返回的默认值,于是,上面的if-else块就可以被简单地写成:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">value=some_dict.get(key,default value)</span><br></pre></td></tr></table></figure></p>
<p>如果key不存在,则get默认返回None,而pop则会引发一个异常。在设置值的时候,常常会将字典中的值处理成别的集类型(比如列表)。例如,根据首字母对一组单词进行分类并最终产生一个由列表组成的字典:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In[455]:words=[&apos;apple&apos;,&apos;bat&apos;,&apos;bar&apos;,&apos;atom&apos;,&apos;book&apos;]</span><br><span class="line">In [456]: by_letter = &#123;&#125;</span><br><span class="line">In [457] : for word in words:letter=word[0]</span><br><span class="line">  if letter not in by_letter:</span><br><span class="line">    by_letter[letter]=[word]</span><br><span class="line">  else:</span><br><span class="line">    by_letter[letter]. append(n</span><br><span class="line">In [458]: by_letter</span><br><span class="line">Out[458]:&#123;&apos;a&apos;:[&apos;apple&apos;,&apos;atom&apos;],&apos;b&apos;:[&apos;bat&apos;,&apos;bar&apos;,&apos;book&apos;]&#125;</span><br></pre></td></tr></table></figure>
<p>字典的setdefault方法刚好能达到这个目的。上面的if-else块可以写成:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">by_letter.setdefault(letter,[]).append(word)</span><br></pre></td></tr></table></figure>
<p>内置的collections模块有一个叫做defaultdict的类,它可以使该过程更简单。传入一个类型或函数(用于生成字典各插槽所使用的默认值)即可创建出一个defaultdict:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from collections import defaultdict</span><br><span class="line"></span><br><span class="line">by_letter = defaultdict(list)</span><br><span class="line"></span><br><span class="line">for word in words:</span><br><span class="line">  by_letter[word[0]].append(word)</span><br></pre></td></tr></table></figure>
<p>defaultdict的初始化器只需要一个可调用对象(例如各种函数),并不需要明确的类型。因此,如果你想要将默认值设置为4,只需传入一个能够返回4的函数即可:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">counts=defaultdict(1ambda:4)</span><br></pre></td></tr></table></figure>
<h4 id="字典键的有效类型"><a href="#字典键的有效类型" class="headerlink" title="字典键的有效类型"></a>字典键的有效类型</h4><p>虽然字典的值可以是任何Python对象,但键必须是不可变对象,如标量类型(整数、浮点数、字符串)或元组(元组中的所有对象也必须是不可变的)。</p>
<h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><p>集合Set是由唯一元素组成的无序集</p>
<p><img alt="image" data-src="https://i.loli.net/2019/06/09/5cfd13314501789880.jpg" class="lozad"></p>
<h4 id="列表-集合-字典推导式"><a href="#列表-集合-字典推导式" class="headerlink" title="列表,集合,字典推导式"></a>列表,集合,字典推导式</h4><p>列表推导式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[expr for val in collection if condition]</span><br></pre></td></tr></table></figure></p>
<p>这相当于下面这段for循环:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">result = [ ]</span><br><span class="line">for val in collection:</span><br><span class="line">  if condition:</span><br><span class="line">    result . append ( expr )</span><br></pre></td></tr></table></figure></p>
<p>过滤器条件可以省略,只留下表达式。<br>集合和字典的推导式是该思想的一种自然延伸,它们的语法差不多,只不过产生的是集合和字典而已。字典推导式的基本形式如下:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">dict_comp=&#123;key-expr:value-expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure></p>
<p>集合推导式跟列表推导式非常相似,唯一的区别就是它用的是花括号而不是方括号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set_comp=&#123;expr for value in collection if condition&#125;</span><br></pre></td></tr></table></figure>
<h4 id="函数亦为对象"><a href="#函数亦为对象" class="headerlink" title="函数亦为对象"></a>函数亦为对象</h4><p>由于Python函数都是对象,因此,在其他语言中较难表达的一些设计思想在Python中就要简单很多了。假设我们有下面这样一个字符串数组,希望对其进行一些数据清理工作并执行一堆转换:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">states = [ &apos; Alabama &apos; , &apos; Georgia ! &apos; , &apos; Georgia&apos;,&apos;georgia&apos;,&apos;F10rIda&apos;,&apos;south carolina##&apos;,&apos;West virginia?&apos;]</span><br></pre></td></tr></table></figure>
<p>不管是谁,只要处理过由用户提交的调查数据,就能明白这种乱七八糟的数据是怎么一回事。为了得到一组能用于分析工作的格式统一的字符串,需要做很多事情:去除空白符、删除各种标点符号、正确的大写格式等。牟一看上去,我们可能会写出下面这样的代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re # 正则表达式模块</span><br><span class="line">def clean_strings(strings):</span><br><span class="line">  result = [ ]</span><br><span class="line">  for value in strings:</span><br><span class="line">    value = value . strip ( )</span><br><span class="line">    value = re . sub ( &apos; ! ! #? ] &apos; , &apos;&apos; , value)#移除标点符号</span><br><span class="line">    value =value.title()</span><br><span class="line">    result.append(value)</span><br><span class="line">  return result</span><br></pre></td></tr></table></figure>
<p>最终结果如下所示:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [15]: clean_strings(states)</span><br><span class="line">Out[15]:</span><br><span class="line">[&apos;Alabama&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Florida&apos;,</span><br><span class="line">&apos;South Carolina&apos;,</span><br><span class="line">&apos; West Virginia &apos; ]</span><br></pre></td></tr></table></figure></p>
<p>其实还有另外一种不错的办法:将需要在一组给定字符串上执行的所有运算做成一个列表:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def remove_punctuation(value):</span><br><span class="line">  return re.sub ( &apos;!#?&apos;,&apos;&apos;, value)</span><br><span class="line"></span><br><span class="line">clean_ops=[str.strip,remove_punctuation,str.title]</span><br><span class="line"></span><br><span class="line">def clean_strings(strings,ops):</span><br><span class="line">  result = [ ]</span><br><span class="line">  for value in strings:</span><br><span class="line">    for function in ops:</span><br><span class="line">      value=function(value)</span><br><span class="line">    result.append (value)</span><br><span class="line">  return result</span><br></pre></td></tr></table></figure></p>
<p>然后我们就有了:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [22]: clean_strings(states,clean_ops)</span><br><span class="line">Out[22]:</span><br><span class="line">[&apos;Alabama&apos;</span><br><span class="line">&apos;Georgia&apos;,</span><br><span class="line">&apos;Georgia&apos;</span><br><span class="line">&apos;Georgia&apos;,</span><br><span class="line">&apos;Florida&apos;,</span><br><span class="line">&apos;South Carolina&apos;,</span><br><span class="line">&apos;West Virginia&apos;]</span><br></pre></td></tr></table></figure></p>
<h4 id="闭包-返回函数的函数"><a href="#闭包-返回函数的函数" class="headerlink" title="闭包:返回函数的函数"></a>闭包:返回函数的函数</h4><p>闭包(closure)就是由其他函数动态生成并返回的函数。其关键性质是,被返回的函数可以访问其创建者的局部命名空间中的变量。</p>
<p>闭包和标准Python函数之间的区别在于:即使其创建者已经执行完毕,闭包仍能继续访问其创建者的局部命名空间。虽然闭包的内部状态一般都是静态的,但也允许使用可变对象(如字典、集合、列表等可以被修改的对象)。例如,下面这个函数可以返回一个能够记录其参数(曾经传入的一切参数)的函数:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def make_watcher():</span><br><span class="line">  have seen = &#123;&#125;</span><br><span class="line">  </span><br><span class="line">  def has_been_seen(x):</span><br><span class="line">    if x in have seen:</span><br><span class="line">      return True</span><br><span class="line">    else:</span><br><span class="line">      have_seen[x]=True</span><br><span class="line">      return False</span><br><span class="line">  </span><br><span class="line">  return has been seen</span><br></pre></td></tr></table></figure></p>
<p>对一组整数使用该函数,可以得到:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [496]:watcher=make_watcher()</span><br><span class="line">In [497]:vals=[5,6,1,5,1,6,3,5]</span><br><span class="line">In [498]: [watcher(x) for x in vals]</span><br><span class="line">Out[498]: [False, False, False, True, True, True, False, True]</span><br></pre></td></tr></table></figure>
<h4 id="生成器表达式"><a href="#生成器表达式" class="headerlink" title="生成器表达式"></a>生成器表达式</h4><p>生成器表达式(generator expression)是构造生成器的最简单方式。生成器也有一个类似于列表、字典、集合推导式的东西,其创建方式为,把列表推导式两端的方括号改成圆括号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(expr for val in collection if condition)</span><br></pre></td></tr></table></figure>
<p><a href="http://www.cnblogs.com/coder2012/p/4990834.html" target="_blank" rel="noopener">生成器与yiely补充</a></p>
<h4 id="itertools模块"><a href="#itertools模块" class="headerlink" title="itertools模块"></a>itertools模块</h4><p>标准库itertools模块中有一组用于许多常见数据算法的生成器。例如,groupby可以接受任何序列和一个函数。它根据函数的返回值对序列中的连续元素进行分组。下面是一个例子:<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">In [514]: import itertools</span><br><span class="line">In [515]: first_letter = lambda x: x[0]</span><br><span class="line">In [516]: names = [&apos;Alan&apos;, &apos;Adam&apos;, &apos;Wes&apos;,Will&apos;,&apos;Albert&apos;,&apos;Steven&apos;]</span><br><span class="line">In [517]: for letter, names in itertools. groupby(names,first_letter):</span><br><span class="line">print letter,list(names)#names是一个生成器</span><br><span class="line"></span><br><span class="line">A [ &apos; Alan &apos; , &apos; Adam &apos; ]</span><br><span class="line">......</span><br></pre></td></tr></table></figure></p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">小废在不在、</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://yoursite.com/2019/03/29/python数据分析-2/">http://yoursite.com/2019/03/29/python数据分析-2/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://yoursite.com">小废在不在、</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/python/">python    </a><a class="post-meta__tags" href="/tags/DataAnalysis/">DataAnalysis    </a></div><div class="post_share"><div class="addthis_inline_share_toolbox"></div><script src="//s7.addthis.com/js/300/addthis_widget.js#pubid=ra-5c47ca989fc62bc0" async></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/04/01/Python基础学习笔记-1/"><img class="prev_cover lozad" data-src="https://i.loli.net/2019/09/02/en6ws8lVRy4jv7Z.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">上一篇</div><div class="prev_info"><span>python基础学习笔记-1</span></div></a></div><div class="next-post pull-right"><a href="/2019/03/27/python数据分析-1/"><img class="next_cover lozad" data-src="https://i.loli.net/2019/10/02/Vu4YPURokEQf3zW.png" onerror="onerror=null;src='/img/404.jpg'"><div class="label">下一篇</div><div class="next_info"><span>python数据分析[1]</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-fw fa-thumbs-up" aria-hidden="true"></i><span> 相关推荐</span></div><div class="relatedPosts_list"><div class="relatedPosts_item"><a href="/2019/06/10/python数据分析-3/" title="python数据分析-3"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/02/dZEXBfu9QLeCxWP.png"><div class="relatedPosts_title">python数据分析-3</div></a></div><div class="relatedPosts_item"><a href="/2019/03/27/python数据分析-1/" title="python数据分析[1]"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/03/ymbgADQ1PW3LkiR.png"><div class="relatedPosts_title">python数据分析[1]</div></a></div><div class="relatedPosts_item"><a href="/2019/04/01/Python基础学习笔记-2/" title="python基础学习笔记-2"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/03/DLw5GvOpm38rkIg.jpg"><div class="relatedPosts_title">python基础学习笔记-2</div></a></div><div class="relatedPosts_item"><a href="/2019/04/01/Python基础学习笔记-1/" title="python基础学习笔记-1"><img class="relatedPosts_cover lozad" data-src="https://i.loli.net/2019/09/03/ymbgADQ1PW3LkiR.png"><div class="relatedPosts_title">python基础学习笔记-1</div></a></div></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i><span> 评论</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = false == true ? true : false;
var verify = false == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'zWtJNyAP6AMppEFvVIb9F1np-gzGzoHsz',
  appKey:'iPnURTTXpBCzw1tbFQlqEbpl',
  placeholder:'在我的小小世界里留下你的驻足',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'zh-cn',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2018 - 2019 By 小废在不在、</div><div class="framework-info"><span>驱动 </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">喜欢你却没能及时告诉你,我是 <a href="https://fjken.top">小废</a> ,那么我有荣幸能让你看到吗 ?</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><a id="to_comment" href="#post-comment"><i class="scroll_to_comment fa fa-comments"></i></a><i class="fa fa-book" id="readmode" title="阅读模式"> </i><i class="fa fa-plus" id="font_plus" title="放大字体"></i><i class="fa fa-minus" id="font_minus" title="缩小字体"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="简繁转换">简</a><i class="fa fa-moon-o nightshift" id="nightshift" title="夜间模式"></i></section><div id="post_bottom"><div id="post_bottom_items"><a id="mobile_to_comment" href="#post-comment"><i class="mobile_scroll_to_comment fa fa-comments"></i></a><i class="fa fa-list" id="mobile_toc"></i><div id="toc_mobile"><div class="toc_mobile_headline">目录</div><ol class="toc_mobile_items"><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#Python解释器"><span class="toc_mobile_items-number">1.</span> <span class="toc_mobile_items-text">Python解释器</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-3"><a class="toc_mobile_items-link" href="#基础知识"><span class="toc_mobile_items-number">2.</span> <span class="toc_mobile_items-text">基础知识</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#语言语义"><span class="toc_mobile_items-number">2.1.</span> <span class="toc_mobile_items-text">语言语义</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#缩进-而不是大括号"><span class="toc_mobile_items-number">2.2.</span> <span class="toc_mobile_items-text">缩进,而不是大括号</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#变量和按引用传递"><span class="toc_mobile_items-number">2.3.</span> <span class="toc_mobile_items-text">变量和按引用传递</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#动态引用-强类型"><span class="toc_mobile_items-number">2.4.</span> <span class="toc_mobile_items-text">动态引用,强类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#属性和方法"><span class="toc_mobile_items-number">2.5.</span> <span class="toc_mobile_items-text">属性和方法</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#“鸭子”类型"><span class="toc_mobile_items-number">2.6.</span> <span class="toc_mobile_items-text">“鸭子”类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#引入-import"><span class="toc_mobile_items-number">2.7.</span> <span class="toc_mobile_items-text">引入(import)</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二元运算符和比较运算符"><span class="toc_mobile_items-number">2.8.</span> <span class="toc_mobile_items-text">二元运算符和比较运算符</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#可变和不可变的对象"><span class="toc_mobile_items-number">2.9.</span> <span class="toc_mobile_items-text">可变和不可变的对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#字符串"><span class="toc_mobile_items-number">2.10.</span> <span class="toc_mobile_items-text">字符串</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#None"><span class="toc_mobile_items-number">2.11.</span> <span class="toc_mobile_items-text">None</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#日期和时间"><span class="toc_mobile_items-number">2.12.</span> <span class="toc_mobile_items-text">日期和时间</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#排序"><span class="toc_mobile_items-number">2.13.</span> <span class="toc_mobile_items-text">排序</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#二分搜索及维护有序列表"><span class="toc_mobile_items-number">2.14.</span> <span class="toc_mobile_items-text">二分搜索及维护有序列表</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#切片"><span class="toc_mobile_items-number">2.15.</span> <span class="toc_mobile_items-text">切片</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#内置的序列函数"><span class="toc_mobile_items-number">2.16.</span> <span class="toc_mobile_items-text">内置的序列函数</span></a><ol class="toc_mobile_items-child"><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#enumerate"><span class="toc_mobile_items-number">2.16.1.</span> <span class="toc_mobile_items-text">enumerate</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#sorted"><span class="toc_mobile_items-number">2.16.2.</span> <span class="toc_mobile_items-text">sorted</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#zip"><span class="toc_mobile_items-number">2.16.3.</span> <span class="toc_mobile_items-text">zip</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-5"><a class="toc_mobile_items-link" href="#reversed"><span class="toc_mobile_items-number">2.16.4.</span> <span class="toc_mobile_items-text">reversed</span></a></li></ol></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#字典"><span class="toc_mobile_items-number">2.17.</span> <span class="toc_mobile_items-text">字典</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#默认值"><span class="toc_mobile_items-number">2.18.</span> <span class="toc_mobile_items-text">默认值</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#字典键的有效类型"><span class="toc_mobile_items-number">2.19.</span> <span class="toc_mobile_items-text">字典键的有效类型</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#集合"><span class="toc_mobile_items-number">2.20.</span> <span class="toc_mobile_items-text">集合</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#列表-集合-字典推导式"><span class="toc_mobile_items-number">2.21.</span> <span class="toc_mobile_items-text">列表,集合,字典推导式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#函数亦为对象"><span class="toc_mobile_items-number">2.22.</span> <span class="toc_mobile_items-text">函数亦为对象</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#闭包-返回函数的函数"><span class="toc_mobile_items-number">2.23.</span> <span class="toc_mobile_items-text">闭包:返回函数的函数</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#生成器表达式"><span class="toc_mobile_items-number">2.24.</span> <span class="toc_mobile_items-text">生成器表达式</span></a></li><li class="toc_mobile_items-item toc_mobile_items-level-4"><a class="toc_mobile_items-link" href="#itertools模块"><span class="toc_mobile_items-number">2.25.</span> <span class="toc_mobile_items-text">itertools模块</span></a></li></ol></li></ol></div></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script async src="/js/search/local-search.js"></script><script src="https://cdn.jsdelivr.net/npm/animejs@latest/anime.min.js"></script><script src="/js/third-party/fireworks.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="/js/third-party/canvas-ribbon.js" size="150" alpha="0.6" zindex="-1" data-click="false"></script><script src="/js/activate-power-mode.js"></script><script>POWERMODE.colorful = true; // make power mode colorful
POWERMODE.shake = true; // turn off shake
document.body.addEventListener('input', POWERMODE);
</script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script>const observer = lozad(); // lazy loads elements with default selector as '.lozad'
observer.observe();</script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">本地搜索</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>由</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a>
 <span>提供支持</span></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>